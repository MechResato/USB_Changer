   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "main.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_VADC_GLOBAL_GetDetailedResult,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	XMC_VADC_GLOBAL_GetDetailedResult:
  23              	.LFB66:
  24              	 .file 1 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_vadc.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @file xmc_vadc.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @date 2019-12-02
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-15:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Initial <br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-20:
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised for XMC1201 device.<br>
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-04-27:
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for SHS.<br>
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added New APIs for trigger edge selection.<BR>
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for Queue flush entries, boundary selection, Boundary node pointer.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised GatingMode APIs and EMUX Control Init API.<BR>
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-20:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-25:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - BFL configuration in channel initialization fixed.
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-07-28:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - CLOCK_GATING_SUPPORTED and PERIPHERAL_RESET_SUPPORTED macros used
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC13 XMC12 and XMC14
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC44 XMC47 and XMC48
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GLOBAL_SetIndividualBoundary
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetIndividualBoundary
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAlias
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetInputClass
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelSetIclass
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetResultAlignment
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetInputClass
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultSubtractionValue
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC4300 device supported
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_TriggerEvent API updated. OR operation removed.
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_ClearEvent API updated. Multiple events triggering on clearing the event i
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Wrong MACRO name defined in xmc_vadc_map.h file corrected for XMC4200/4100 devices.
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       XMC_VADC_G3_SAMPLE renamed to XMC_VADC_G1_SAMPLE
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the analog calibration voltage for XMC1100 to external reference upper supply range.
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the XMC_VADC_GLOBAL_StartupCalibration() for XMC1100.
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-09:
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Optimization of write only registers
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-18:
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_IsConverterReady(): API checks the STEPCFG register for the read
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       SHSCFG SFR.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-06-17:
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New macros added XMC_VADC_SHS_FULL_SET_REG, XMC_VADC_RESULT_PRIORITY_AVAILABLE
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New Enum added XMC_VADC_SHS_GAIN_LEVEL_t and XMC_VADC_SYNCTR_EVAL_t
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs added are:
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncSlaveReadySignal
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetAssertedEvents
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAssertedResultEvents
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultRegPriority
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncReadySignal
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetSyncReadySignal
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetResultRegPriority
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-02-06:
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new functions to remove channels from background request source, XMC_VADC_GLOBAL_Bac
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-06-24:
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new function XMC_VADC_GLOBAL_SHS_SetAnalogReference() for XMC1 family
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-08-14:
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GLOBAL_DETAILED_RESULT_t
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       You can cast the return of XMC_VADC_GLOBAL_GetDetailedResult() to a varible of type XMC_VA
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() to update AREF bitfield correctly
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-03-30:
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Changed XMC_VADC_GROUP_SetChannelAlias() to inline function
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetChannelAlias()
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-12-02:
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fix including files following the convention: angle brackets are used for standard include
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-09-03:
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetPowerMode()
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-11-11:
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() and XMC_VADC_GROUP_SetChannelAlias()
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @endcond
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifndef XMC_VADC_H
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_H
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * HEADER FILES
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_common.h"
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_scu.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_vadc_map.h"
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup XMClib XMC Peripheral Library
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup VADC
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @brief Versatile Analog to Digital Converter (VADC) driver for XMC microcontroller family.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC microcontroller provides a series of analog input channels connected to a cluster of Ana
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Converters using the Successive Approximation Register (SAR) principle to convert analog input v
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * to discrete digital values.
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC1
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC1x is based on Sample & Hold converters, where a cluster contains 2 Sample&Hold units whi
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter.
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter of the ADC cluster can operate independent of the others, controlled by a dedicat
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * registers and triggered by a dedicated group request source. The results of each channel can be 
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * dedicated channel-specific result register or in a group-specific result register.<BR>
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Versatile Analog to Digital Converter module (VADC) of the XMC comprises a set of converter 
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can be operated either independently or via a common request source that emulates a background c
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter block is equipped with a dedicated input multiplexer and dedicated request source
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * which together build separate groups.
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC4
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc4x.png"
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \else
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc1x.png"
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The VADC LLD is split into GLOBAL and GROUP related APIs.<BR>
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GLOBAL: </B><BR>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Global APIs act on the entire ADC module. Configures global configuration registers</LI>
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Allows configuration of the background request source of the VADC.</LI>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The clock related configurations for the VADC module are configured in the Global APIs/</LI>
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Global API names are prefixed by the \b XMC_VADC_GLOBAL_ and they accept ::XMC_VADC_GLOB
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the background request source of the VADC. The APIs which act on the background r
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_Background</LI>
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the sample and hold unit of the VADC. The APIs which act on the SHS related regis
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_SHS_</LI>
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GROUP: </B><BR>
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Group APIs act on a VADC group. Configures the group configuration registers</LI>
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the queue request source of the VADC. The APIs which act on the queue related reg
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Queue</LI>
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the scan request source of the VADC. The APIs which act on the scan related regis
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Scan</LI>
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configuration of the channels of each group are done by the API which have a prefix as
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     \b XMC_VADC_GROUP_Channel.</LI>
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Group API names are prefixed by the \b XMC_VADC_GROUP_ and they accept ::XMC_VADC_GROUP_
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * MACROS
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if ((UC_SERIES == XMC42)||(UC_SERIES == XMC41) || (UC_SERIES == XMC43))
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE           (1U) /*  Defines the availability of group resource in a
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE           (1U) /*  Defines the availability of scan request resour
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE           (1U) /*  Defines the availability of queue request resou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE            (1U) /*  Defines the availability of external multiplexe
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE        (1U) /*  Defines the availability of boundary check supp
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS      (1U) /*  Defines the availability of synchronous request
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS        (2U) /*  Defines the maximum number of groups available 
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT      (1U) /*  Defines the availability of boundary flags in a
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE         (1U) /*  Defines the external multiplexer channel select
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE             (0U) /* Defines the availability of sample and hold modu
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG          (0U) /* Defines the availability of sample and hold modu
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE    (1U) /* Define the availability of a source specific res
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC44 || UC_SERIES == XMC47 || UC_SERIES == XMC48)
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC45)
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC14 || UC_SERIES == XMC13 || UC_SERIES == XMC12)
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (1U) /* Defines the availability of sample and hold module
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (1U) /* Define the availability of a priority for result
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC11)
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (0U) /*  Defines the availability of group resource in a d
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (0U) /*  Defines the availability of scan request resource
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (0U) /*  Defines the availability of queue request resourc
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (0U) /*  Defines the availability of external multiplexer 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (0U) /*  Defines the availability of boundary check suppor
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (0U) /*  Defines the availability of synchronous request s
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_START_UP_CAL_ACTIVE (3U) /*  Defines the need for SHS startup calibration acti
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 devices */
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_CONV_ENABLE_FOR_XMC11   (*(uint32_t*) 0x40010500UL) /*  Defines the additional err
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 device for effective working*/
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_PORTS               (16U) /* Defines the number of hardware ports that can be 
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     as triggers and gating signals */
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_RESULT_REGISTERS    (16U) /* Defines the number of result holding registers pe
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_CHANNELS_PER_GROUP  (8U)  /**< Defines the number of ADC channels per group */
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ENUMS
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef uint16_t XMC_VADC_RESULT_SIZE_t; /**< Type defined the converted result size to unsigned 16
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_GLOBAL_TypeDef XMC_VADC_GLOBAL_t; /**< Type defined the device header file vadc global
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC type*/
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_G_TypeDef XMC_VADC_GROUP_t; /**< Type defined the device header file vadc group regist
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC Group type*/
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef SHS_Type XMC_VADC_GLOBAL_SHS_t; /**< Type defined the sample and hold register structure*/
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the return status after execution of VADC specific API's. Use @ref XMC_VADC_STATUS_t fo
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STATUS
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_SUCCESS = 0,   /**< Returned when the API has been able to fulfill the callers re
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_ERROR          /**< Returned when the API cannot fulfill the request */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STATUS_t;
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various service requests lines. Each group can raise up to 4 service requests indep
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  all groups together have the possibility of raising 4 module wide service requests. Use @ref XM
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SR
 345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR0 = 0, /**< Group specific Service Request-0 */
 347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR1,     /**< Group specific Service Request-1 */
 348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR2,     /**< Group specific Service Request-2 */
 349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR3,     /**< Group specific Service Request-3 */
 350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR0,    /**< Module Wide Common Service Request-0 */
 351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR1,    /**< Module Wide Common Service Request-1 */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR2,    /**< Module Wide Common Service Request-2 */
 353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR3    /**< Module Wide Common Service Request-3 */
 354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SR_t;
 355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the mode of operation of a channel, when an ongoing conversion gets interrupted in betw
 358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_STARTMODE_t for this enumeration.
 359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STARTMODE
 361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_WFS = 0, /**< An ongoing conversion completes without interruption */
 363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CIR,     /**< An ongoing conversion can be interrupted and resumed later*/
 364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CNR     /**< An ongoing conversion can be interrupted and never resumed */
 365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STARTMODE_t;
 366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the edge sensitivity of the trigger signal which can assert a conversion.
 369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_EDGE_t for this enumeration.
 370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_EDGE
 372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_NONE = 0, /**< No external trigger. Conversion request can be asserted by s
 374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_FALLING,  /**< The falling edge of the external trigger can assert conversi
 375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_RISING,   /**< The rising edge of the external trigger can assert conversio
 376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_ANY       /**< Both the edges can assert conversion request */
 377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_EDGE_t;
 378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external trigger input selection possibilities, to assert a conversion. Refer the V
 381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  section of the reference manual for details of peripherals which can be used. Also refer xmc_va
 382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  detailed definitions of the peripherals which can take the control of these enumeration items.
 383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_INPUT_SELECT_t for this enumeration.
 384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_INPUT_SELECT
 386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_A = 0, /**< Trigger select signal A */
 388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_B,     /**< Trigger select signal B */
 389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_C,     /**< Trigger select signal C */
 390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_D,     /**< Trigger select signal D */
 391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_E,     /**< Trigger select signal E */
 392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_F,     /**< Trigger select signal F */
 393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_G,     /**< Trigger select signal G */
 394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_H,     /**< Trigger select signal H */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_I,     /**< Trigger select signal I */
 396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_J,     /**< Trigger select signal J */
 397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_K,     /**< Trigger select signal K */
 398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_L,     /**< Trigger select signal L */
 399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_M,     /**< Trigger select signal M */
 400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_N,     /**< Trigger select signal N */
 401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_O,     /**< Trigger select signal O */
 402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_P      /**< Trigger select signal P */
 403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_INPUT_SELECT_t;
 405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external gating input selection possibilities, to gate the conversion requests. Ref
 408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  interconnects section of the reference manual for details of peripherals which can be used. Als
 409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of t
 410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  items. Use @ref XMC_VADC_GATE_INPUT_SELECT_t for this enumeration.
 411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATE_INPUT_SELECT
 413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_A = 0, /**< Gating select signal A */
 415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_B,     /**< Gating select signal B */
 416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_C,     /**< Gating select signal C */
 417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_D,     /**< Gating select signal D */
 418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_E,     /**< Gating select signal E */
 419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_F,     /**< Gating select signal F */
 420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_G,     /**< Gating select signal G */
 421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_H,     /**< Gating select signal H */
 422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_I,     /**< Gating select signal I */
 423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_J,     /**< Gating select signal J */
 424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_K,     /**< Gating select signal K */
 425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_L,     /**< Gating select signal L */
 426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_M,     /**< Gating select signal M */
 427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_N,     /**< Gating select signal N */
 428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_O,     /**< Gating select signal O */
 429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_P      /**< Gating select signal P */
 430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATE_INPUT_SELECT_t;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the condition for gating the conversion requests. It can be used to set the ENGT field
 435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of ASMR/BSMR/QMR register respectively for auto_scan/background_scan/queue request sources.
 436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_GATEMODE_t for this enumeration.
 437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATEMODE
 439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_BLOCK = 0,  /**< External triggers are permanently blocked */
 441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_IGNORE,     /**< External triggers are unconditionally passed */
 442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVEHIGH, /**< External trigger is passed only if the gate signal is high */
 443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVELOW  /**< External trigger is passed only if the gate signal is low */
 444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATEMODE_t;
 445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion result handling mode. Use @ref XMC_VADC_DMM_t for this enumeration.
 448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_DMM
 450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_REDUCTION_MODE = 0, /**< Standard Data reduction mode*/
 452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_FILTERING_MODE,     /**< Provide option to select Finite Impulse Response Filter (FI
 453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                         Infinite Impulse Response Filter (IIR)*/
 454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_DIFFERENCE_MODE,    /**< Difference mode is selected*/
 455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DMM_t;
 456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the conversion mode. It defines the resolution of conversion. Use XMC_VADC_CONVMODE_t f
 459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CONVMODE
 461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_12BIT       = 0,  /**< Results of conversion are 12bits wide */
 463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_10BIT       = 1,  /**< Results of conversion are 10bits wide */
 464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_8BIT        = 2,  /**< Results of conversion are 8bits wide */
 465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_FASTCOMPARE = 5  /**< Input signal compared with a preset range */
 466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CONVMODE_t;
 467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the output of a fast compare mode. Use @ref XMC_VADC_FAST_COMPARE_t for
 470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  this enumeration.
 471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_FAST_COMPARE
 473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_LOW = 0, /**< Input lower than than programmed reference */
 475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_HIGH,    /**< Input higher than than programmed reference */
 476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_UNKNOWN  /**< Unknown, Conversion probably still ongoing */
 477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_FAST_COMPARE_t;
 478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the type of scan request source to be used. It can choose between auto scan and backgrou
 481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * source methods. Use @ref XMC_VADC_SCAN_TYPE_t for this enumeration.
 482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_TYPE
 484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_GROUPSCAN = 0, /**< Auto scan mode of operation selected. Also called as Group
 486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_BACKGROUND    /**< Background scan mode of operation selected. Also called as 
 487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_TYPE_t;
 488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the behavior of load event for the scan request source. Use @ref XMC_VADC_SCAN_LOAD_t fo
 491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_LOAD
 493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_OVERWRITE = 0, /**< The old set of channels is discarded in favor of the new s
 495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          awaiting conversion */
 496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_COMBINE       /**< The new set of channels are combined with the pending chann
 497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          previous set */
 498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_LOAD_t;
 499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion classes that can be selected for each channel. The enumeration members ho
 502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * global classes. The conversion classes decides the properties of conversion, like resolution, sa
 503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_CHANNEL_CONV_t for this enumeration.
 504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_CONV
 507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 = 0, /**< Conversion property set-0 specific to the group */
 509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS1,     /**< Conversion property set-1 specific to the group */
 510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,    /**< Conversion property set-0, Module wide */
 511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1    /**< Conversion property set-1, Module wide */
 512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONV_t;
 513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the references to boundary values used for limit checking feature. Each of these can be 
 516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * either an upper bound or a lower bound. Use @ref XMC_VADC_CHANNEL_BOUNDARY_t for this enumeratio
 517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY
 520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 = 0, /**< Group specific Boundary-0 value */
 522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1,     /**< Group specific Boundary-1 value */
 523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0,    /**< Module wide Boundary-0 value */
 524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1    /**< Module wide Boundary-1 value */
 525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_t;
 526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the voltage which the capacitor is charged to. Used in Broken wire detection feature. Us
 529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @ref XMC_VADC_CHANNEL_BWDCH_t for this enumeration.
 530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BWDCH
 532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAGND = 0, /**< Capacitor pre-charged to ground*/
 534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAREF     /**< Capacitor pre-charged to reference voltage*/
 535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BWDCH_t;
 536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Defines the criteria for event generation by the channel. Use @ref XMC_VADC_CHANNEL_EVGEN_t fo
 539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_EVGEN
 541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_NEVER     = 0,  /**< No event generated */
 543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_INBOUND   = 1U, /**< Event generated when the result is within the normal 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPHIGH  = 1U, /**< Event generated when the result of fast compare opera
 545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_OUTBOUND  = 2U, /**< Event generated when the result is outside the normal
 546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPLOW   = 2U, /**< Event generated when the result result of fast compar
 547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_ALWAYS    = 3U /**< Event generated always after conversion - unconditiona
 548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_EVGEN_t;
 549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the reference voltage selection for conversion. Use @ref XMC_VADC_CHANNEL_REF_t for this
 552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_REF
 554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_INTREF = 0, /**< Internal VARef */
 556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_ALT_CH0    /**< External voltage available on Channel-0 of the perticular gr
 557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_REF_t;
 558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the criteria for boundary flag assertion. Use @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t
 561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY_CONDITION
 564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND = 0, /**< Set Boundary condition criteria to asser
 566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND     /**< Set Boundary condition criteria to assert
 567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t;
 568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the event which can lead to a global service request assertion. Use @ref XMC_VADC_GLOBAL
 571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_EVENT
 574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE = VADC_GLOBEFLAG_SEVGLB_Msk, /**< Background scan request sourc
 576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_RESULT      = VADC_GLOBEFLAG_REVGLB_Msk  /**< Global result event */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_EVENT_t;
 578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the power modes of a VADC Group. Use @ref XMC_VADC_GROUP_POWERMODE_t for this enumeratio
 581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_POWERMODE
 583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_OFF       = 0, /**< Group is powered down */
 585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED1,     /**< Reserved */
 586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED2,     /**< Reserved */
 587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_NORMAL        /**< Group is powered up */
 588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_POWERMODE_t;
 589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the status of a VADC group (also known as kernel). Use @ref XMC_VADC_GROUP_STATE_t for 
 592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_STATE
 594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_IDLE = 0, /**< Idle and can convert if requested */
 596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_BUSY      /**< Busy with an ongoing conversion */
 597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_STATE_t;
 598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the reference to sample time and conversion mode settings. Use @ref XMC_VADC_GROUP_CONV
 601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_CONV
 604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_STD = 0, /**< Settings pertaining to channels directly attached to VADC modul
 606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_EMUX    /**< Settings pertaining to channels connected to VADC via EMUX */
 607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONV_t;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbiter behavior. Use @ref XMC_VADC_GROUP_ARBMODE_t for this enumera
 611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_ARBMODE
 613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ALWAYS = 0, /**< Arbiter runs all the time */
 615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ONDEMAND    /**< Arbiter runs only if a conversion request is asserted by 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                           request sources */
 617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_ARBMODE_t;
 618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX mode of operation. Use @ref XMC_VADC_GROUP_EMUXMODE_t for this enumeration.
 621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXMODE
 623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SWCTRL = 0,     /**< Perform EMUX in Software control mode*/
 625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_STEADYMODE,     /**< Perform EMUX in Steady mode (Use EMUX set value)*/
 626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SINGLEMODE,     /**< Perform EMUX in Single step mode*/
 627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE,   /**< Perform EMUX in Sequence mode*/
 628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXMODE_t;
 629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX channel selection encoding scheme. Use @ref XMC_VADC_GROUP_EMUXCODE_t for this
 632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXCODE
 634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_BINARY = 0, /**< A linearly incrementing code serves are MUX-SEL */
 636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_GRAY       /**< The MUX-SEL is gray encoded */
 637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCODE_t;
 638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the service request set used. Use @ref XMC_VADC_GROUP_IRQ_t for this enumeration.
 641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_IRQ
 643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_KERNEL = 0, /**< Refers to Group specific service request */
 645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_SHARED     /**< Refers to Module wide service request */
 646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_IRQ_t;
 647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the alignment of the converted result. Use @ref XMC_VADC_RESULT_ALIGN_t for this enumer
 650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_ALIGN
 652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_LEFT = 0,  /**< Always align result to left */
 654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_RIGHT      /**< Always align result to right */
 655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_ALIGN_t;
 656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_SUBTRATION
 658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_LEFT_ALIGN  = 0U,  /**< Always align result to left */
 660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_LEFT_ALIGN  = 2U,  /**< Always align result to left */
 662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_LEFT_ALIGN   = 4U,  /**< Always align result to left */
 664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_RIGHT_ALIGN  = 0U,  /**< Always align result to right */
 665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_SUBTRATION_t;
 666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbitration priority. Use @ref XMC_VADC_GROUP_RS_PRIORITY_t for this
 669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_RS_PRIORITY
 671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_0 = 0, /**< Lowest priority for the request source*/
 673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_1,     /**< Second lowest priority for the request source*/
 674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_2,     /**< Second highest priority for the request source*/
 675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_3,     /**< Highest priority for the request source*/
 676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_RS_PRIORITY_t;
 677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various modes for the boundary flag. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t f
 680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_BOUNDARY_FLAG_MODE
 682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED = 0,       /**< Disable boundary flag*/
 684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED,            /**< Always enable boundary*/
 685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW, /**< Enable boundary flag when gate level i
 686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH /**< Enable boundary flag when gate level i
 687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t;
 688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the boundary select for Channel. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t for this 
 692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_SELECT
 694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_LOWER_BOUND = 0U,       /**< Select the lower boundary*/
 696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_UPPER_BOUND = 2U        /**< Selects the upper boundary*/
 697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_SELECT_t;
 698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the group indices. Use @ref XMC_VADC_GROUP_INDEX_t for this enumeration.
 702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_INDEX
 704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_0   = 0,
 706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_1,
 707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_2,
 709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_3
 710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_INDEX_t;
 712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * Defines channel alias.
 715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * All enum items are available for channels 0 and 1. Other Channels can accept only XMC_VADC_CHANNE
 716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** */
 717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_ALIAS
 718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_DISABLED = -1,
 720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH0 = 0,
 721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH1 = 1,
 722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH2 = 2,
 723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH3 = 3,
 724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH4 = 4,
 725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH5 = 5,
 726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH6 = 6,
 727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH7 = 7
 728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_ALIAS_t;
 729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selection of the reference voltage that is required for conversions (VREF).
 734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_AREF
 736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_EXTERNAL_VDD_UPPER_RANGE = 0 << SHS_SHSCFG_AREF_Pos, /**< External refer
 738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_UPPER_RANGE = 2 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_LOWER_RANGE = 3 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_AREF_t;
 741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the gain calibration selection.
 745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_GAIN_LEVEL
 747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_0 = SHS_CALOC0_CALOFFVAL0_Pos, /**< Select the calibration value for gain
 749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_1 = SHS_CALOC0_CALOFFVAL1_Pos, /**< Select the calibration value for gain
 750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_2 = SHS_CALOC0_CALOFFVAL2_Pos, /**< Select the calibration value for gain
 751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_3 = SHS_CALOC0_CALOFFVAL3_Pos  /**< Select the calibration value for gain
 752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_GAIN_LEVEL_t;
 753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the Delta sigma loop.
 757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_LOOP_CH
 759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_0 = SHS_LOOP_LPCH0_Pos, /**< Select Delta-sigma loop 0*/
 761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_1 = SHS_LOOP_LPCH1_Pos /**< Select Delta-sigma loop 1*/
 762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_LOOP_CH_t;
 763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides the order in which the SHS should do the calibration
 766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER
 768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_POST_CONV = 0, /**< Calibration occur after conversion take
 770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_PRE_CONV   /**< Calibration occur before conversion takes p
 771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t;
 772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides possible routing values for the boundary flag.
 777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_NODE
 779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_0 = 0U, /**<Route the Group boundary flag to Common b
 781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_1,      /**<Route the Group boundary flag to Common b
 782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_2,      /**<Route the Group boundary flag to Common b
 783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_3,      /**<Route the Group boundary flag to Common b
 784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_0,  /**<Route the Group boundary flag to Common Service Req
 785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_1,  /**<Route the Group boundary flag to Common Service Req
 786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_2,  /**<Route the Group boundary flag to Common Service Req
 787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_3   /**<Route the Group boundary flag to Common Service Req
 788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_NODE_t;
 789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 791:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 792:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 793:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the ready signal selection
 794:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 795:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SYNCTR_EVAL
 796:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 797:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_1 = VADC_G_SYNCTR_EVALR1_Msk, /**<Mask to set the EVAL1 bits of SYNCTR */
 798:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 799:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_2 = VADC_G_SYNCTR_EVALR2_Msk, /**<Mask to set the EVAL2 bits of SYNCTR */
 800:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_3 = VADC_G_SYNCTR_EVALR3_Msk  /**<Mask to set the EVAL3 bits of SYNCTR */
 801:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 802:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SYNCTR_EVAL_t;
 803:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 804:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 805:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DATA STRUCTURES
 806:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 807:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard start*/
 808:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
 809:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma push
 810:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma anon_unions
 811:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
 812:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning 586
 813:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 814:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 815:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 816:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC scan request source. Use type @ref XMC_VADC_SCAN_CONFIG_t for t
 817:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 818:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_SCAN_CONFIG
 819:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 820:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 821:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how scan request source would
 822:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 823:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter. If the Conversion s
 824:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          selected as Cancel inject repeat/Never mode then this fiel
 825:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          priority of scan request source. Uses @ref XMC_VADC_GROUP_
 826:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 827:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 828:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 829:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 830:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 831:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Use any one Group related result register as the 
 832:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
 833:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
 834:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 835:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 836:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 837:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 838:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger. U
 839:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_INPUT_SELECT_t enumeration*/
 840:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 841:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal. Uses @ref
 842:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_EDGE_t */
 843:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 844:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating. Us
 845:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_GATE_INPUT_SELECT_t */
 846:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
 847:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Decides whether timer mode for equi-distant sampl
 848:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       activated or not.*/
 849:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
 850:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 851:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asctrl;
 852:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 853:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 854:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 855:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 856:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 857:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 2;
 858:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversions be initiated by external hardware trigger 
 859:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t req_src_interrupt  : 1;  /**< Request source event can be generated after a conversi
 860:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_auto_scan   : 1;  /**< Enables the continuous conversion mode. Conversion com
 861:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  of the last channel in a scan sequence will cause 
 862:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t load_mode          : 1;  /**< Selects load event mode. Uses @ref XMC_VADC_SCAN_LOAD_
 863:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 26;
 864:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 865:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asmr;
 866:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 867:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_CONFIG_t;
 868:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 869:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 870:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef XMC_VADC_SCAN_CONFIG_t XMC_VADC_BACKGROUND_CONFIG_t; /**< Type defined the scan configurati
 871:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                  structure for background Request S
 872:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 873:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 874:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC channel. Use type XMC_VADC_CHANNEL_CONFIG_t for this enumeratio
 875:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 876:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_CHANNEL_CONFIG
 877:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 878:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 879:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 880:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 881:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 882:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t input_class                : 2;  /**< Input conversion class selection.
 883:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_CONV_t */
 884:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 2;
 885:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t lower_boundary_select      : 2;  /**< Which boundary register serves as lower bound?
 886:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 887:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t upper_boundary_select      : 2;  /**< Which boundary register serves as upper bound?
 888:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 889:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_criteria         : 2;  /**< When should an event be generated?
 890:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_EVGEN_t */
 891:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sync_conversion            : 1;  /**< Enables synchronous conversion for the configu
 892:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t alternate_reference        : 1;  /**< Input reference voltage selection either VARef
 893:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_REF_t*/
 894:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 4;
 895:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_reg_number          : 4;  /**< Group result register number */
 896:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t use_global_result          : 1;  /**< Use global result register for background requ
 897:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_alignment           : 1;  /**< Alignment of the results read in the result re
 898:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_RESULT_ALIGN_t */
 899:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 6;
 900:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect_channel : 2;  /**< Source to be used to charge the capacitor for 
 901:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BWDCH_t. */
 902:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect         : 1;  /**< Configures extra phase before the capacitor is
 903:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 904:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t chctr;
 905:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 906:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 907:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 908:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 909:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 910:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 8;
 911:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 912:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch0 : 1; /**< Condition for which the boundary flag should cha
 913:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITIO
 914:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch1 : 1; /**< Condition for which the boundary flag should cha
 915:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 916:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch2 : 1; /**< Condition for which the boundary flag should cha
 917:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 918:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch3 : 1; /**< Condition for which the boundary flag should cha
 919:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 920:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 921:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 922:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 923:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 924:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 925:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch0  : 1; /**< Inverts boundary flag output.*/
 926:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch1  : 1; /**< Inverts boundary flag output.*/
 927:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch2  : 1; /**< Inverts boundary flag output.*/
 928:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch3  : 1; /**< Inverts boundary flag output.*/
 929:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 930:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 931:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch0  : 1; /**< Enable the boundary flag output on the specific 
 932:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch1  : 1; /**< Enable the boundary flag output on the specific 
 933:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch2  : 1; /**< Enable the boundary flag output on the specific 
 934:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch3  : 1; /**< Enable the boundary flag output on the specific 
 935:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 936:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 12;
 937:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 938:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bfl;
 939:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 940:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 941:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 942:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 943:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 944:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 945:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch0    : 4; /**< Specify the basic operation of boundary flag 0
 946:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 947:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch1    : 4; /**< Specify the basic operation of boundary flag 1
 948:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 949:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch2    : 4; /**< Specify the basic operation of boundary flag 2
 950:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 951:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch3    : 4; /**< Specify the basic operation of boundary flag 3
 952:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 953:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 16;
 954:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 955:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bflc;
 956:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 957:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 958:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   bool    channel_priority;  /**< Only non priority channels can be converted by Background Request
 959:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   int8_t  alias_channel;     /**< Specifies the channel which has to be aliased with CH0/CH1 (which
 960:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Force the value to \b(int8_t)-1 to bypass alias feature.
 961:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Uses @ref XMC_VADC_CHANNEL_ALIAS_t  for configuration.*/
 962:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONFIG_t;
 963:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 964:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 965:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize a queue entry. Use type @ref XMC_VADC_QUEUE_ENTRY_t.
 966:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 967:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_ENTRY
 968:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 969:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 970:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 971:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 972:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 973:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_num        : 5;  /**< Channel number associated with this queue entry.<BR>Ra
 974:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t refill_needed      : 1;  /**< Conversion completed channel gets inserted back into t
 975:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t generate_interrupt : 1;  /**< Generates a queue request source event */
 976:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversion requests are raised on an external trigger.
 977:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 24;
 978:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 979:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 980:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qinr0;
 981:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 982:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_ENTRY_t;
 983:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 984:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 985:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing a VADC queue request source. Use type @ref XMC_VADC_QUEUE_CONFIG_t.
 986:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 987:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_CONFIG
 988:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 989:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 990:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how queue request source woul
 991:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 992:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter.Uses @ref XMC_VADC_G
 993:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 994:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 995:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 996:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 997:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 998:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Uses any one Group related result register as the
 999:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
1000:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
1001:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1002:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1003:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1004:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1005:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger.
1006:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_INPUT_SELECT_t */
1007:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1008:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal.
1009:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_EDGE_t */
1010:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1011:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating.
1012:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GATE_INPUT_SELECT_t */
1013:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
1014:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Timer mode for equi-distant sampling shall be act
1015:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
1016:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1017:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qctrl0;
1018:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1019:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1020:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1021:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1022:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1023:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 2;
1024:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger  : 1;  /**< Are external triggers supported? */
1025:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 29;
1026:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1027:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qmr0;
1028:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1029:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_CONFIG_t;
1030:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1031:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1032:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1033:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the global input class configuration. Configured parameters are sample 
1034:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1035:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1036:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLASS
1037:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1038:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1039:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1040:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1041:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1042:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1043:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1044:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1045:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1046:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1047:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1048:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
1049:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1050:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1051:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1052:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1053:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1054:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1055:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1056:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 16;
1057:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1058:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1059:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globiclass;
1060:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1061:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLASS_t;
1062:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1063:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1064:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1065:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize converter and arbiter clock configuration
1066:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1067:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLOCK
1068:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1069:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1070:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1071:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1072:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1073:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1074:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_clock_divider     : 5;  /**< Clock for the converter. <BR>Range: [0x0 to 0x1F
1075:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 2;
1076:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t msb_conversion_clock     : 1;  /**< Additional clock cycle for analog converter */
1077:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_clock_divider    : 2;  /**< Request source arbiter clock divider. <BR>Range:
1078:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 5;
1079:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 17;
1080:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1081:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globcfg;
1082:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1083:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLOCK_t;
1084:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1085:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1086:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1087:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1088:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize the VADC Global functions
1089:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1090:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CONFIG
1091:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1092:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1093:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1094:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1095:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1096:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1097:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1098:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1099:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globbound;
1102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLOCK_t clock_config; /**< ADC clock configurations*/
1105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class0;      /**< ADC input conversion configurations for GLOBICLASS[0]*
1107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class1;      /**< ADC input conversion configurations for GLOBICLASS[1]*
1108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Data reduction stages */
1114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Results of the next conversion will not be overwr
1116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       result register until the previous value is r
1117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 6;
1118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globrcr;
1121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t module_disable              : 1;  /**< Disables the module clock.*/
1127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 2;
1128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t disable_sleep_mode_control  : 1;  /**< Set it to true in order to disable the Sleep 
1129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 28;
1130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t clc;
1132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CONFIG_t;
1134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the group input class configuration. Configured parameters are sample t
1138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CLASS
1141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_iclass0;
1160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CLASS_t;
1162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  EMUX related configuration structure.
1166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_EMUXCFG
1168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t starting_external_channel : 3;  /**< External channel number to which the VADC will
1174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         generate a control signal (needed to select
1175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         the analog multiplexer)*/
1176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 13;
1177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 10; /**< The Channel to which the EMUX is connected. */
1179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 5;  /**< The Channel to which the EMUX is connected. */
1181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 5;
1182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_mode                 : 2;  /**< Selects the external multiplexer modes: Steady,
1184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         Uses @ref XMC_VADC_GROUP_EMUXMODE_t*/
1185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_coding               : 1;  /**< Select Binary or Gray coding. Uses @ref XMC_VAD
1186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t stce_usage                : 1;  /**< Use STCE for each conversion of an external cha
1187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_select_style : 1;  /**< Selects the style of configuring the \b connect
1189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         (Each bit represents the channel or entire 
1190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 1;
1191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 2;
1193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_emuxctr;
1196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCFG_t;
1198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Group Configuration Data Structures
1202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CONFIG
1205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCFG_t emux_config;    /**< External multiplexer related configurations */
1207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class0;           /**< ADC input conversion configurations for GxICLASS[0]
1208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class1;           /**< ADC input conversion configurations for GxICLASS[1]
1209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_bound;
1219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 4;
1225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbitration_round_length : 2;  /**< Number of arbiter slots to be considered */
1226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 1;
1227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_mode             : 1;  /**< Arbiter mode - Select either Continuous mode or 
1228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_ARBMODE_t */
1229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 24;
1230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_arbcfg;
1232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONFIG_t;
1234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize VADC Group result register.
1237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_RESULT_CONFIG
1240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Configures the data reduction stages */
1247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t post_processing_mode    : 2;  /**< Result data processing mode. Uses @ref  XMC_VADC_
1248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       For normal operation select
1249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_DMM_t::XMC_VADC_DMM_REDUCTION_MODE
1250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       and data_reduction_control as 0*/
1251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 2;
1252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Allow the conversion only after previous results 
1253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t part_of_fifo            : 2;  /**< Make the result register a part of Result FIFO? *
1254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_rcr;
1258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_CONFIG_t;
1260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
1262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Structure to initialize the Stepper configurations
1265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_STEP_CONFIG
1267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step0            : 3;  /**< Select a Sample and hold unit for the stepper's 
1273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step0             : 1; /**< Should the step be added to the sequence */
1275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step1            : 3;  /**< Select a Sample and hold unit for the stepper's 
1276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step1             : 1; /**< Should the step be added to the sequence */
1278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step2            : 3;  /**< Select a Sample and hold unit for the stepper's 
1279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step2             : 1; /**< Should the step be added to the sequence */
1281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step3            : 3;  /**< Select a Sample and hold unit for the stepper's 
1282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step3             : 1; /**< Should the step be added to the sequence */
1284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step4            : 3;  /**< Select a Sample and hold unit for the stepper's 
1285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step4             : 1; /**< Should the step be added to the sequence */
1287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step5            : 3;  /**< Select a Sample and hold unit for the stepper's 
1288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step5             : 1; /**< Should the step be added to the sequence */
1290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step6            : 3;  /**< Select a Sample and hold unit for the stepper's 
1291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step6             : 1; /**< Should the step be added to the sequence */
1293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step7            : 3;  /**< Select a Sample and hold unit for the stepper's 
1294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step7             : 1; /**< Should the step be added to the sequence */
1296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t stepcfg;
1299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_STEP_CONFIG_t;
1301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sample and hold Initialization structure
1304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_CONFIG
1306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t shs_clock_divider        : 4; /**< The divider value for the SHS clock. Range: [0x0 
1313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 6;
1314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 10;
1316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_reference_select  : 2; /**< It is possible to different reference voltage for
1318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 20;
1319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t shscfg;
1321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t calibration_order; /**< order in which the calibration sh
1324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CONFIG_t;
1326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed global result structure
1331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_DETAILED_RESULT
1333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t group_number             : 4;  /**< Indicates the group to which the channel_number 
1340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_DETAILED_RESULT_t;
1350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed channel result structure
1353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_DETAILED_RESULT
1355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_counter   : 4;  /**< Results reduction counter value*/
1362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DETAILED_RESULT_t;
1372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard end*/
1375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
1376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma pop
1377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
1378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning restore
1379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * static inline functions
1382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_CHECK_GROUP_PTR(XMC_VADC_GROUP_t *const group_ptr)
1386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS == 4U)
1388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1) || (group_ptr == VADC_G2) || (group_ptr 
1389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1));
1391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * API Prototypes
1396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifdef __cplusplus
1399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** extern "C" {
1400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module.<BR>\n
1409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would ungate the clock to the VADC module (if applicable). Also this API would bring
1410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module out of reset state(if applicable), by asserting the appropriate registers.
1411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_UngatePeripheralClock() and XMC_SCU_RESET_DeassertPeripheral
1412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * if needed. Directly accessed register is  COMPARATOR.ORCCTRL (Refer to the errata for XMC1100).
1413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableModule().
1416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_EnableModule(void);
1418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module.<BR>\n
1426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would gate the clock to the VADC module (if applicable). Also this API would put
1427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module into the reset state(if applicable) by asserting the appropriate registers.
1428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_GatePeripheralClock() and XMC_SCU_RESET_AssertPeripheralRese
1429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModule().
1432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_DisableModule(void);
1434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module.
1438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config Pointer to initialization data structure
1439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC global module with the associated configuration structure pointed by \a con
1444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enables the global access to registers by configuring reset and clock un-gating for selected dev
1445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * initializes global class, boundary , result resources by setting GLOBICLASS,GLOBBOUND,GLOBRCR re
1446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * configures the global analog and digital clock dividers by setting GLOBCFG register. Refer relat
1447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the configurations later in the program.
1448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_ClockInit()<BR>
1451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *conf
1453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module clock.\n\n Call this API before any further configuration of VADC. It se
1462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * register to enable.
1463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Enable:Wrong Module Pointer", (global_ptr == VADC))
1471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_DISR_Msk);
1472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module clock.\n\n After this API call, no conversion will occur. Call
1482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModuleClock() to enable the VADC module later in the program.
1483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Disable:Wrong Module Pointer", (global_ptr == VADC))
1491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_DISR_Pos);
1492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables VADC module to sleep if a sleep request comes.\n\n
1502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * It resets the EDIS bit of CLC register for enabling the sleep mode.
1503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableSleepMode().
1506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_EDIS_Msk);
1511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Ignores the sleep mode request for the VADC.\n\n
1521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * With the sleep feature enabled, the module will respond to sleep
1522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * requests by going into a low power mode. It resets the EDIS bit of CLC register for enabling the
1523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableSleepMode().
1526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_EDIS_Pos);
1531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to the data structure containing clock configuration data
1538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the VADC clock.<BR>\n
1543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the clock configuration of the VADC module using the config structure pointed by \a conf
1544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The clock to the analog converter and to the request source arbiter is configured by setting the
1545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ClockInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_
1551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClockInit:Wrong Module Pointer", (global_ptr == VADC))
1553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Write the Clock configuration into the GLOBCFG register */
1555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG = (uint32_t)(config->globcfg | (VADC_GLOBCFG_DIVWC_Msk));
1556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Conversion class parameter structure
1563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_type configure the input call for either standard conversion or EMUX related convers
1564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param set_num Conversion class set<BR>
1565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                Range: [0x0, 0x1]
1566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the ADC conversion settings like sample time and resolution.<BR>\n
1569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the conversion settings for vadc global resource associated with \a config structure. It
1570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * conversion class properties like sampling time and resolution for selected \a conv_type channels
1571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the GLOBALICLASS register specified by \a set_num with the required settings.
1572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLAS
1580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num);
1581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC global module
1585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to result configuration data structure
1586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes global result register.<BR>\n
1591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes Global Result Register with specified settings configured in the \a config structure
1592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * results in configuration of GLOBRCR register. This helps in configuring the Data reduction mode,
1593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * , wait for read mode on the GLOBRES register.
1594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ResultInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC
1602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ResultInit:Wrong Module Pointer", (global_ptr == VADC))
1604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Configure GLOBRCR*/
1606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBRCR = config->g_rcr;
1607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of G
1617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enable the startup calibration feature. After turning it on, it loops until all active groups fi
1618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call XMC_VADC_GLOBAL_Enable() and XMC_VADC_GLOBAL_ClockInit() before calling this API in sequenc
1619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableStartupCalibration() can disable the calibration feature at runtime.
1620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr);
1627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr  Constant pointer to the VADC module.
1632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of 
1637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * disable the startup calibration feature. Calling the API XMC_VADC_GLOBAL_EnsableStartupCalibrati
1638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * calibration feature at runtime.
1639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableStartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
1645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableStartupCalibration:Wrong Module Pointer", (global_ptr == VADC)
1647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= ~((uint32_t)VADC_GLOBCFG_SUCAL_Msk);
1648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be disabled. <BR>
1655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the post calibration for a particular group specified as \a group_number.\n\n It config
1661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to disable the post calibration feature. Call XMC_VADC_GLOBAL_Enable() and
1662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit() before calling this API in sequence. Calling the API
1663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnablePostCalibration() can enable back the calibration feature at runtime.
1664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, ui
1673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_numbe
1677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be enabled. <BR>
1683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the post calibration for a particular group specified as \a group_number.\n\n It configu
1689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to enable the post calibration feature. Calling the API XMC_VADC_GLOBAL_Disa
1690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can disable the calibration feature at runtime.
1691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uin
1697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= (~ (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_nu
1701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
1705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary0  Boundary-0 Value<BR>Range[0 - 4095]
1709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary1  Boundary-1 Value<BR>Range[0 - 4095]
1710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundaries with \a boundary0 and boundary1 for result comparison.\n\n These two bou
1715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * absolute boundaries. They define a range against which the result of a conversion can be compare
1716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any c
1717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * values entered here form a boundary pallete. There are dedicated upper and lower boundary regist
1718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * GLOBBOUND1 who will derive their values from this palette.
1719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetBoundaries(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t boundary0, c
1725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_value.
1730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_value  Boundary Value<BR>Range[0 - 4095]
1731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs either the boundary 0 or boundary 1 for result comparison.\n\n This defines a range aga
1736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result of a conversion can be compared. In the fast compare mode, the two boundaries provide
1737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * capability to a compare value.
1738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetIndividualBoundary(XMC_VADC_GLOBAL_t *const global_ptr,
1744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const XMC_VADC_CHANNEL_BOUNDARY_t selection,
1745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const uint16_t boundary_value);
1746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_AVAILABLE== 1U)
1749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module
1752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param emuxif       The EMUX interface<BR>Range[0x0 - 0x1]
1753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group        The VADC group which must be bound to the desired emux
1754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds a VADC \a group to an EMUX interface specified in \a emuxif.<BR>\n
1759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects which group's scan request source will control the EMUX interface (set of control select
1760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * By passing \b group it would configure that group's scan request source to control the EMUX sele
1761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \b emuxif.
1762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BindGroupToEMux(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t emuxif, co
1767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return uint32_t Complete global result register value GLOBRES
1774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Retrieves the complete result from the global result register associated with the \a global_ptr.
1777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result register GLOBRES for the validity of the data. If the validity is assured, data is fi
1778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the global result register, cached locally next and subsequently returned to the caller.
1779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @note You can cast the return to a varible of type XMC_VADC_GLOBAL_DETAILED_RESULT_t to easily a
1781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_GetResult()
1784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GLOBAL_GetDetailedResult(XMC_VADC_GLOBAL_t *const global_ptr)
1786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
  25              	 .loc 1 1786 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 7860     	 str r0,[r7,#4]
1787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetDetailedResult:Wrong Module Pointer", (global_ptr == VADC))
1788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return (global_ptr->GLOBRES);
  39              	 .loc 1 1789 0
  40 0008 7A68     	 ldr r2,[r7,#4]
  41 000a C023     	 mov r3,#192
  42 000c 9B00     	 lsl r3,r3,#2
  43 000e D358     	 ldr r3,[r2,r3]
1790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
  44              	 .loc 1 1790 0
  45 0010 181C     	 mov r0,r3
  46 0012 BD46     	 mov sp,r7
  47 0014 02B0     	 add sp,sp,#8
  48              	 
  49 0016 80BD     	 pop {r7,pc}
  50              	 .cfi_endproc
  51              	.LFE66:
  53              	 .section .text.ADC_MEASUREMENT_GetGlobalDetailedResult,"ax",%progbits
  54              	 .align 2
  55              	 .code 16
  56              	 .thumb_func
  58              	ADC_MEASUREMENT_GetGlobalDetailedResult:
  59              	.LFB92:
  60              	 .file 2 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @file adc_measurement.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @date 2021-01-08
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * NOTE:
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @cond
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT v4.1.24 - Incorporates analog to digital conversion for the required measurement
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * All rights reserved.
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * following conditions are met:
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   disclaimer.
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   products derived from this software without specific prior written permission.
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Change History
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * --------------
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-16:
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Initial version for DAVEv4.<BR>
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-19:
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added GetResult APIs for XMC1100 devices.
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-05-14:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Optimized the Manifest.<BR>
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified the structure ADC_MEASUREMENT_channel_t to ADC_MEASUREMENT_CHANNEL_t.<BR>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-06-26:
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added input class resource consumption.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   * 2015-07-09:
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-07-31:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support new devices.<BR>
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-01:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support the interrupt control in XMC14.<BR>
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-08:
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4700/XMC4800 devices.<BR>
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-20:
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-12-03:
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4300 device.<BR>
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-02-09:
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP for the minimum required ANALOG_IO APP version.<BR>
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-03-18:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Maximum number of channels for XMC41/42 increased to 9.<BR>
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added Post calibration time for XMC1x series in Total conversion Time.<BR>
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Fixed the ADC_MEASUREMENT_Init() for ANALOG_IO initialization.<BR>
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Deprecated the API ADC_MEASUREMENT_GetResult() and
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetDetailedResult().<BR>
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Added new API ADC_MEASUREMENT_GetGlobalResult() and
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetGlobalDetailedResult().<BR>
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-08-18:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_A
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2021-01-08:
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified check for minimum XMCLib version
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcond
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /*CODE_BLOCK_BEGIN*/
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifndef ADC_MEASUREMENT_H
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_H
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * HEADER FILES
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "GLOBAL_ADC/global_adc.h"
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "adc_measurement_conf.h"
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * MACROS
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION 2
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MINOR_VERSION 0
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_PATCH_VERSION 0
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if !((XMC_LIB_MAJOR_VERSION > ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) ||\
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION >
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION =
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #error "ADC_MEASUREMENT requires XMC Peripheral Library v2.0.0 or higher"
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if defined (__GNUC__) || defined (__CC_ARM)
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED   __attribute__((deprecated))
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_MODULE_PTR ((XMC_VADC_GLOBAL_t *) (void *) VADC)
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ENUMS
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_enumerations
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**@brief Return value of an API  */
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef enum ADC_MEASUREMENT_STATUS
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_SUCCESS = 0, /**< APP is Initialized */
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_FAILURE, /**< APP Initialization failed*/
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_UNINITIALIZED /**<  APP has not been Initialized */
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_STATUS_t;
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** * DATA STRUCTURES
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ***************************************************************************************************
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_datastructures
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef void (*ADC_MEASUREMENT_MUX_CONFIG_t)(void); /**< Function pointer to the mux configuration*
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  Structure to initialize  Request Source Interrupt's NVIC Node
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_ISR
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t node_id; 		/**< This holds the Node ID of the NVIC.*/
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t priority; 		/**< This holds the NVIC priority.*/
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(UC_FAMILY == XMC4)
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t sub_priority; 	/**< This holds the SubPriority of the NVIC. for Only XMC4x Devices*/
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_NON_DEFAULT_IRQ_SOURCE_SELECTED
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t irqctrl; 	     /**< This indicates the service request source selected for the consumed N
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_ISR_t;
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to initialize ADC channels.
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_CHANNEL_CONFIG_t *ch_handle; /**< This holds the VADC Channel LLD struct*/
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_GROUP_t *group_handle; 		/**< This holds the group to which the channel belongs*/
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_ANALOG_IO_USED
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ANALOG_IO_t   *analog_io_config;    /**< This hold the address of the ANALOG_IO configuration str
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t group_index; 					/**< This holds the group index*/
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t ch_num; 						/**< This Holds the Channel Number*/
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_t;
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to hold channels handles that are configured
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL_ARRAY
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_t *const channel_array[ADC_MEASUREMENT_MAXCHANNELS]; /**< Array whi
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                                         of APPs Cha
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 0U)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_ARRAY_t;
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to configure ADC_MEASUREMENT APP.
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_ARRAY_t *const array; 		 /**< This holds ADC_MEASUREMENT_Channel_Ha
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_BACKGROUND_CONFIG_t *const backgnd_config_handle; /**< This holds the LLD Backgrou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                         Structure*/
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_GLOBAL_CLASS_t *const iclass_config_handle;  /**< This holds the adc global ICLASS
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   GLOBAL_ADC_t *const global_handle; 						 /**< This hold the ADC Global APP handle*/
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if (UC_SERIES != XMC11)
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const req_src_intr_handle; 	 /**< This has the NVIC configuration st
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const result_intr_handle; 	 /**< This has the NVIC configuration str
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_MUX_CONFIG_t mux_config; /**< This hold the pointer to the function that does mux
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_t init_state; 	  /**< Holds information regarding the APP initialization *
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_SR_t srv_req_node; 	  /**< Service Request Line selected*/
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const bool start_conversion; 			  /**< This indicates whether to start at initialization of the A
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_t;
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef __cplusplus
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** extern "C" {
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * API Prototypes
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_apidoc
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Get ADC_MEASUREMENT APP version
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * The function can be used to check application software compatibility with a
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specific version of the APP.
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Example Usage:
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void) 
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_STATUS_t init_status;
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_APP_VERSION_t version;
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // Initialize ADC_MEASUREMENT APP:
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // ADC_MEASUREMENT_Init() is called from within DAVE_Init().
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   init_status = DAVE_Init();
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   version = ADC_MEASUREMENT_GetAppVersion();
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   if (version.major != 1U) {
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     // Probably, not the right version.
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // More code here
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   while(1) {
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   return (0);
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcode
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** DAVE_APP_VERSION_t ADC_MEASUREMENT_GetAppVersion(void);
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Initializes the APP to measure a set of analog inputs. <BR>
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return ADC_MEASUREMENT_STATUS_SUCCESS when initialization succeeds else, return ADC_MEASUREMENT
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Initializes the VADC background scan request source, group channels and result registers with th
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specified in the handle structure. The API configures the conversion timing parameters of VADC, 
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GLOBICLASS] register. The API initializes the channel and result configurations by setting the 
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GxRCRy] registers respectively. It adds all channels into the background request source channel
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [BRSSEL]. For microcontrollers apart from XMC1100, the APP uses background request source event 
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * the interrupt. For XMC1100 devices, global result event is used to generate the interrupt. If "S
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * initialization" has been selected in the GUI, the ADC conversions starts immediately at the end 
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    DAVE_Init(); //ADC_MEASUREMENT_Init is called within DAVE_Init
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    return 0;
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */ 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr);
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Starts the conversion of the required measurements. <BR>
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the APP handle structure<BR>
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return None <BR>
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  If "Start conversion after initialization" option is not selected in the GUI, the conversions c
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  calling this API. A call to this API sets the register bit field BRSMR.LDEV to generate a load 
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  load event triggers the conversion of selected channels in a fixed sequence. A conversion reque
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  upon detection of a hardware trigger. Hence, if "Start conversion after initialization" option 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  "Trigger edge Selection" is configured to any edge, this API call is not mandatory to start the
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #else
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr);
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value for a specific channel. Not Applicable for XMC1100.<BR>
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the channel handle structure of type @ref ADC_MEASUREMENT_
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the result register [GxRESy.RESULT], assigned to the specif
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where separate result registers are available for storing ea
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * For these microcontrollers, each channel is configured to a particular group result register. Th
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is defined in the channel handle structure @ref ADC_MEASUREMENT_CHANNEL_t. Hence this API shall 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * pointer to the channel handle of type  @ref ADC_MEASUREMENT_CHANNEL_t (Directly use the channel 
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * macros which are defined in adc_measurement_conf.h).
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) for XMC1
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Not Applicable for XMC1100. <BR>
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the channel handle structure.
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete result register.<BR>
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GxRES[y]) completely. The result of conversion as well as ot
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) 
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result;
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_Channel_A);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_G_RES_VF_Pos))
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 437:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 438:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.channel_num = (result & VADC_G_RES_CHNR_Msk) >> VADC_G_RES_CHNR_Pos;
 439:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.group_num = ADC_MEASUREMENT_Channel_A.group_index;
 440:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.conversion_result = result & VADC_G_RES_RESULT_Msk;
 441:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 442:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 443:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 444:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 445:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 446:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 447:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 448:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 449:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 450:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 451:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 452:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 453:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 454:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 455:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 456:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else /* Applicable for XMC1100 devices*/
 457:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 459:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 460:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 461:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 462:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 463:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 464:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 465:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 466:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 467:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 469:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetDetailedResult API.
 470:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 471:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 472:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 473:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 474:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 475:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 476:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 477:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 478:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 479:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 480:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 481:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 482:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 483:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 484:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 485:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 486:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 487:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 488:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 489:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_0);
 490:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 491:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 492:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 493:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 494:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 495:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 496:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 497:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 498:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 499:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 500:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 501:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 502:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 503:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREME
 504:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 505:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 506:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 507:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 508:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 509:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 510:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 511:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 512:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 513:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 514:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 515:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 516:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 517:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 518:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 519:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 520:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 521:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 522:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 523:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 524:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 525:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 526:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 527:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 528:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 529:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 530:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 531:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 532:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 533:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 534:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 535:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 536:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 538:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 539:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 540:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 541:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 542:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 543:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 545:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 546:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 547:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 548:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 549:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 550:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 551:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 552:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 553:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 554:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_0);
 555:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 556:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 557:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 558:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 559:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 560:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 561:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 562:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 563:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 564:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 565:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 566:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 567:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 568:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 569:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 570:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 571:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 572:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 573:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 574:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 575:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 576:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREMENT_DEP
 578:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 581:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 582:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 583:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 584:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 585:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 586:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 587:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 588:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 589:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 591:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetGlobalDetailedResult API.
 592:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 593:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 594:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 595:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 596:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 597:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 598:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 599:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 600:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 601:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 602:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 603:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 604:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 605:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 606:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 607:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 609:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 610:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 611:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 612:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 613:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 614:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 615:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 617:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 618:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 619:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 620:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 621:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 622:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 623:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 624:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 625:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE XMC_VADC_RESULT_SIZE_t  ADC_MEASUREMENT_GetGlobalResult(void)
 626:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 627:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 628:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 629:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
 630:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 631:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
 632:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
 633:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 634:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 635:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 636:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 637:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 638:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 639:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 640:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 641:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 642:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 643:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 644:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 645:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 646:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 647:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 648:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 649:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 650:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 651:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 652:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 653:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 654:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 655:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 656:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 657:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 658:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 659:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 660:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 661:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 662:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 663:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 664:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 665:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 666:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 667:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 668:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 669:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 670:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 671:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 672:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 673:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 674:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 675:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 676:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 677:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 678:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 679:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 680:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 681:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 682:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 683:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalDetailedResult();
 684:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 685:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 686:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 687:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 688:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 689:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 690:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 691:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 692:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 693:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 694:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 695:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 696:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 697:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 698:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 699:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 700:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 701:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 702:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 703:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 704:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 705:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 706:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE uint32_t ADC_MEASUREMENT_GetGlobalDetailedResult(void)
 707:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
  61              	 .loc 2 707 0
  62              	 .cfi_startproc
  63 0000 80B5     	 push {r7,lr}
  64              	.LCFI3:
  65              	 .cfi_def_cfa_offset 8
  66              	 .cfi_offset 7,-8
  67              	 .cfi_offset 14,-4
  68 0002 82B0     	 sub sp,sp,#8
  69              	.LCFI4:
  70              	 .cfi_def_cfa_offset 16
  71 0004 00AF     	 add r7,sp,#0
  72              	.LCFI5:
  73              	 .cfi_def_cfa_register 7
 708:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 709:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
  74              	 .loc 2 709 0
  75 0006 054B     	 ldr r3,.L5
  76 0008 181C     	 mov r0,r3
  77 000a FFF7FEFF 	 bl XMC_VADC_GLOBAL_GetDetailedResult
  78 000e 031C     	 mov r3,r0
  79 0010 7B60     	 str r3,[r7,#4]
 710:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 711:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
  80              	 .loc 2 711 0
  81 0012 7B68     	 ldr r3,[r7,#4]
 712:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
  82              	 .loc 2 712 0
  83 0014 181C     	 mov r0,r3
  84 0016 BD46     	 mov sp,r7
  85 0018 02B0     	 add sp,sp,#8
  86              	 
  87 001a 80BD     	 pop {r7,pc}
  88              	.L6:
  89              	 .align 2
  90              	.L5:
  91 001c 00000348 	 .word 1208156160
  92              	 .cfi_endproc
  93              	.LFE92:
  95              	 .section .text.XMC_GPIO_SetOutputHigh,"ax",%progbits
  96              	 .align 2
  97              	 .code 16
  98              	 .thumb_func
 100              	XMC_GPIO_SetOutputHigh:
 101              	.LFB95:
 102              	 .file 3 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics.
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #if UC_FAMILY == XMC1
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 103              	 .loc 3 262 0
 104              	 .cfi_startproc
 105 0000 80B5     	 push {r7,lr}
 106              	.LCFI6:
 107              	 .cfi_def_cfa_offset 8
 108              	 .cfi_offset 7,-8
 109              	 .cfi_offset 14,-4
 110 0002 82B0     	 sub sp,sp,#8
 111              	.LCFI7:
 112              	 .cfi_def_cfa_offset 16
 113 0004 00AF     	 add r7,sp,#0
 114              	.LCFI8:
 115              	 .cfi_def_cfa_register 7
 116 0006 7860     	 str r0,[r7,#4]
 117 0008 0A1C     	 mov r2,r1
 118 000a FB1C     	 add r3,r7,#3
 119 000c 1A70     	 strb r2,[r3]
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
 120              	 .loc 3 265 0
 121 000e FB1C     	 add r3,r7,#3
 122 0010 1B78     	 ldrb r3,[r3]
 123 0012 0122     	 mov r2,#1
 124 0014 9A40     	 lsl r2,r2,r3
 125 0016 7B68     	 ldr r3,[r7,#4]
 126 0018 5A60     	 str r2,[r3,#4]
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 127              	 .loc 3 266 0
 128 001a BD46     	 mov sp,r7
 129 001c 02B0     	 add sp,sp,#8
 130              	 
 131 001e 80BD     	 pop {r7,pc}
 132              	 .cfi_endproc
 133              	.LFE95:
 135              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
 136              	 .align 2
 137              	 .code 16
 138              	 .thumb_func
 140              	XMC_GPIO_SetOutputLow:
 141              	.LFB96:
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 142              	 .loc 3 288 0
 143              	 .cfi_startproc
 144 0000 80B5     	 push {r7,lr}
 145              	.LCFI9:
 146              	 .cfi_def_cfa_offset 8
 147              	 .cfi_offset 7,-8
 148              	 .cfi_offset 14,-4
 149 0002 82B0     	 sub sp,sp,#8
 150              	.LCFI10:
 151              	 .cfi_def_cfa_offset 16
 152 0004 00AF     	 add r7,sp,#0
 153              	.LCFI11:
 154              	 .cfi_def_cfa_register 7
 155 0006 7860     	 str r0,[r7,#4]
 156 0008 0A1C     	 mov r2,r1
 157 000a FB1C     	 add r3,r7,#3
 158 000c 1A70     	 strb r2,[r3]
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
 159              	 .loc 3 291 0
 160 000e FB1C     	 add r3,r7,#3
 161 0010 1B78     	 ldrb r3,[r3]
 162 0012 8022     	 mov r2,#128
 163 0014 5202     	 lsl r2,r2,#9
 164 0016 9A40     	 lsl r2,r2,r3
 165 0018 7B68     	 ldr r3,[r7,#4]
 166 001a 5A60     	 str r2,[r3,#4]
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 167              	 .loc 3 292 0
 168 001c BD46     	 mov sp,r7
 169 001e 02B0     	 add sp,sp,#8
 170              	 
 171 0020 80BD     	 pop {r7,pc}
 172              	 .cfi_endproc
 173              	.LFE96:
 175 0022 C046     	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
 176              	 .align 2
 177              	 .code 16
 178              	 .thumb_func
 180              	XMC_GPIO_GetInput:
 181              	.LFB98:
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  port pin number.
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  Port pin number.
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * None
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 182              	 .loc 3 339 0
 183              	 .cfi_startproc
 184 0000 80B5     	 push {r7,lr}
 185              	.LCFI12:
 186              	 .cfi_def_cfa_offset 8
 187              	 .cfi_offset 7,-8
 188              	 .cfi_offset 14,-4
 189 0002 82B0     	 sub sp,sp,#8
 190              	.LCFI13:
 191              	 .cfi_def_cfa_offset 16
 192 0004 00AF     	 add r7,sp,#0
 193              	.LCFI14:
 194              	 .cfi_def_cfa_register 7
 195 0006 7860     	 str r0,[r7,#4]
 196 0008 0A1C     	 mov r2,r1
 197 000a FB1C     	 add r3,r7,#3
 198 000c 1A70     	 strb r2,[r3]
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
 199              	 .loc 3 342 0
 200 000e 7B68     	 ldr r3,[r7,#4]
 201 0010 5A6A     	 ldr r2,[r3,#36]
 202 0012 FB1C     	 add r3,r7,#3
 203 0014 1B78     	 ldrb r3,[r3]
 204 0016 DA40     	 lsr r2,r2,r3
 205 0018 131C     	 mov r3,r2
 206 001a 0122     	 mov r2,#1
 207 001c 1340     	 and r3,r2
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 208              	 .loc 3 343 0
 209 001e 181C     	 mov r0,r3
 210 0020 BD46     	 mov sp,r7
 211 0022 02B0     	 add sp,sp,#8
 212              	 
 213 0024 80BD     	 pop {r7,pc}
 214              	 .cfi_endproc
 215              	.LFE98:
 217 0026 C046     	 .section .text.DIGITAL_IO_SetOutputHigh,"ax",%progbits
 218              	 .align 2
 219              	 .code 16
 220              	 .thumb_func
 222              	DIGITAL_IO_SetOutputHigh:
 223              	.LFB103:
 224              	 .file 4 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /*
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @file digital_io.h
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @date 2021-01-08
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * NOTE:
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @cond
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DIGITAL_IO v4.0.18 - The DIGITAL_IO APP is used to configure a port pin as digital Input/Output.
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * All rights reserved.
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * following conditions are met:
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   disclaimer.
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   products derived from this software without specific prior written permission.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * with Infineon Technologies AG (dave@infineon.com).
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Change History
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * --------------
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-02-16
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Initial version
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-04-22
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - XMC_ASSERT is added in static inline functions.<br>
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-06-20
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Version check added for XMCLib dependency.<br>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-12-22
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Added hardware controlled IO feature.
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2016-07-08:
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Fixed incorrect case for an included header.<br>
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2021-01-08:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Modified check for minimum XMCLib version
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @endcond
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  */
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * HEADER FILES
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifndef DIGITAL_IO_H
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_H
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "xmc_gpio.h"
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "DAVE_Common.h"
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "digital_io_conf.h"
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * MACROS
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MAJOR_VERSION 2
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MINOR_VERSION 0
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_PATCH_VERSION 0
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #if !((XMC_LIB_MAJOR_VERSION > DIGITAL_IO_XMC_LIB_MAJOR_VERSION) ||\
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > DIGI
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == DIG
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #error "DIGITAL_IO requires XMC Peripheral Library v2.0.0 or higher"
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  /*************************************************************************************************
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * ENUMS
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_enumerations
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization status of DIGITAL_IO APP.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef enum DIGITAL_IO_STATUS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_OK = 0U,/**< 0=Status OK */
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_FAILURE = 1U/**< 1=Status Failed */
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_STATUS_t;
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DATA STRUCTURES
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_datastructures
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization data structure of DIGITAL_IO APP
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef struct DIGITAL_IO
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_PORT_t *const gpio_port;             /**< port number */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_CONFIG_t gpio_config;          /**< mode, initial output level and pad driver stre
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const uint8_t gpio_pin;                       /**< pin number */
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_HWCTRL_t hwctrl;               /**< Hardware port control */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_t;
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * API Prototypes
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifdef __cplusplus
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** extern "C" {
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_apidoc
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Get DIGITAL_IO APP version
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description: </b><br>
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * The function can be used to check application software compatibility with a
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * specific version of the APP.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h"
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t init_status;
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_APP_VERSION_t version;
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // Initialize DIGITAL_IO APP:
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // DIGITAL_IO_Init() is called from within DAVE_Init().
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   init_status = DAVE_Init();
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(init_status == DAVE_STATUS_SUCCESS)
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     version = DIGITAL_IO_GetAppVersion();
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if (version.major != 4U) {
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Probably, not the right version.
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // More code here
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1) {
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     return (1);
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @endcode<BR>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DAVE_APP_VERSION_t DIGITAL_IO_GetAppVersion(void);
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to initialize the port pin as per UI settings.
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status. Refer @ref DIGITAL_IO_STATUS_t structure for d
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function initializes GPIO port registers IOCR,PDISC,OMR,PDR/PHCR to configure pin direction,
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * and pad driver strength/hysteresis.
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * None
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return 1U;
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler);
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to set port pin high.
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to high level
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  DIGITAL_IO_SetOutputLow()
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_0);
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Add application code here
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 225              	 .loc 4 277 0
 226              	 .cfi_startproc
 227 0000 80B5     	 push {r7,lr}
 228              	.LCFI15:
 229              	 .cfi_def_cfa_offset 8
 230              	 .cfi_offset 7,-8
 231              	 .cfi_offset 14,-4
 232 0002 82B0     	 sub sp,sp,#8
 233              	.LCFI16:
 234              	 .cfi_def_cfa_offset 16
 235 0004 00AF     	 add r7,sp,#0
 236              	.LCFI17:
 237              	 .cfi_def_cfa_register 7
 238 0006 7860     	 str r0,[r7,#4]
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 239              	 .loc 4 279 0
 240 0008 7B68     	 ldr r3,[r7,#4]
 241 000a 1A68     	 ldr r2,[r3]
 242 000c 7B68     	 ldr r3,[r7,#4]
 243 000e 1B7B     	 ldrb r3,[r3,#12]
 244 0010 101C     	 mov r0,r2
 245 0012 191C     	 mov r1,r3
 246 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 247              	 .loc 4 280 0
 248 0018 BD46     	 mov sp,r7
 249 001a 02B0     	 add sp,sp,#8
 250              	 
 251 001c 80BD     	 pop {r7,pc}
 252              	 .cfi_endproc
 253              	.LFE103:
 255 001e C046     	 .section .text.DIGITAL_IO_SetOutputLow,"ax",%progbits
 256              	 .align 2
 257              	 .code 16
 258              	 .thumb_func
 260              	DIGITAL_IO_SetOutputLow:
 261              	.LFB104:
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to reset port pin.
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to low level.
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputHigh()
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  int main(void)
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  {
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DAVE_STATUS_t status;
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_I
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    if(status == DAVE_STATUS_SUCCESS)
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG("DAVE Apps initialization success\n");
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    else
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    //Placeholder for user application code. The while loop below can be replaced with user applic
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DIGITAL_IO_SetOutputLow(&DIGITAL_IO_0);
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    while(1U)
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      // Add application code here
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 262              	 .loc 4 325 0
 263              	 .cfi_startproc
 264 0000 80B5     	 push {r7,lr}
 265              	.LCFI18:
 266              	 .cfi_def_cfa_offset 8
 267              	 .cfi_offset 7,-8
 268              	 .cfi_offset 14,-4
 269 0002 82B0     	 sub sp,sp,#8
 270              	.LCFI19:
 271              	 .cfi_def_cfa_offset 16
 272 0004 00AF     	 add r7,sp,#0
 273              	.LCFI20:
 274              	 .cfi_def_cfa_register 7
 275 0006 7860     	 str r0,[r7,#4]
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 276              	 .loc 4 327 0
 277 0008 7B68     	 ldr r3,[r7,#4]
 278 000a 1A68     	 ldr r2,[r3]
 279 000c 7B68     	 ldr r3,[r7,#4]
 280 000e 1B7B     	 ldrb r3,[r3,#12]
 281 0010 101C     	 mov r0,r2
 282 0012 191C     	 mov r1,r3
 283 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 284              	 .loc 4 328 0
 285 0018 BD46     	 mov sp,r7
 286 001a 02B0     	 add sp,sp,#8
 287              	 
 288 001c 80BD     	 pop {r7,pc}
 289              	 .cfi_endproc
 290              	.LFE104:
 292 001e C046     	 .section .text.DIGITAL_IO_GetInput,"ax",%progbits
 293              	 .align 2
 294              	 .code 16
 295              	 .thumb_func
 297              	DIGITAL_IO_GetInput:
 298              	.LFB106:
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to Toggle port pin.
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to toggle port pin.
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputLow(), DIGITAL_IO_SetOutputHigh()
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t delay_count;;
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 1 -> 0 (if initial output level is logic
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 0 -> 1
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to read input level of port pin.
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return uint32_t input logic level. Range:0-1
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function reads the Pn_IN register and returns the current logical value at the GPIO pin.
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  None
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t pin_status;
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();   // (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     pin_status = DIGITAL_IO_GetInput(&DIGITAL_IO_0);
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if(pin_status == 1)
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     else
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 299              	 .loc 4 433 0
 300              	 .cfi_startproc
 301 0000 80B5     	 push {r7,lr}
 302              	.LCFI21:
 303              	 .cfi_def_cfa_offset 8
 304              	 .cfi_offset 7,-8
 305              	 .cfi_offset 14,-4
 306 0002 82B0     	 sub sp,sp,#8
 307              	.LCFI22:
 308              	 .cfi_def_cfa_offset 16
 309 0004 00AF     	 add r7,sp,#0
 310              	.LCFI23:
 311              	 .cfi_def_cfa_register 7
 312 0006 7860     	 str r0,[r7,#4]
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
 313              	 .loc 4 435 0
 314 0008 7B68     	 ldr r3,[r7,#4]
 315 000a 1A68     	 ldr r2,[r3]
 316 000c 7B68     	 ldr r3,[r7,#4]
 317 000e 1B7B     	 ldrb r3,[r3,#12]
 318 0010 101C     	 mov r0,r2
 319 0012 191C     	 mov r1,r3
 320 0014 FFF7FEFF 	 bl XMC_GPIO_GetInput
 321 0018 031C     	 mov r3,r0
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 322              	 .loc 4 436 0
 323 001a 181C     	 mov r0,r3
 324 001c BD46     	 mov sp,r7
 325 001e 02B0     	 add sp,sp,#8
 326              	 
 327 0020 80BD     	 pop {r7,pc}
 328              	 .cfi_endproc
 329              	.LFE106:
 331              	 .global relay_threshold_latchtime
 332 0022 C046     	 .section .data.relay_threshold_latchtime,"aw",%progbits
 333              	 .align 1
 336              	relay_threshold_latchtime:
 337 0000 F401     	 .short 500
 338              	 .global ADC_upper_threshold
 339              	 .section .data.ADC_upper_threshold,"aw",%progbits
 340              	 .align 2
 343              	ADC_upper_threshold:
 344 0000 B80B0000 	 .word 3000
 345              	 .global ADC_lower_threshold
 346              	 .section .data.ADC_lower_threshold,"aw",%progbits
 347              	 .align 2
 350              	ADC_lower_threshold:
 351 0000 C4090000 	 .word 2500
 352              	 .comm USB_state,1,1
 353              	 .comm relay_state,1,1
 354              	 .comm setup_state,1,1
 355              	 .global led_status_pattern
 356              	 .section .bss.led_status_pattern,"aw",%nobits
 359              	led_status_pattern:
 360 0000 00       	 .space 1
 361              	 .global led_status_pattern_last
 362              	 .section .bss.led_status_pattern_last,"aw",%nobits
 365              	led_status_pattern_last:
 366 0000 00       	 .space 1
 367              	 .global led_pattern_mode
 368              	 .section .bss.led_pattern_mode,"aw",%nobits
 371              	led_pattern_mode:
 372 0000 00       	 .space 1
 373              	 .global led_status_pattern_after_single
 374              	 .section .bss.led_status_pattern_after_single,"aw",%nobits
 377              	led_status_pattern_after_single:
 378 0000 00       	 .space 1
 379              	 .global led_number
 380              	 .section .bss.led_number,"aw",%nobits
 381              	 .align 1
 384              	led_number:
 385 0000 0000     	 .space 2
 386              	 .global led_fadetime
 387              	 .section .data.led_fadetime,"aw",%progbits
 388              	 .align 1
 391              	led_fadetime:
 392 0000 DC05     	 .short 1500
 393              	 .global led_fadesteps
 394              	 .section .data.led_fadesteps,"aw",%progbits
 395              	 .align 1
 398              	led_fadesteps:
 399 0000 E803     	 .short 1000
 400              	 .global buttonpress_usb
 401              	 .section .bss.buttonpress_usb,"aw",%nobits
 404              	buttonpress_usb:
 405 0000 00       	 .space 1
 406              	 .global buttonpress_up
 407              	 .section .bss.buttonpress_up,"aw",%nobits
 410              	buttonpress_up:
 411 0000 00       	 .space 1
 412              	 .global buttonpress_down
 413              	 .section .bss.buttonpress_down,"aw",%nobits
 416              	buttonpress_down:
 417 0000 00       	 .space 1
 418              	 .global button_usb_pressed_timestamp
 419              	 .section .bss.button_usb_pressed_timestamp,"aw",%nobits
 420              	 .align 2
 423              	button_usb_pressed_timestamp:
 424 0000 00000000 	 .space 4
 425              	 .global button_up_pressed_timestamp
 426              	 .section .bss.button_up_pressed_timestamp,"aw",%nobits
 427              	 .align 2
 430              	button_up_pressed_timestamp:
 431 0000 00000000 	 .space 4
 432              	 .global button_down_pressed_timestamp
 433              	 .section .bss.button_down_pressed_timestamp,"aw",%nobits
 434              	 .align 2
 437              	button_down_pressed_timestamp:
 438 0000 00000000 	 .space 4
 439              	 .global button_usb_pressed_duration
 440              	 .section .bss.button_usb_pressed_duration,"aw",%nobits
 441              	 .align 1
 444              	button_usb_pressed_duration:
 445 0000 0000     	 .space 2
 446              	 .global button_up_pressed_duration
 447              	 .section .bss.button_up_pressed_duration,"aw",%nobits
 448              	 .align 1
 451              	button_up_pressed_duration:
 452 0000 0000     	 .space 2
 453              	 .global button_down_pressed_duration
 454              	 .section .bss.button_down_pressed_duration,"aw",%nobits
 455              	 .align 1
 458              	button_down_pressed_duration:
 459 0000 0000     	 .space 2
 460              	 .global ADC_val_current
 461              	 .section .bss.ADC_val_current,"aw",%nobits
 462              	 .align 2
 465              	ADC_val_current:
 466 0000 00000000 	 .space 4
 467              	 .global ADC_val_upper_thres_exceed_timestamp
 468              	 .section .bss.ADC_val_upper_thres_exceed_timestamp,"aw",%nobits
 469              	 .align 2
 472              	ADC_val_upper_thres_exceed_timestamp:
 473 0000 00000000 	 .space 4
 474              	 .global ADC_val_lower_thres_exceed_timestamp
 475              	 .section .bss.ADC_val_lower_thres_exceed_timestamp,"aw",%nobits
 476              	 .align 2
 479              	ADC_val_lower_thres_exceed_timestamp:
 480 0000 00000000 	 .space 4
 481              	 .global systime_debug
 482              	 .section .bss.systime_debug,"aw",%nobits
 483              	 .align 2
 486              	systime_debug:
 487 0000 00000000 	 .space 4
 488              	 .section .text.delay_ms,"ax",%progbits
 489              	 .align 2
 490              	 .global delay_ms
 491              	 .code 16
 492              	 .thumb_func
 494              	delay_ms:
 495              	.LFB153:
 496              	 .file 5 "../main.c"
   1:../main.c     **** /*
   2:../main.c     ****  * main.c
   3:../main.c     ****  *
   4:../main.c     ****  *  Created on: 2022 Mar 03 16:13:51
   5:../main.c     ****  *  Author: RNSANTELER
   6:../main.c     ****  */
   7:../main.c     **** 
   8:../main.c     **** #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
   9:../main.c     **** 
  10:../main.c     **** 
  11:../main.c     **** // Constant settings (must be set hard-coded)
  12:../main.c     **** #define BTN_STD_PRESS_DURATION		60							// The minimum duration of a button press that will be reg
  13:../main.c     **** #define BTN_LONG_PRESS_DURATION		1000						// The minimum duration of a long button press that will
  14:../main.c     **** #define BTN_LONGEST_PRESS_DURATION	4000						// The maximum duration of a button press
  15:../main.c     **** #define ADC_THRESHOLD_MAX			4095						// Maximum ADC value. Note: 1023 can be divided by 1, 3, 11, 
  16:../main.c     **** #define ADC_THRESHOLD_INCREMENT		(ADC_THRESHOLD_MAX / 33)	// Value added/subtracted when adjusting 
  17:../main.c     **** #define RELAY_LATCHTIME_MAX			60000						// Maximum configurable time that the threshold must be ex
  18:../main.c     **** #define RELAY_LATCHTIME_INCREMENT	500							// Value added/subtracted when adjusting time
  19:../main.c     **** #define LED_PULSE_SHORT				200							// In ms. Duration of a short led pulse used for led pattern "
  20:../main.c     **** #define LED_PULSE_LONG				1100						// In ms. Duration of a long led pulse used for led pattern "nu
  21:../main.c     **** #define PWM_FULL_ON					PWM_CCU4_SYM_DUTY_MIN		// Integer that represents the lowest possible duty 
  22:../main.c     **** #define PWM_FULL_OFF				PWM_CCU4_SYM_DUTY_MAX		// Integer that represents the highest possible duty
  23:../main.c     **** #define TIMESTAMP_DEACTIVATED		UINT32_MAX
  24:../main.c     **** 
  25:../main.c     **** // Dynamic settings (can be changed by user)
  26:../main.c     **** uint16_t relay_threshold_latchtime = 500; // Time in ms that the threshold must stay exceeded in or
  27:../main.c     **** int32_t ADC_upper_threshold = 3000;    // Upper threshold that the ADC value must be exceed to trig
  28:../main.c     **** int32_t ADC_lower_threshold = 2500;    // Upper threshold that the ADC value must be exceed to trig
  29:../main.c     **** 
  30:../main.c     **** 
  31:../main.c     **** // State machines
  32:../main.c     **** typedef enum {USB_1_active, USB_2_active, USB_inactive} USB_states;
  33:../main.c     **** typedef enum {RELAY_HIGH, RELAY_LOW} relay_states;
  34:../main.c     **** typedef enum {SETUP_IDLE, SETUP_UPPER_TH, SETUP_LOWER_TH, SETUP_TIME_TH} setup_states;
  35:../main.c     **** USB_states USB_state;
  36:../main.c     **** relay_states relay_state;
  37:../main.c     **** setup_states setup_state;
  38:../main.c     **** typedef enum {LED_OFF, LED_ON, LED_NUMBER, LED_FADE_DOWN, LED_FADE_UP, LED_MATCH_RELAY_STATE} LED_p
  39:../main.c     **** LED_patterns led_status_pattern = LED_OFF;
  40:../main.c     **** LED_patterns led_status_pattern_last = LED_OFF;
  41:../main.c     **** typedef enum {LED_PATTERN_CONTINUOUS, LED_PATTERN_SINGLE} LED_pattern_modes;
  42:../main.c     **** LED_pattern_modes led_pattern_mode = LED_PATTERN_CONTINUOUS;
  43:../main.c     **** LED_patterns led_status_pattern_after_single = LED_OFF; 	// Defines to what pattern will be switche
  44:../main.c     **** uint16_t led_number = 0;
  45:../main.c     **** uint16_t led_fadetime = 1500; // Time of one fade from one extreme to the other
  46:../main.c     **** uint16_t led_fadesteps = 1000; // Number of steps used to fade led
  47:../main.c     **** 
  48:../main.c     **** // Buttons
  49:../main.c     **** typedef enum {BTNPRESS_NOT, BTNPRESS_STD, BTNPRESS_LONG, BTNPRESS_LONGEST} button_press_states;
  50:../main.c     **** button_press_states buttonpress_usb = BTNPRESS_NOT;
  51:../main.c     **** button_press_states buttonpress_up = BTNPRESS_NOT;
  52:../main.c     **** button_press_states buttonpress_down = BTNPRESS_NOT;
  53:../main.c     **** uint32_t button_usb_pressed_timestamp = 0; // If a button is pressed (or state = HIGH) the current 
  54:../main.c     **** uint32_t button_up_pressed_timestamp = 0;
  55:../main.c     **** uint32_t button_down_pressed_timestamp = 0;
  56:../main.c     **** uint16_t button_usb_pressed_duration = 0; // If a button is released (or state = LOW) duration is c
  57:../main.c     **** uint16_t button_up_pressed_duration = 0;
  58:../main.c     **** uint16_t button_down_pressed_duration = 0;
  59:../main.c     **** #define SW_ON 0
  60:../main.c     **** #define SW_OFF 1
  61:../main.c     **** 
  62:../main.c     **** // ADC
  63:../main.c     **** uint32_t ADC_val_current = 0;
  64:../main.c     **** uint32_t ADC_val_upper_thres_exceed_timestamp = 0; // If this is 0 the threshold is not exceeded. I
  65:../main.c     **** uint32_t ADC_val_lower_thres_exceed_timestamp = 0;
  66:../main.c     **** 
  67:../main.c     **** // Debug
  68:../main.c     **** int systime_debug = 0;
  69:../main.c     **** 
  70:../main.c     **** 
  71:../main.c     **** 
  72:../main.c     **** //****************************************************************************
  73:../main.c     **** // delay_ms - millisecond delay function
  74:../main.c     **** //****************************************************************************
  75:../main.c     **** void delay_ms(uint32_t ms){
 497              	 .loc 5 75 0
 498              	 .cfi_startproc
 499 0000 80B5     	 push {r7,lr}
 500              	.LCFI24:
 501              	 .cfi_def_cfa_offset 8
 502              	 .cfi_offset 7,-8
 503              	 .cfi_offset 14,-4
 504 0002 84B0     	 sub sp,sp,#16
 505              	.LCFI25:
 506              	 .cfi_def_cfa_offset 24
 507 0004 00AF     	 add r7,sp,#0
 508              	.LCFI26:
 509              	 .cfi_def_cfa_register 7
 510 0006 7860     	 str r0,[r7,#4]
  76:../main.c     **** 	uint32_t targetMicroSec = SYSTIMER_GetTime() + (ms*1000);
 511              	 .loc 5 76 0
 512 0008 FFF7FEFF 	 bl SYSTIMER_GetTime
 513 000c 011C     	 mov r1,r0
 514 000e 7B68     	 ldr r3,[r7,#4]
 515 0010 FA22     	 mov r2,#250
 516 0012 9200     	 lsl r2,r2,#2
 517 0014 5343     	 mul r3,r2
 518 0016 CB18     	 add r3,r1,r3
 519 0018 FB60     	 str r3,[r7,#12]
  77:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 520              	 .loc 5 77 0
 521 001a 00E0     	 b .L16
 522              	.L17:
  78:../main.c     **** 		__NOP(); // do nothing
 523              	 .loc 5 78 0
 524              	
 525 001c C046     	 nop
 526              	
 527              	 .code 16
 528              	.L16:
  77:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 529              	 .loc 5 77 0
 530 001e FFF7FEFF 	 bl SYSTIMER_GetTime
 531 0022 021E     	 sub r2,r0,#0
 532 0024 FB68     	 ldr r3,[r7,#12]
 533 0026 9A42     	 cmp r2,r3
 534 0028 F8D3     	 bcc .L17
  79:../main.c     **** }
 535              	 .loc 5 79 0
 536 002a BD46     	 mov sp,r7
 537 002c 04B0     	 add sp,sp,#16
 538              	 
 539 002e 80BD     	 pop {r7,pc}
 540              	 .cfi_endproc
 541              	.LFE153:
 543              	 .section .text.reset_status_led_to_relay_state,"ax",%progbits
 544              	 .align 2
 545              	 .global reset_status_led_to_relay_state
 546              	 .code 16
 547              	 .thumb_func
 549              	reset_status_led_to_relay_state:
 550              	.LFB154:
  80:../main.c     **** 
  81:../main.c     **** //****************************************************************************
  82:../main.c     **** // reset_status_led_to_relay_state - gets state of relay and sets relay led according
  83:../main.c     **** //****************************************************************************
  84:../main.c     **** void reset_status_led_to_relay_state(){
 551              	 .loc 5 84 0
 552              	 .cfi_startproc
 553 0000 80B5     	 push {r7,lr}
 554              	.LCFI27:
 555              	 .cfi_def_cfa_offset 8
 556              	 .cfi_offset 7,-8
 557              	 .cfi_offset 14,-4
 558 0002 82B0     	 sub sp,sp,#8
 559              	.LCFI28:
 560              	 .cfi_def_cfa_offset 16
 561 0004 00AF     	 add r7,sp,#0
 562              	.LCFI29:
 563              	 .cfi_def_cfa_register 7
  85:../main.c     **** 	uint32_t state = DIGITAL_IO_GetInput(&IO_RELAY);
 564              	 .loc 5 85 0
 565 0006 0F4B     	 ldr r3,.L21
 566 0008 181C     	 mov r0,r3
 567 000a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 568 000e 031C     	 mov r3,r0
 569 0010 7B60     	 str r3,[r7,#4]
  86:../main.c     **** 	if(state == 0){
 570              	 .loc 5 86 0
 571 0012 7B68     	 ldr r3,[r7,#4]
 572 0014 002B     	 cmp r3,#0
 573 0016 09D1     	 bne .L19
  87:../main.c     **** 		led_status_pattern = LED_OFF;
 574              	 .loc 5 87 0
 575 0018 0B4B     	 ldr r3,.L21+4
 576 001a 0022     	 mov r2,#0
 577 001c 1A70     	 strb r2,[r3]
  88:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 578              	 .loc 5 88 0
 579 001e 0B4B     	 ldr r3,.L21+8
 580 0020 0B4A     	 ldr r2,.L21+12
 581 0022 181C     	 mov r0,r3
 582 0024 111C     	 mov r1,r2
 583 0026 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 584 002a 07E0     	 b .L18
 585              	.L19:
  89:../main.c     **** 	}
  90:../main.c     **** 	else{
  91:../main.c     **** 		led_status_pattern = LED_ON;
 586              	 .loc 5 91 0
 587 002c 064B     	 ldr r3,.L21+4
 588 002e 0122     	 mov r2,#1
 589 0030 1A70     	 strb r2,[r3]
  92:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 590              	 .loc 5 92 0
 591 0032 064B     	 ldr r3,.L21+8
 592 0034 181C     	 mov r0,r3
 593 0036 0021     	 mov r1,#0
 594 0038 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 595              	.L18:
  93:../main.c     **** 	}
  94:../main.c     **** }
 596              	 .loc 5 94 0
 597 003c BD46     	 mov sp,r7
 598 003e 02B0     	 add sp,sp,#8
 599              	 
 600 0040 80BD     	 pop {r7,pc}
 601              	.L22:
 602 0042 C046     	 .align 2
 603              	.L21:
 604 0044 00000000 	 .word IO_RELAY
 605 0048 00000000 	 .word led_status_pattern
 606 004c 00000000 	 .word PWM_CCU4_LED_STATUS
 607 0050 10270000 	 .word 10000
 608              	 .cfi_endproc
 609              	.LFE154:
 611              	 .global __aeabi_uidiv
 612              	 .section .text.manage_status_led,"ax",%progbits
 613              	 .align 2
 614              	 .global manage_status_led
 615              	 .code 16
 616              	 .thumb_func
 618              	manage_status_led:
 619              	.LFB155:
  95:../main.c     **** 
  96:../main.c     **** //****************************************************************************
  97:../main.c     **** // manage_status_led - blink the status led according to the given pattern and (user interface)
  98:../main.c     **** //****************************************************************************
  99:../main.c     **** void manage_status_led(){
 620              	 .loc 5 99 0
 621              	 .cfi_startproc
 622 0000 80B5     	 push {r7,lr}
 623              	.LCFI30:
 624              	 .cfi_def_cfa_offset 8
 625              	 .cfi_offset 7,-8
 626              	 .cfi_offset 14,-4
 627 0002 00AF     	 add r7,sp,#0
 628              	.LCFI31:
 629              	 .cfi_def_cfa_register 7
 100:../main.c     **** 	static uint16_t led_pattern_state;
 101:../main.c     **** 	static uint32_t led_pattern_state_timestamp;
 102:../main.c     **** 	static uint16_t led_pattern_state_length;
 103:../main.c     **** 
 104:../main.c     **** 	static uint16_t fade_duty_step;
 105:../main.c     **** 
 106:../main.c     **** 	// Check target pattern an initiate
 107:../main.c     **** 	if(led_status_pattern != led_status_pattern_last){
 630              	 .loc 5 107 0
 631 0004 A94B     	 ldr r3,.L50
 632 0006 1A78     	 ldrb r2,[r3]
 633 0008 A94B     	 ldr r3,.L50+4
 634 000a 1B78     	 ldrb r3,[r3]
 635 000c 9A42     	 cmp r2,r3
 636 000e 00D1     	 bne .LCB403
 637 0010 87E0     	 b .L24
 638              	.LCB403:
 108:../main.c     **** 		switch (led_status_pattern){
 639              	 .loc 5 108 0
 640 0012 A64B     	 ldr r3,.L50
 641 0014 1B78     	 ldrb r3,[r3]
 642 0016 052B     	 cmp r3,#5
 643 0018 00D9     	 bls .LCB407
 644 001a 7EE0     	 b .L25
 645              	.LCB407:
 646 001c 9A00     	 lsl r2,r3,#2
 647 001e A54B     	 ldr r3,.L50+8
 648 0020 D318     	 add r3,r2,r3
 649 0022 1B68     	 ldr r3,[r3]
 650 0024 9F46     	 mov pc,r3
 651              	 .section .rodata.manage_status_led,"a",%progbits
 652              	 .align 2
 653              	.L27:
 654 0000 26000000 	 .word .L26
 655 0004 34000000 	 .word .L28
 656 0008 40000000 	 .word .L29
 657 000c 6E000000 	 .word .L30
 658 0010 C0000000 	 .word .L31
 659 0014 14010000 	 .word .L32
 660              	 .section .text.manage_status_led
 661              	.L26:
 109:../main.c     **** 			case LED_OFF:
 110:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 662              	 .loc 5 110 0
 663 0026 A44B     	 ldr r3,.L50+12
 664 0028 A44A     	 ldr r2,.L50+16
 665 002a 181C     	 mov r0,r3
 666 002c 111C     	 mov r1,r2
 667 002e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 111:../main.c     **** 				break;
 668              	 .loc 5 111 0
 669 0032 72E0     	 b .L25
 670              	.L28:
 112:../main.c     **** 			case LED_ON:
 113:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 671              	 .loc 5 113 0
 672 0034 A04B     	 ldr r3,.L50+12
 673 0036 181C     	 mov r0,r3
 674 0038 0021     	 mov r1,#0
 675 003a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 114:../main.c     **** 				break;
 676              	 .loc 5 114 0
 677 003e 6CE0     	 b .L25
 678              	.L29:
 115:../main.c     **** 			case LED_NUMBER:
 116:../main.c     **** 				if(led_number >= 1){
 679              	 .loc 5 116 0
 680 0040 9F4B     	 ldr r3,.L50+20
 681 0042 1B88     	 ldrh r3,[r3]
 682 0044 002B     	 cmp r3,#0
 683 0046 11D0     	 beq .L33
 117:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 684              	 .loc 5 117 0
 685 0048 FFF7FEFF 	 bl SYSTIMER_GetTime
 686 004c 021C     	 mov r2,r0
 687 004e 9D4B     	 ldr r3,.L50+24
 688 0050 1A60     	 str r2,[r3]
 118:../main.c     **** 					led_pattern_state_length = LED_PULSE_SHORT;
 689              	 .loc 5 118 0
 690 0052 9D4B     	 ldr r3,.L50+28
 691 0054 C822     	 mov r2,#200
 692 0056 1A80     	 strh r2,[r3]
 119:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 693              	 .loc 5 119 0
 694 0058 974B     	 ldr r3,.L50+12
 695 005a 984A     	 ldr r2,.L50+16
 696 005c 181C     	 mov r0,r3
 697 005e 111C     	 mov r1,r2
 698 0060 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 120:../main.c     **** 					led_pattern_state = 0;
 699              	 .loc 5 120 0
 700 0064 994B     	 ldr r3,.L50+32
 701 0066 0022     	 mov r2,#0
 702 0068 1A80     	 strh r2,[r3]
 121:../main.c     **** 				}
 122:../main.c     **** 				break;
 703              	 .loc 5 122 0
 704 006a 56E0     	 b .L25
 705              	.L33:
 706 006c 55E0     	 b .L25
 707              	.L30:
 123:../main.c     **** 			case LED_FADE_DOWN:
 124:../main.c     **** 				if(led_fadetime > 0){
 708              	 .loc 5 124 0
 709 006e 984B     	 ldr r3,.L50+36
 710 0070 1B88     	 ldrh r3,[r3]
 711 0072 002B     	 cmp r3,#0
 712 0074 23D0     	 beq .L34
 125:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 713              	 .loc 5 125 0
 714 0076 FFF7FEFF 	 bl SYSTIMER_GetTime
 715 007a 021C     	 mov r2,r0
 716 007c 914B     	 ldr r3,.L50+24
 717 007e 1A60     	 str r2,[r3]
 126:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 718              	 .loc 5 126 0
 719 0080 934B     	 ldr r3,.L50+36
 720 0082 1A88     	 ldrh r2,[r3]
 721 0084 934B     	 ldr r3,.L50+40
 722 0086 1B88     	 ldrh r3,[r3]
 723 0088 101C     	 mov r0,r2
 724 008a 191C     	 mov r1,r3
 725 008c FFF7FEFF 	 bl __aeabi_uidiv
 726 0090 031C     	 mov r3,r0
 727 0092 9AB2     	 uxth r2,r3
 728 0094 8C4B     	 ldr r3,.L50+28
 729 0096 1A80     	 strh r2,[r3]
 127:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 730              	 .loc 5 127 0
 731 0098 8E4B     	 ldr r3,.L50+40
 732 009a 1B88     	 ldrh r3,[r3]
 733 009c 8748     	 ldr r0,.L50+16
 734 009e 191C     	 mov r1,r3
 735 00a0 FFF7FEFF 	 bl __aeabi_uidiv
 736 00a4 031C     	 mov r3,r0
 737 00a6 9AB2     	 uxth r2,r3
 738 00a8 8B4B     	 ldr r3,.L50+44
 739 00aa 1A80     	 strh r2,[r3]
 128:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 740              	 .loc 5 128 0
 741 00ac 824B     	 ldr r3,.L50+12
 742 00ae 181C     	 mov r0,r3
 743 00b0 0021     	 mov r1,#0
 744 00b2 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 129:../main.c     **** 					led_pattern_state = 0;
 745              	 .loc 5 129 0
 746 00b6 854B     	 ldr r3,.L50+32
 747 00b8 0022     	 mov r2,#0
 748 00ba 1A80     	 strh r2,[r3]
 130:../main.c     **** 				}
 131:../main.c     **** 				break;
 749              	 .loc 5 131 0
 750 00bc 2DE0     	 b .L25
 751              	.L34:
 752 00be 2CE0     	 b .L25
 753              	.L31:
 132:../main.c     **** 			case LED_FADE_UP:
 133:../main.c     **** 				if(led_fadetime > 0){
 754              	 .loc 5 133 0
 755 00c0 834B     	 ldr r3,.L50+36
 756 00c2 1B88     	 ldrh r3,[r3]
 757 00c4 002B     	 cmp r3,#0
 758 00c6 24D0     	 beq .L35
 134:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 759              	 .loc 5 134 0
 760 00c8 FFF7FEFF 	 bl SYSTIMER_GetTime
 761 00cc 021C     	 mov r2,r0
 762 00ce 7D4B     	 ldr r3,.L50+24
 763 00d0 1A60     	 str r2,[r3]
 135:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 764              	 .loc 5 135 0
 765 00d2 7F4B     	 ldr r3,.L50+36
 766 00d4 1A88     	 ldrh r2,[r3]
 767 00d6 7F4B     	 ldr r3,.L50+40
 768 00d8 1B88     	 ldrh r3,[r3]
 769 00da 101C     	 mov r0,r2
 770 00dc 191C     	 mov r1,r3
 771 00de FFF7FEFF 	 bl __aeabi_uidiv
 772 00e2 031C     	 mov r3,r0
 773 00e4 9AB2     	 uxth r2,r3
 774 00e6 784B     	 ldr r3,.L50+28
 775 00e8 1A80     	 strh r2,[r3]
 136:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 776              	 .loc 5 136 0
 777 00ea 7A4B     	 ldr r3,.L50+40
 778 00ec 1B88     	 ldrh r3,[r3]
 779 00ee 7348     	 ldr r0,.L50+16
 780 00f0 191C     	 mov r1,r3
 781 00f2 FFF7FEFF 	 bl __aeabi_uidiv
 782 00f6 031C     	 mov r3,r0
 783 00f8 9AB2     	 uxth r2,r3
 784 00fa 774B     	 ldr r3,.L50+44
 785 00fc 1A80     	 strh r2,[r3]
 137:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 786              	 .loc 5 137 0
 787 00fe 6E4B     	 ldr r3,.L50+12
 788 0100 6E4A     	 ldr r2,.L50+16
 789 0102 181C     	 mov r0,r3
 790 0104 111C     	 mov r1,r2
 791 0106 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 138:../main.c     **** 					led_pattern_state = 0;
 792              	 .loc 5 138 0
 793 010a 704B     	 ldr r3,.L50+32
 794 010c 0022     	 mov r2,#0
 795 010e 1A80     	 strh r2,[r3]
 139:../main.c     **** 				}
 140:../main.c     **** 				break;
 796              	 .loc 5 140 0
 797 0110 03E0     	 b .L25
 798              	.L35:
 799 0112 02E0     	 b .L25
 800              	.L32:
 141:../main.c     **** 			case LED_MATCH_RELAY_STATE:
 142:../main.c     **** 				reset_status_led_to_relay_state();
 801              	 .loc 5 142 0
 802 0114 FFF7FEFF 	 bl reset_status_led_to_relay_state
 143:../main.c     **** 				break;
 803              	 .loc 5 143 0
 804 0118 C046     	 mov r8,r8
 805              	.L25:
 144:../main.c     **** 		}
 145:../main.c     **** 		led_status_pattern_last = led_status_pattern;
 806              	 .loc 5 145 0
 807 011a 644B     	 ldr r3,.L50
 808 011c 1A78     	 ldrb r2,[r3]
 809 011e 644B     	 ldr r3,.L50+4
 810 0120 1A70     	 strb r2,[r3]
 811              	.L24:
 146:../main.c     **** 	}
 147:../main.c     **** 
 148:../main.c     **** 	// Handle LED_NUMBER pattern
 149:../main.c     **** 	if(led_status_pattern == LED_NUMBER){
 812              	 .loc 5 149 0
 813 0122 624B     	 ldr r3,.L50
 814 0124 1B78     	 ldrb r3,[r3]
 815 0126 022B     	 cmp r3,#2
 816 0128 60D1     	 bne .L36
 150:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 817              	 .loc 5 150 0
 818 012a FFF7FEFF 	 bl SYSTIMER_GetTime
 819 012e 021C     	 mov r2,r0
 820 0130 644B     	 ldr r3,.L50+24
 821 0132 1B68     	 ldr r3,[r3]
 822 0134 D31A     	 sub r3,r2,r3
 823 0136 181C     	 mov r0,r3
 824 0138 FA23     	 mov r3,#250
 825 013a 9900     	 lsl r1,r3,#2
 826 013c FFF7FEFF 	 bl __aeabi_uidiv
 827 0140 031C     	 mov r3,r0
 828 0142 1A1C     	 mov r2,r3
 829 0144 604B     	 ldr r3,.L50+28
 830 0146 1B88     	 ldrh r3,[r3]
 831 0148 9A42     	 cmp r2,r3
 832 014a 00D2     	 bcs .LCB578
 833 014c 29E1     	 b .L23
 834              	.LCB578:
 151:../main.c     **** 			// Next state
 152:../main.c     **** 			led_pattern_state++;
 835              	 .loc 5 152 0
 836 014e 5F4B     	 ldr r3,.L50+32
 837 0150 1B88     	 ldrh r3,[r3]
 838 0152 0133     	 add r3,r3,#1
 839 0154 9AB2     	 uxth r2,r3
 840 0156 5D4B     	 ldr r3,.L50+32
 841 0158 1A80     	 strh r2,[r3]
 153:../main.c     **** 
 154:../main.c     **** 			// Check if LED must be powered on or off for this state
 155:../main.c     **** 			if(led_pattern_state % 2)
 842              	 .loc 5 155 0
 843 015a 5C4B     	 ldr r3,.L50+32
 844 015c 1B88     	 ldrh r3,[r3]
 845 015e 0122     	 mov r2,#1
 846 0160 1340     	 and r3,r2
 847 0162 9BB2     	 uxth r3,r3
 848 0164 002B     	 cmp r3,#0
 849 0166 05D0     	 beq .L38
 156:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 850              	 .loc 5 156 0
 851 0168 534B     	 ldr r3,.L50+12
 852 016a 181C     	 mov r0,r3
 853 016c 0021     	 mov r1,#0
 854 016e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 855 0172 05E0     	 b .L39
 856              	.L38:
 157:../main.c     **** 			else
 158:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 857              	 .loc 5 158 0
 858 0174 504B     	 ldr r3,.L50+12
 859 0176 514A     	 ldr r2,.L50+16
 860 0178 181C     	 mov r0,r3
 861 017a 111C     	 mov r1,r2
 862 017c FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 863              	.L39:
 159:../main.c     **** 
 160:../main.c     **** 			// Detect last low phase and make it longer
 161:../main.c     **** 			if(led_pattern_state == (led_number*2) && led_pattern_mode == LED_PATTERN_CONTINUOUS)
 864              	 .loc 5 161 0
 865 0180 524B     	 ldr r3,.L50+32
 866 0182 1B88     	 ldrh r3,[r3]
 867 0184 1A1C     	 mov r2,r3
 868 0186 4E4B     	 ldr r3,.L50+20
 869 0188 1B88     	 ldrh r3,[r3]
 870 018a 5B00     	 lsl r3,r3,#1
 871 018c 9A42     	 cmp r2,r3
 872 018e 07D1     	 bne .L40
 873              	 .loc 5 161 0 is_stmt 0 discriminator 1
 874 0190 524B     	 ldr r3,.L50+48
 875 0192 1B78     	 ldrb r3,[r3]
 876 0194 002B     	 cmp r3,#0
 877 0196 03D1     	 bne .L40
 162:../main.c     **** 				led_pattern_state_length = LED_PULSE_LONG;
 878              	 .loc 5 162 0 is_stmt 1
 879 0198 4B4B     	 ldr r3,.L50+28
 880 019a 514A     	 ldr r2,.L50+52
 881 019c 1A80     	 strh r2,[r3]
 882 019e 02E0     	 b .L41
 883              	.L40:
 163:../main.c     **** 			else
 164:../main.c     **** 				led_pattern_state_length = LED_PULSE_SHORT;
 884              	 .loc 5 164 0
 885 01a0 494B     	 ldr r3,.L50+28
 886 01a2 C822     	 mov r2,#200
 887 01a4 1A80     	 strh r2,[r3]
 888              	.L41:
 165:../main.c     **** 
 166:../main.c     **** 			// Store current time
 167:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 889              	 .loc 5 167 0
 890 01a6 FFF7FEFF 	 bl SYSTIMER_GetTime
 891 01aa 021C     	 mov r2,r0
 892 01ac 454B     	 ldr r3,.L50+24
 893 01ae 1A60     	 str r2,[r3]
 168:../main.c     **** 
 169:../main.c     **** 			// Check if LED pattern is finished
 170:../main.c     **** 			if(led_pattern_state > led_number*2){
 894              	 .loc 5 170 0
 895 01b0 464B     	 ldr r3,.L50+32
 896 01b2 1B88     	 ldrh r3,[r3]
 897 01b4 1A1C     	 mov r2,r3
 898 01b6 424B     	 ldr r3,.L50+20
 899 01b8 1B88     	 ldrh r3,[r3]
 900 01ba 5B00     	 lsl r3,r3,#1
 901 01bc 9A42     	 cmp r2,r3
 902 01be 00DC     	 bgt .LCB642
 903 01c0 EFE0     	 b .L23
 904              	.LCB642:
 171:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS) // Repeat pattern
 905              	 .loc 5 171 0
 906 01c2 464B     	 ldr r3,.L50+48
 907 01c4 1B78     	 ldrb r3,[r3]
 908 01c6 002B     	 cmp r3,#0
 909 01c8 03D1     	 bne .L42
 172:../main.c     **** 					led_pattern_state = 1;
 910              	 .loc 5 172 0
 911 01ca 404B     	 ldr r3,.L50+32
 912 01cc 0122     	 mov r2,#1
 913 01ce 1A80     	 strh r2,[r3]
 914 01d0 E7E0     	 b .L23
 915              	.L42:
 173:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 916              	 .loc 5 173 0
 917 01d2 424B     	 ldr r3,.L50+48
 918 01d4 1B78     	 ldrb r3,[r3]
 919 01d6 012B     	 cmp r3,#1
 920 01d8 00D0     	 beq .LCB657
 921 01da E2E0     	 b .L23
 922              	.LCB657:
 174:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 923              	 .loc 5 174 0
 924 01dc 3F4B     	 ldr r3,.L50+48
 925 01de 0022     	 mov r2,#0
 926 01e0 1A70     	 strb r2,[r3]
 175:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 927              	 .loc 5 175 0
 928 01e2 404B     	 ldr r3,.L50+56
 929 01e4 1A78     	 ldrb r2,[r3]
 930 01e6 314B     	 ldr r3,.L50
 931 01e8 1A70     	 strb r2,[r3]
 932 01ea DAE0     	 b .L23
 933              	.L36:
 176:../main.c     **** 				}
 177:../main.c     **** 			}
 178:../main.c     **** 		}
 179:../main.c     **** 	}
 180:../main.c     **** 
 181:../main.c     **** 	// Handle LED_FADE_UP pattern
 182:../main.c     **** 	else if(led_status_pattern == LED_FADE_DOWN){
 934              	 .loc 5 182 0
 935 01ec 2F4B     	 ldr r3,.L50
 936 01ee 1B78     	 ldrb r3,[r3]
 937 01f0 032B     	 cmp r3,#3
 938 01f2 00D0     	 beq .LCB672
 939 01f4 78E0     	 b .L44
 940              	.LCB672:
 183:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 941              	 .loc 5 183 0
 942 01f6 FFF7FEFF 	 bl SYSTIMER_GetTime
 943 01fa 021C     	 mov r2,r0
 944 01fc 314B     	 ldr r3,.L50+24
 945 01fe 1B68     	 ldr r3,[r3]
 946 0200 D31A     	 sub r3,r2,r3
 947 0202 181C     	 mov r0,r3
 948 0204 FA23     	 mov r3,#250
 949 0206 9900     	 lsl r1,r3,#2
 950 0208 FFF7FEFF 	 bl __aeabi_uidiv
 951 020c 031C     	 mov r3,r0
 952 020e 1A1C     	 mov r2,r3
 953 0210 2D4B     	 ldr r3,.L50+28
 954 0212 1B88     	 ldrh r3,[r3]
 955 0214 9A42     	 cmp r2,r3
 956 0216 00D2     	 bcs .LCB687
 957 0218 C3E0     	 b .L23
 958              	.LCB687:
 184:../main.c     **** 			//
 185:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, (led_pattern_state*fade_duty_step) + PWM_FULL_ON);
 959              	 .loc 5 185 0
 960 021a 2C4B     	 ldr r3,.L50+32
 961 021c 1B88     	 ldrh r3,[r3]
 962 021e 1A1C     	 mov r2,r3
 963 0220 2D4B     	 ldr r3,.L50+44
 964 0222 1B88     	 ldrh r3,[r3]
 965 0224 5343     	 mul r3,r2
 966 0226 1A1C     	 mov r2,r3
 967 0228 234B     	 ldr r3,.L50+12
 968 022a 181C     	 mov r0,r3
 969 022c 111C     	 mov r1,r2
 970 022e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 186:../main.c     **** 
 187:../main.c     **** 			// Store current time
 188:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 971              	 .loc 5 188 0
 972 0232 FFF7FEFF 	 bl SYSTIMER_GetTime
 973 0236 021C     	 mov r2,r0
 974 0238 224B     	 ldr r3,.L50+24
 975 023a 1A60     	 str r2,[r3]
 189:../main.c     **** 
 190:../main.c     **** 			// Next state
 191:../main.c     **** 			led_pattern_state++;
 976              	 .loc 5 191 0
 977 023c 234B     	 ldr r3,.L50+32
 978 023e 1B88     	 ldrh r3,[r3]
 979 0240 0133     	 add r3,r3,#1
 980 0242 9AB2     	 uxth r2,r3
 981 0244 214B     	 ldr r3,.L50+32
 982 0246 1A80     	 strh r2,[r3]
 192:../main.c     **** 
 193:../main.c     **** 			// Make last state longer
 194:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 983              	 .loc 5 194 0
 984 0248 204B     	 ldr r3,.L50+32
 985 024a 1B88     	 ldrh r3,[r3]
 986 024c 1A1C     	 mov r2,r3
 987 024e 214B     	 ldr r3,.L50+40
 988 0250 1B88     	 ldrh r3,[r3]
 989 0252 013B     	 sub r3,r3,#1
 990 0254 9A42     	 cmp r2,r3
 991 0256 06D1     	 bne .L46
 195:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 992              	 .loc 5 195 0
 993 0258 1B4B     	 ldr r3,.L50+28
 994 025a 1B88     	 ldrh r3,[r3]
 995 025c 9133     	 add r3,r3,#145
 996 025e FF33     	 add r3,r3,#255
 997 0260 9AB2     	 uxth r2,r3
 998 0262 194B     	 ldr r3,.L50+28
 999 0264 1A80     	 strh r2,[r3]
 1000              	.L46:
 196:../main.c     **** 
 197:../main.c     **** 			// Check if LED pattern is finished
 198:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1001              	 .loc 5 198 0
 1002 0266 194B     	 ldr r3,.L50+32
 1003 0268 1A88     	 ldrh r2,[r3]
 1004 026a 1A4B     	 ldr r3,.L50+40
 1005 026c 1B88     	 ldrh r3,[r3]
 1006 026e 9A42     	 cmp r2,r3
 1007 0270 00D2     	 bcs .LCB731
 1008 0272 96E0     	 b .L23
 1009              	.LCB731:
 199:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1010              	 .loc 5 199 0
 1011 0274 194B     	 ldr r3,.L50+48
 1012 0276 1B78     	 ldrb r3,[r3]
 1013 0278 002B     	 cmp r3,#0
 1014 027a 0AD1     	 bne .L47
 200:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1015              	 .loc 5 200 0
 1016 027c 124B     	 ldr r3,.L50+28
 1017 027e 1B88     	 ldrh r3,[r3]
 1018 0280 913B     	 sub r3,r3,#145
 1019 0282 FF3B     	 sub r3,r3,#255
 1020 0284 9AB2     	 uxth r2,r3
 1021 0286 104B     	 ldr r3,.L50+28
 1022 0288 1A80     	 strh r2,[r3]
 201:../main.c     **** 					led_pattern_state = 0;
 1023              	 .loc 5 201 0
 1024 028a 104B     	 ldr r3,.L50+32
 1025 028c 0022     	 mov r2,#0
 1026 028e 1A80     	 strh r2,[r3]
 1027 0290 87E0     	 b .L23
 1028              	.L47:
 202:../main.c     **** 				}
 203:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1029              	 .loc 5 203 0
 1030 0292 124B     	 ldr r3,.L50+48
 1031 0294 1B78     	 ldrb r3,[r3]
 1032 0296 012B     	 cmp r3,#1
 1033 0298 00D0     	 beq .LCB753
 1034 029a 82E0     	 b .L23
 1035              	.LCB753:
 204:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1036              	 .loc 5 204 0
 1037 029c 0F4B     	 ldr r3,.L50+48
 1038 029e 0022     	 mov r2,#0
 1039 02a0 1A70     	 strb r2,[r3]
 205:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1040              	 .loc 5 205 0
 1041 02a2 104B     	 ldr r3,.L50+56
 1042 02a4 1A78     	 ldrb r2,[r3]
 1043 02a6 014B     	 ldr r3,.L50
 1044 02a8 1A70     	 strb r2,[r3]
 1045 02aa 7AE0     	 b .L23
 1046              	.L51:
 1047              	 .align 2
 1048              	.L50:
 1049 02ac 00000000 	 .word led_status_pattern
 1050 02b0 00000000 	 .word led_status_pattern_last
 1051 02b4 00000000 	 .word .L27
 1052 02b8 00000000 	 .word PWM_CCU4_LED_STATUS
 1053 02bc 10270000 	 .word 10000
 1054 02c0 00000000 	 .word led_number
 1055 02c4 00000000 	 .word led_pattern_state_timestamp.7000
 1056 02c8 00000000 	 .word led_pattern_state_length.7001
 1057 02cc 00000000 	 .word led_pattern_state.6999
 1058 02d0 00000000 	 .word led_fadetime
 1059 02d4 00000000 	 .word led_fadesteps
 1060 02d8 00000000 	 .word fade_duty_step.7002
 1061 02dc 00000000 	 .word led_pattern_mode
 1062 02e0 4C040000 	 .word 1100
 1063 02e4 00000000 	 .word led_status_pattern_after_single
 1064              	.L44:
 206:../main.c     **** 				}
 207:../main.c     **** 			}
 208:../main.c     **** 		}
 209:../main.c     **** 	}
 210:../main.c     **** 
 211:../main.c     **** 	// Handle LED_FADE_DOWN pattern
 212:../main.c     **** 	else if(led_status_pattern == LED_FADE_UP){
 1065              	 .loc 5 212 0
 1066 02e8 2F4B     	 ldr r3,.L52
 1067 02ea 1B78     	 ldrb r3,[r3]
 1068 02ec 042B     	 cmp r3,#4
 1069 02ee 58D1     	 bne .L23
 213:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 1070              	 .loc 5 213 0
 1071 02f0 FFF7FEFF 	 bl SYSTIMER_GetTime
 1072 02f4 021C     	 mov r2,r0
 1073 02f6 2D4B     	 ldr r3,.L52+4
 1074 02f8 1B68     	 ldr r3,[r3]
 1075 02fa D31A     	 sub r3,r2,r3
 1076 02fc 181C     	 mov r0,r3
 1077 02fe FA23     	 mov r3,#250
 1078 0300 9900     	 lsl r1,r3,#2
 1079 0302 FFF7FEFF 	 bl __aeabi_uidiv
 1080 0306 031C     	 mov r3,r0
 1081 0308 1A1C     	 mov r2,r3
 1082 030a 294B     	 ldr r3,.L52+8
 1083 030c 1B88     	 ldrh r3,[r3]
 1084 030e 9A42     	 cmp r2,r3
 1085 0310 47D3     	 bcc .L23
 214:../main.c     **** 			//
 215:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF - (led_pattern_state*fade_duty_step) );
 1086              	 .loc 5 215 0
 1087 0312 284B     	 ldr r3,.L52+12
 1088 0314 1B88     	 ldrh r3,[r3]
 1089 0316 1A1C     	 mov r2,r3
 1090 0318 274B     	 ldr r3,.L52+16
 1091 031a 1B88     	 ldrh r3,[r3]
 1092 031c 5343     	 mul r3,r2
 1093 031e 1A1C     	 mov r2,r3
 1094 0320 264B     	 ldr r3,.L52+20
 1095 0322 9B1A     	 sub r3,r3,r2
 1096 0324 264A     	 ldr r2,.L52+24
 1097 0326 101C     	 mov r0,r2
 1098 0328 191C     	 mov r1,r3
 1099 032a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 216:../main.c     **** 
 217:../main.c     **** 			// Store current time
 218:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 1100              	 .loc 5 218 0
 1101 032e FFF7FEFF 	 bl SYSTIMER_GetTime
 1102 0332 021C     	 mov r2,r0
 1103 0334 1D4B     	 ldr r3,.L52+4
 1104 0336 1A60     	 str r2,[r3]
 219:../main.c     **** 
 220:../main.c     **** 			// Next state
 221:../main.c     **** 			led_pattern_state++;
 1105              	 .loc 5 221 0
 1106 0338 1E4B     	 ldr r3,.L52+12
 1107 033a 1B88     	 ldrh r3,[r3]
 1108 033c 0133     	 add r3,r3,#1
 1109 033e 9AB2     	 uxth r2,r3
 1110 0340 1C4B     	 ldr r3,.L52+12
 1111 0342 1A80     	 strh r2,[r3]
 222:../main.c     **** 
 223:../main.c     **** 			// Make last state longer
 224:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 1112              	 .loc 5 224 0
 1113 0344 1B4B     	 ldr r3,.L52+12
 1114 0346 1B88     	 ldrh r3,[r3]
 1115 0348 1A1C     	 mov r2,r3
 1116 034a 1E4B     	 ldr r3,.L52+28
 1117 034c 1B88     	 ldrh r3,[r3]
 1118 034e 013B     	 sub r3,r3,#1
 1119 0350 9A42     	 cmp r2,r3
 1120 0352 06D1     	 bne .L48
 225:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 1121              	 .loc 5 225 0
 1122 0354 164B     	 ldr r3,.L52+8
 1123 0356 1B88     	 ldrh r3,[r3]
 1124 0358 9133     	 add r3,r3,#145
 1125 035a FF33     	 add r3,r3,#255
 1126 035c 9AB2     	 uxth r2,r3
 1127 035e 144B     	 ldr r3,.L52+8
 1128 0360 1A80     	 strh r2,[r3]
 1129              	.L48:
 226:../main.c     **** 
 227:../main.c     **** 			// Check if LED pattern is finished
 228:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1130              	 .loc 5 228 0
 1131 0362 144B     	 ldr r3,.L52+12
 1132 0364 1A88     	 ldrh r2,[r3]
 1133 0366 174B     	 ldr r3,.L52+28
 1134 0368 1B88     	 ldrh r3,[r3]
 1135 036a 9A42     	 cmp r2,r3
 1136 036c 19D3     	 bcc .L23
 229:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1137              	 .loc 5 229 0
 1138 036e 164B     	 ldr r3,.L52+32
 1139 0370 1B78     	 ldrb r3,[r3]
 1140 0372 002B     	 cmp r3,#0
 1141 0374 0AD1     	 bne .L49
 230:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1142              	 .loc 5 230 0
 1143 0376 0E4B     	 ldr r3,.L52+8
 1144 0378 1B88     	 ldrh r3,[r3]
 1145 037a 913B     	 sub r3,r3,#145
 1146 037c FF3B     	 sub r3,r3,#255
 1147 037e 9AB2     	 uxth r2,r3
 1148 0380 0B4B     	 ldr r3,.L52+8
 1149 0382 1A80     	 strh r2,[r3]
 231:../main.c     **** 					led_pattern_state = 0;
 1150              	 .loc 5 231 0
 1151 0384 0B4B     	 ldr r3,.L52+12
 1152 0386 0022     	 mov r2,#0
 1153 0388 1A80     	 strh r2,[r3]
 1154 038a 0AE0     	 b .L23
 1155              	.L49:
 232:../main.c     **** 				}
 233:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1156              	 .loc 5 233 0
 1157 038c 0E4B     	 ldr r3,.L52+32
 1158 038e 1B78     	 ldrb r3,[r3]
 1159 0390 012B     	 cmp r3,#1
 1160 0392 06D1     	 bne .L23
 234:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1161              	 .loc 5 234 0
 1162 0394 0C4B     	 ldr r3,.L52+32
 1163 0396 0022     	 mov r2,#0
 1164 0398 1A70     	 strb r2,[r3]
 235:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1165              	 .loc 5 235 0
 1166 039a 0C4B     	 ldr r3,.L52+36
 1167 039c 1A78     	 ldrb r2,[r3]
 1168 039e 024B     	 ldr r3,.L52
 1169 03a0 1A70     	 strb r2,[r3]
 1170              	.L23:
 236:../main.c     **** 				}
 237:../main.c     **** 			}
 238:../main.c     **** 		}
 239:../main.c     **** 	}
 240:../main.c     **** }
 1171              	 .loc 5 240 0
 1172 03a2 BD46     	 mov sp,r7
 1173              	 
 1174 03a4 80BD     	 pop {r7,pc}
 1175              	.L53:
 1176 03a6 C046     	 .align 2
 1177              	.L52:
 1178 03a8 00000000 	 .word led_status_pattern
 1179 03ac 00000000 	 .word led_pattern_state_timestamp.7000
 1180 03b0 00000000 	 .word led_pattern_state_length.7001
 1181 03b4 00000000 	 .word led_pattern_state.6999
 1182 03b8 00000000 	 .word fade_duty_step.7002
 1183 03bc 10270000 	 .word 10000
 1184 03c0 00000000 	 .word PWM_CCU4_LED_STATUS
 1185 03c4 00000000 	 .word led_fadesteps
 1186 03c8 00000000 	 .word led_pattern_mode
 1187 03cc 00000000 	 .word led_status_pattern_after_single
 1188              	 .cfi_endproc
 1189              	.LFE155:
 1191              	 .section .text.manage_buttons,"ax",%progbits
 1192              	 .align 2
 1193              	 .global manage_buttons
 1194              	 .code 16
 1195              	 .thumb_func
 1197              	manage_buttons:
 1198              	.LFB156:
 241:../main.c     **** 
 242:../main.c     **** //****************************************************************************
 243:../main.c     **** // main - function to manage, debounce and interpret button presses
 244:../main.c     **** //****************************************************************************
 245:../main.c     **** void manage_buttons(void)
 246:../main.c     **** {
 1199              	 .loc 5 246 0
 1200              	 .cfi_startproc
 1201 0000 80B5     	 push {r7,lr}
 1202              	.LCFI32:
 1203              	 .cfi_def_cfa_offset 8
 1204              	 .cfi_offset 7,-8
 1205              	 .cfi_offset 14,-4
 1206 0002 00AF     	 add r7,sp,#0
 1207              	.LCFI33:
 1208              	 .cfi_def_cfa_register 7
 247:../main.c     **** 	/// Detect start of press and save current system time
 248:../main.c     **** 	if(button_usb_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_ON)
 1209              	 .loc 5 248 0
 1210 0004 8F4B     	 ldr r3,.L73
 1211 0006 1B68     	 ldr r3,[r3]
 1212 0008 002B     	 cmp r3,#0
 1213 000a 0AD1     	 bne .L55
 1214              	 .loc 5 248 0 is_stmt 0 discriminator 1
 1215 000c 8E4B     	 ldr r3,.L73+4
 1216 000e 181C     	 mov r0,r3
 1217 0010 FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1218 0014 031E     	 sub r3,r0,#0
 1219 0016 04D1     	 bne .L55
 249:../main.c     **** 		button_usb_pressed_timestamp = SYSTIMER_GetTime();
 1220              	 .loc 5 249 0 is_stmt 1
 1221 0018 FFF7FEFF 	 bl SYSTIMER_GetTime
 1222 001c 021C     	 mov r2,r0
 1223 001e 894B     	 ldr r3,.L73
 1224 0020 1A60     	 str r2,[r3]
 1225              	.L55:
 250:../main.c     **** 	if(button_up_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_ON)
 1226              	 .loc 5 250 0
 1227 0022 8A4B     	 ldr r3,.L73+8
 1228 0024 1B68     	 ldr r3,[r3]
 1229 0026 002B     	 cmp r3,#0
 1230 0028 0AD1     	 bne .L56
 1231              	 .loc 5 250 0 is_stmt 0 discriminator 1
 1232 002a 894B     	 ldr r3,.L73+12
 1233 002c 181C     	 mov r0,r3
 1234 002e FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1235 0032 031E     	 sub r3,r0,#0
 1236 0034 04D1     	 bne .L56
 251:../main.c     **** 		button_up_pressed_timestamp = SYSTIMER_GetTime();
 1237              	 .loc 5 251 0 is_stmt 1
 1238 0036 FFF7FEFF 	 bl SYSTIMER_GetTime
 1239 003a 021C     	 mov r2,r0
 1240 003c 834B     	 ldr r3,.L73+8
 1241 003e 1A60     	 str r2,[r3]
 1242              	.L56:
 252:../main.c     **** 	if(button_down_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_ON)
 1243              	 .loc 5 252 0
 1244 0040 844B     	 ldr r3,.L73+16
 1245 0042 1B68     	 ldr r3,[r3]
 1246 0044 002B     	 cmp r3,#0
 1247 0046 0AD1     	 bne .L57
 1248              	 .loc 5 252 0 is_stmt 0 discriminator 1
 1249 0048 834B     	 ldr r3,.L73+20
 1250 004a 181C     	 mov r0,r3
 1251 004c FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1252 0050 031E     	 sub r3,r0,#0
 1253 0052 04D1     	 bne .L57
 253:../main.c     **** 		button_down_pressed_timestamp = SYSTIMER_GetTime();
 1254              	 .loc 5 253 0 is_stmt 1
 1255 0054 FFF7FEFF 	 bl SYSTIMER_GetTime
 1256 0058 021C     	 mov r2,r0
 1257 005a 7E4B     	 ldr r3,.L73+16
 1258 005c 1A60     	 str r2,[r3]
 1259              	.L57:
 254:../main.c     **** 
 255:../main.c     **** 	// USB BUTTON: If a press in ongoing and release is detected, calculate time difference
 256:../main.c     **** 	if(button_usb_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_OFF){
 1260              	 .loc 5 256 0
 1261 005e 794B     	 ldr r3,.L73
 1262 0060 1B68     	 ldr r3,[r3]
 1263 0062 002B     	 cmp r3,#0
 1264 0064 33D0     	 beq .L58
 1265              	 .loc 5 256 0 is_stmt 0 discriminator 1
 1266 0066 784B     	 ldr r3,.L73+4
 1267 0068 181C     	 mov r0,r3
 1268 006a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1269 006e 031E     	 sub r3,r0,#0
 1270 0070 012B     	 cmp r3,#1
 1271 0072 2CD1     	 bne .L58
 257:../main.c     **** 		button_usb_pressed_duration = (SYSTIMER_GetTime() - button_usb_pressed_timestamp) / 1000; // conv
 1272              	 .loc 5 257 0 is_stmt 1
 1273 0074 FFF7FEFF 	 bl SYSTIMER_GetTime
 1274 0078 021C     	 mov r2,r0
 1275 007a 724B     	 ldr r3,.L73
 1276 007c 1B68     	 ldr r3,[r3]
 1277 007e D31A     	 sub r3,r2,r3
 1278 0080 181C     	 mov r0,r3
 1279 0082 FA23     	 mov r3,#250
 1280 0084 9900     	 lsl r1,r3,#2
 1281 0086 FFF7FEFF 	 bl __aeabi_uidiv
 1282 008a 031C     	 mov r3,r0
 1283 008c 9AB2     	 uxth r2,r3
 1284 008e 734B     	 ldr r3,.L73+24
 1285 0090 1A80     	 strh r2,[r3]
 258:../main.c     **** 		button_usb_pressed_timestamp = 0;
 1286              	 .loc 5 258 0
 1287 0092 6C4B     	 ldr r3,.L73
 1288 0094 0022     	 mov r2,#0
 1289 0096 1A60     	 str r2,[r3]
 259:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 260:../main.c     **** 		if(button_usb_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1290              	 .loc 5 260 0
 1291 0098 704B     	 ldr r3,.L73+24
 1292 009a 1B88     	 ldrh r3,[r3]
 1293 009c 704A     	 ldr r2,.L73+28
 1294 009e 9342     	 cmp r3,r2
 1295 00a0 03D9     	 bls .L59
 261:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1296              	 .loc 5 261 0
 1297 00a2 704B     	 ldr r3,.L73+32
 1298 00a4 0022     	 mov r2,#0
 1299 00a6 1A70     	 strb r2,[r3]
 1300 00a8 10E0     	 b .L60
 1301              	.L59:
 262:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1302              	 .loc 5 262 0
 1303 00aa 6C4B     	 ldr r3,.L73+24
 1304 00ac 1B88     	 ldrh r3,[r3]
 1305 00ae 6E4A     	 ldr r2,.L73+36
 1306 00b0 9342     	 cmp r3,r2
 1307 00b2 03D9     	 bls .L61
 263:../main.c     **** 			buttonpress_usb = BTNPRESS_LONG;
 1308              	 .loc 5 263 0
 1309 00b4 6B4B     	 ldr r3,.L73+32
 1310 00b6 0222     	 mov r2,#2
 1311 00b8 1A70     	 strb r2,[r3]
 1312 00ba 07E0     	 b .L60
 1313              	.L61:
 264:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_STD_PRESS_DURATION)
 1314              	 .loc 5 264 0
 1315 00bc 674B     	 ldr r3,.L73+24
 1316 00be 1B88     	 ldrh r3,[r3]
 1317 00c0 3B2B     	 cmp r3,#59
 1318 00c2 03D9     	 bls .L60
 265:../main.c     **** 			buttonpress_usb = BTNPRESS_STD;
 1319              	 .loc 5 265 0
 1320 00c4 674B     	 ldr r3,.L73+32
 1321 00c6 0122     	 mov r2,#1
 1322 00c8 1A70     	 strb r2,[r3]
 260:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1323              	 .loc 5 260 0
 1324 00ca 18E0     	 b .L62
 1325              	.L60:
 1326 00cc 17E0     	 b .L62
 1327              	.L58:
 266:../main.c     **** 	}
 267:../main.c     **** 	// USB BUTTON: If press is to long reset (simulate that press ended)
 268:../main.c     **** 	else if(button_usb_pressed_timestamp != 0 && button_usb_pressed_timestamp != TIMESTAMP_DEACTIVATED
 1328              	 .loc 5 268 0
 1329 00ce 5D4B     	 ldr r3,.L73
 1330 00d0 1B68     	 ldr r3,[r3]
 1331 00d2 002B     	 cmp r3,#0
 1332 00d4 13D0     	 beq .L62
 1333              	 .loc 5 268 0 is_stmt 0 discriminator 1
 1334 00d6 5B4B     	 ldr r3,.L73
 1335 00d8 1B68     	 ldr r3,[r3]
 1336 00da 0133     	 add r3,r3,#1
 1337 00dc 0FD0     	 beq .L62
 1338              	 .loc 5 268 0 discriminator 2
 1339 00de FFF7FEFF 	 bl SYSTIMER_GetTime
 1340 00e2 021C     	 mov r2,r0
 1341 00e4 574B     	 ldr r3,.L73
 1342 00e6 1B68     	 ldr r3,[r3]
 1343 00e8 D31A     	 sub r3,r2,r3
 1344 00ea 604A     	 ldr r2,.L73+40
 1345 00ec 9342     	 cmp r3,r2
 1346 00ee 06D9     	 bls .L62
 269:../main.c     **** 		button_usb_pressed_timestamp = TIMESTAMP_DEACTIVATED; // deactivate timestamp till button is rele
 1347              	 .loc 5 269 0 is_stmt 1
 1348 00f0 544B     	 ldr r3,.L73
 1349 00f2 0122     	 mov r2,#1
 1350 00f4 5242     	 neg r2,r2
 1351 00f6 1A60     	 str r2,[r3]
 270:../main.c     **** 		buttonpress_usb = BTNPRESS_LONGEST;
 1352              	 .loc 5 270 0
 1353 00f8 5A4B     	 ldr r3,.L73+32
 1354 00fa 0322     	 mov r2,#3
 1355 00fc 1A70     	 strb r2,[r3]
 1356              	.L62:
 271:../main.c     **** 	}
 272:../main.c     **** 
 273:../main.c     **** 	// UP BUTTON: If a press in ongoing and release is detected, calculate time difference
 274:../main.c     **** 	if(button_up_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_OFF){
 1357              	 .loc 5 274 0
 1358 00fe 534B     	 ldr r3,.L73+8
 1359 0100 1B68     	 ldr r3,[r3]
 1360 0102 002B     	 cmp r3,#0
 1361 0104 33D0     	 beq .L63
 1362              	 .loc 5 274 0 is_stmt 0 discriminator 1
 1363 0106 524B     	 ldr r3,.L73+12
 1364 0108 181C     	 mov r0,r3
 1365 010a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1366 010e 031E     	 sub r3,r0,#0
 1367 0110 012B     	 cmp r3,#1
 1368 0112 2CD1     	 bne .L63
 275:../main.c     **** 		button_up_pressed_duration = (SYSTIMER_GetTime() - button_up_pressed_timestamp) / 1000; // conver
 1369              	 .loc 5 275 0 is_stmt 1
 1370 0114 FFF7FEFF 	 bl SYSTIMER_GetTime
 1371 0118 021C     	 mov r2,r0
 1372 011a 4C4B     	 ldr r3,.L73+8
 1373 011c 1B68     	 ldr r3,[r3]
 1374 011e D31A     	 sub r3,r2,r3
 1375 0120 181C     	 mov r0,r3
 1376 0122 FA23     	 mov r3,#250
 1377 0124 9900     	 lsl r1,r3,#2
 1378 0126 FFF7FEFF 	 bl __aeabi_uidiv
 1379 012a 031C     	 mov r3,r0
 1380 012c 9AB2     	 uxth r2,r3
 1381 012e 504B     	 ldr r3,.L73+44
 1382 0130 1A80     	 strh r2,[r3]
 276:../main.c     **** 		button_up_pressed_timestamp = 0;
 1383              	 .loc 5 276 0
 1384 0132 464B     	 ldr r3,.L73+8
 1385 0134 0022     	 mov r2,#0
 1386 0136 1A60     	 str r2,[r3]
 277:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 278:../main.c     **** 		if(button_up_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1387              	 .loc 5 278 0
 1388 0138 4D4B     	 ldr r3,.L73+44
 1389 013a 1B88     	 ldrh r3,[r3]
 1390 013c 484A     	 ldr r2,.L73+28
 1391 013e 9342     	 cmp r3,r2
 1392 0140 03D9     	 bls .L64
 279:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1393              	 .loc 5 279 0
 1394 0142 4C4B     	 ldr r3,.L73+48
 1395 0144 0022     	 mov r2,#0
 1396 0146 1A70     	 strb r2,[r3]
 1397 0148 10E0     	 b .L65
 1398              	.L64:
 280:../main.c     **** 		else if(button_up_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1399              	 .loc 5 280 0
 1400 014a 494B     	 ldr r3,.L73+44
 1401 014c 1B88     	 ldrh r3,[r3]
 1402 014e 464A     	 ldr r2,.L73+36
 1403 0150 9342     	 cmp r3,r2
 1404 0152 03D9     	 bls .L66
 281:../main.c     **** 			buttonpress_up = BTNPRESS_LONG;
 1405              	 .loc 5 281 0
 1406 0154 474B     	 ldr r3,.L73+48
 1407 0156 0222     	 mov r2,#2
 1408 0158 1A70     	 strb r2,[r3]
 1409 015a 07E0     	 b .L65
 1410              	.L66:
 282:../main.c     **** 		else if(button_up_pressed_duration >= BTN_STD_PRESS_DURATION)
 1411              	 .loc 5 282 0
 1412 015c 444B     	 ldr r3,.L73+44
 1413 015e 1B88     	 ldrh r3,[r3]
 1414 0160 3B2B     	 cmp r3,#59
 1415 0162 03D9     	 bls .L65
 283:../main.c     **** 			buttonpress_up = BTNPRESS_STD;
 1416              	 .loc 5 283 0
 1417 0164 434B     	 ldr r3,.L73+48
 1418 0166 0122     	 mov r2,#1
 1419 0168 1A70     	 strb r2,[r3]
 278:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1420              	 .loc 5 278 0
 1421 016a 18E0     	 b .L67
 1422              	.L65:
 1423 016c 17E0     	 b .L67
 1424              	.L63:
 284:../main.c     **** 
 285:../main.c     **** 	}
 286:../main.c     **** 	// UP BUTTON: If press is to long reset (simulate that press ended)
 287:../main.c     **** 	else if(button_up_pressed_timestamp != 0 && button_up_pressed_timestamp != TIMESTAMP_DEACTIVATED &
 1425              	 .loc 5 287 0
 1426 016e 374B     	 ldr r3,.L73+8
 1427 0170 1B68     	 ldr r3,[r3]
 1428 0172 002B     	 cmp r3,#0
 1429 0174 13D0     	 beq .L67
 1430              	 .loc 5 287 0 is_stmt 0 discriminator 1
 1431 0176 354B     	 ldr r3,.L73+8
 1432 0178 1B68     	 ldr r3,[r3]
 1433 017a 0133     	 add r3,r3,#1
 1434 017c 0FD0     	 beq .L67
 1435              	 .loc 5 287 0 discriminator 2
 1436 017e FFF7FEFF 	 bl SYSTIMER_GetTime
 1437 0182 021C     	 mov r2,r0
 1438 0184 314B     	 ldr r3,.L73+8
 1439 0186 1B68     	 ldr r3,[r3]
 1440 0188 D31A     	 sub r3,r2,r3
 1441 018a 384A     	 ldr r2,.L73+40
 1442 018c 9342     	 cmp r3,r2
 1443 018e 06D9     	 bls .L67
 288:../main.c     **** 		button_up_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 1444              	 .loc 5 288 0 is_stmt 1
 1445 0190 2E4B     	 ldr r3,.L73+8
 1446 0192 0122     	 mov r2,#1
 1447 0194 5242     	 neg r2,r2
 1448 0196 1A60     	 str r2,[r3]
 289:../main.c     **** 		buttonpress_up = BTNPRESS_LONGEST;
 1449              	 .loc 5 289 0
 1450 0198 364B     	 ldr r3,.L73+48
 1451 019a 0322     	 mov r2,#3
 1452 019c 1A70     	 strb r2,[r3]
 1453              	.L67:
 290:../main.c     **** 	}
 291:../main.c     **** 
 292:../main.c     **** 	// DOWN BUTTON: If a press in ongoing and release is detected, calculate time difference
 293:../main.c     **** 	if(button_down_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_OFF){
 1454              	 .loc 5 293 0
 1455 019e 2D4B     	 ldr r3,.L73+16
 1456 01a0 1B68     	 ldr r3,[r3]
 1457 01a2 002B     	 cmp r3,#0
 1458 01a4 33D0     	 beq .L68
 1459              	 .loc 5 293 0 is_stmt 0 discriminator 1
 1460 01a6 2C4B     	 ldr r3,.L73+20
 1461 01a8 181C     	 mov r0,r3
 1462 01aa FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1463 01ae 031E     	 sub r3,r0,#0
 1464 01b0 012B     	 cmp r3,#1
 1465 01b2 2CD1     	 bne .L68
 294:../main.c     **** 		button_down_pressed_duration = (SYSTIMER_GetTime() - button_down_pressed_timestamp) / 1000; // co
 1466              	 .loc 5 294 0 is_stmt 1
 1467 01b4 FFF7FEFF 	 bl SYSTIMER_GetTime
 1468 01b8 021C     	 mov r2,r0
 1469 01ba 264B     	 ldr r3,.L73+16
 1470 01bc 1B68     	 ldr r3,[r3]
 1471 01be D31A     	 sub r3,r2,r3
 1472 01c0 181C     	 mov r0,r3
 1473 01c2 FA23     	 mov r3,#250
 1474 01c4 9900     	 lsl r1,r3,#2
 1475 01c6 FFF7FEFF 	 bl __aeabi_uidiv
 1476 01ca 031C     	 mov r3,r0
 1477 01cc 9AB2     	 uxth r2,r3
 1478 01ce 2A4B     	 ldr r3,.L73+52
 1479 01d0 1A80     	 strh r2,[r3]
 295:../main.c     **** 		button_down_pressed_timestamp = 0;
 1480              	 .loc 5 295 0
 1481 01d2 204B     	 ldr r3,.L73+16
 1482 01d4 0022     	 mov r2,#0
 1483 01d6 1A60     	 str r2,[r3]
 296:../main.c     **** 		// Interpret button press and activate "button pressed" marker. The code that is reacting to it m
 297:../main.c     **** 		if(button_down_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1484              	 .loc 5 297 0
 1485 01d8 274B     	 ldr r3,.L73+52
 1486 01da 1B88     	 ldrh r3,[r3]
 1487 01dc 204A     	 ldr r2,.L73+28
 1488 01de 9342     	 cmp r3,r2
 1489 01e0 03D9     	 bls .L69
 298:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 1490              	 .loc 5 298 0
 1491 01e2 264B     	 ldr r3,.L73+56
 1492 01e4 0022     	 mov r2,#0
 1493 01e6 1A70     	 strb r2,[r3]
 1494 01e8 10E0     	 b .L70
 1495              	.L69:
 299:../main.c     **** 		else if(button_down_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1496              	 .loc 5 299 0
 1497 01ea 234B     	 ldr r3,.L73+52
 1498 01ec 1B88     	 ldrh r3,[r3]
 1499 01ee 1E4A     	 ldr r2,.L73+36
 1500 01f0 9342     	 cmp r3,r2
 1501 01f2 03D9     	 bls .L71
 300:../main.c     **** 			buttonpress_down = BTNPRESS_LONG;
 1502              	 .loc 5 300 0
 1503 01f4 214B     	 ldr r3,.L73+56
 1504 01f6 0222     	 mov r2,#2
 1505 01f8 1A70     	 strb r2,[r3]
 1506 01fa 07E0     	 b .L70
 1507              	.L71:
 301:../main.c     **** 		else if(button_down_pressed_duration >= BTN_STD_PRESS_DURATION)
 1508              	 .loc 5 301 0
 1509 01fc 1E4B     	 ldr r3,.L73+52
 1510 01fe 1B88     	 ldrh r3,[r3]
 1511 0200 3B2B     	 cmp r3,#59
 1512 0202 03D9     	 bls .L70
 302:../main.c     **** 			buttonpress_down = BTNPRESS_STD;
 1513              	 .loc 5 302 0
 1514 0204 1D4B     	 ldr r3,.L73+56
 1515 0206 0122     	 mov r2,#1
 1516 0208 1A70     	 strb r2,[r3]
 297:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 1517              	 .loc 5 297 0
 1518 020a 18E0     	 b .L54
 1519              	.L70:
 1520 020c 17E0     	 b .L54
 1521              	.L68:
 303:../main.c     **** 	}
 304:../main.c     **** 	// DOWN BUTTON: If press is to long reset (simulate that press ended)
 305:../main.c     **** 	else if(button_down_pressed_timestamp != 0 && button_down_pressed_timestamp != TIMESTAMP_DEACTIVAT
 1522              	 .loc 5 305 0
 1523 020e 114B     	 ldr r3,.L73+16
 1524 0210 1B68     	 ldr r3,[r3]
 1525 0212 002B     	 cmp r3,#0
 1526 0214 13D0     	 beq .L54
 1527              	 .loc 5 305 0 is_stmt 0 discriminator 1
 1528 0216 0F4B     	 ldr r3,.L73+16
 1529 0218 1B68     	 ldr r3,[r3]
 1530 021a 0133     	 add r3,r3,#1
 1531 021c 0FD0     	 beq .L54
 1532              	 .loc 5 305 0 discriminator 2
 1533 021e FFF7FEFF 	 bl SYSTIMER_GetTime
 1534 0222 021C     	 mov r2,r0
 1535 0224 0B4B     	 ldr r3,.L73+16
 1536 0226 1B68     	 ldr r3,[r3]
 1537 0228 D31A     	 sub r3,r2,r3
 1538 022a 104A     	 ldr r2,.L73+40
 1539 022c 9342     	 cmp r3,r2
 1540 022e 06D9     	 bls .L54
 306:../main.c     **** 		button_down_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 1541              	 .loc 5 306 0 is_stmt 1
 1542 0230 084B     	 ldr r3,.L73+16
 1543 0232 0122     	 mov r2,#1
 1544 0234 5242     	 neg r2,r2
 1545 0236 1A60     	 str r2,[r3]
 307:../main.c     **** 		buttonpress_down = BTNPRESS_LONGEST;
 1546              	 .loc 5 307 0
 1547 0238 104B     	 ldr r3,.L73+56
 1548 023a 0322     	 mov r2,#3
 1549 023c 1A70     	 strb r2,[r3]
 1550              	.L54:
 308:../main.c     **** 	}
 309:../main.c     **** }
 1551              	 .loc 5 309 0
 1552 023e BD46     	 mov sp,r7
 1553              	 
 1554 0240 80BD     	 pop {r7,pc}
 1555              	.L74:
 1556 0242 C046     	 .align 2
 1557              	.L73:
 1558 0244 00000000 	 .word button_usb_pressed_timestamp
 1559 0248 00000000 	 .word IO_SW_USB
 1560 024c 00000000 	 .word button_up_pressed_timestamp
 1561 0250 00000000 	 .word IO_SW_UP
 1562 0254 00000000 	 .word button_down_pressed_timestamp
 1563 0258 00000000 	 .word IO_SW_DOWN
 1564 025c 00000000 	 .word button_usb_pressed_duration
 1565 0260 9F0F0000 	 .word 3999
 1566 0264 00000000 	 .word buttonpress_usb
 1567 0268 E7030000 	 .word 999
 1568 026c E70C3D00 	 .word 4000999
 1569 0270 00000000 	 .word button_up_pressed_duration
 1570 0274 00000000 	 .word buttonpress_up
 1571 0278 00000000 	 .word button_down_pressed_duration
 1572 027c 00000000 	 .word buttonpress_down
 1573              	 .cfi_endproc
 1574              	.LFE156:
 1576              	 .section .text.main,"ax",%progbits
 1577              	 .align 2
 1578              	 .global main
 1579              	 .code 16
 1580              	 .thumb_func
 1582              	main:
 1583              	.LFB157:
 310:../main.c     **** 
 311:../main.c     **** //****************************************************************************
 312:../main.c     **** // main - primary loop function
 313:../main.c     **** //****************************************************************************
 314:../main.c     **** int main(void)
 315:../main.c     **** {
 1584              	 .loc 5 315 0
 1585              	 .cfi_startproc
 1586 0000 90B5     	 push {r4,r7,lr}
 1587              	.LCFI34:
 1588              	 .cfi_def_cfa_offset 12
 1589              	 .cfi_offset 4,-12
 1590              	 .cfi_offset 7,-8
 1591              	 .cfi_offset 14,-4
 1592 0002 85B0     	 sub sp,sp,#20
 1593              	.LCFI35:
 1594              	 .cfi_def_cfa_offset 32
 1595 0004 00AF     	 add r7,sp,#0
 1596              	.LCFI36:
 1597              	 .cfi_def_cfa_register 7
 316:../main.c     **** 	// Initialization of DAVE APPs
 317:../main.c     **** 	DAVE_STATUS_t status;
 318:../main.c     **** 	status = DAVE_Init();
 1598              	 .loc 5 318 0
 1599 0006 0B23     	 mov r3,#11
 1600 0008 FC18     	 add r4,r7,r3
 1601 000a FFF7FEFF 	 bl DAVE_Init
 1602 000e 031C     	 mov r3,r0
 1603 0010 2370     	 strb r3,[r4]
 319:../main.c     **** 
 320:../main.c     **** 	// Error routine
 321:../main.c     **** 	if (status != DAVE_STATUS_SUCCESS) {
 1604              	 .loc 5 321 0
 1605 0012 0B23     	 mov r3,#11
 1606 0014 FB18     	 add r3,r7,r3
 1607 0016 1B78     	 ldrb r3,[r3]
 1608 0018 002B     	 cmp r3,#0
 1609 001a 00D0     	 beq .L76
 1610              	.L77:
 322:../main.c     **** 		while(1U){
 323:../main.c     **** 		}
 1611              	 .loc 5 323 0 discriminator 1
 1612 001c FEE7     	 b .L77
 1613              	.L76:
 324:../main.c     **** 	}
 325:../main.c     **** 
 326:../main.c     **** 	/// - Set initial state -
 327:../main.c     **** 	// Enable USB chip and switch to USB1
 328:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USB_SI);
 1614              	 .loc 5 328 0
 1615 001e C44B     	 ldr r3,.L126
 1616 0020 181C     	 mov r0,r3
 1617 0022 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 329:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USB_OE);
 1618              	 .loc 5 329 0
 1619 0026 C34B     	 ldr r3,.L126+4
 1620 0028 181C     	 mov r0,r3
 1621 002a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 330:../main.c     **** 	// Enable USB1
 331:../main.c     **** 	DIGITAL_IO_SetOutputHigh(&IO_USBPWR_1);
 1622              	 .loc 5 331 0
 1623 002e C24B     	 ldr r3,.L126+8
 1624 0030 181C     	 mov r0,r3
 1625 0032 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 332:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 1626              	 .loc 5 332 0
 1627 0036 C14B     	 ldr r3,.L126+12
 1628 0038 181C     	 mov r0,r3
 1629 003a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 333:../main.c     **** 	// Disable USB2
 334:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USBPWR_2);
 1630              	 .loc 5 334 0
 1631 003e C04B     	 ldr r3,.L126+16
 1632 0040 181C     	 mov r0,r3
 1633 0042 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 335:../main.c     **** 	DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 1634              	 .loc 5 335 0
 1635 0046 BF4B     	 ldr r3,.L126+20
 1636 0048 181C     	 mov r0,r3
 1637 004a FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 336:../main.c     **** 	// Disable Relay and set LED off
 337:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_RELAY);
 1638              	 .loc 5 337 0
 1639 004e BE4B     	 ldr r3,.L126+24
 1640 0050 181C     	 mov r0,r3
 1641 0052 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 338:../main.c     **** 	PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1642              	 .loc 5 338 0
 1643 0056 BD4B     	 ldr r3,.L126+28
 1644 0058 BD4A     	 ldr r2,.L126+32
 1645 005a 181C     	 mov r0,r3
 1646 005c 111C     	 mov r1,r2
 1647 005e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 339:../main.c     **** 	// Initialize next value conversion
 340:../main.c     **** 	ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 1648              	 .loc 5 340 0
 1649 0062 BC4B     	 ldr r3,.L126+36
 1650 0064 181C     	 mov r0,r3
 1651 0066 FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 341:../main.c     **** 
 342:../main.c     **** 	int main_loop_count = 0;
 1652              	 .loc 5 342 0
 1653 006a 0023     	 mov r3,#0
 1654 006c FB60     	 str r3,[r7,#12]
 1655              	.L122:
 343:../main.c     **** 
 344:../main.c     **** 	// Main loop
 345:../main.c     **** 	while(1U)
 346:../main.c     **** 	{
 347:../main.c     **** 		// - Status LED handling -
 348:../main.c     **** 		manage_status_led();
 1656              	 .loc 5 348 0
 1657 006e FFF7FEFF 	 bl manage_status_led
 349:../main.c     **** 		main_loop_count++;
 1658              	 .loc 5 349 0
 1659 0072 FB68     	 ldr r3,[r7,#12]
 1660 0074 0133     	 add r3,r3,#1
 1661 0076 FB60     	 str r3,[r7,#12]
 350:../main.c     **** 		systime_debug = SYSTIMER_GetTime();
 1662              	 .loc 5 350 0
 1663 0078 FFF7FEFF 	 bl SYSTIMER_GetTime
 1664 007c 031C     	 mov r3,r0
 1665 007e 1A1C     	 mov r2,r3
 1666 0080 B54B     	 ldr r3,.L126+40
 1667 0082 1A60     	 str r2,[r3]
 351:../main.c     **** 
 352:../main.c     **** 		//// - Button handling -
 353:../main.c     **** 		manage_buttons();
 1668              	 .loc 5 353 0
 1669 0084 FFF7FEFF 	 bl manage_buttons
 354:../main.c     **** 
 355:../main.c     **** 		/// - USB Channel handling -
 356:../main.c     **** 		switch (USB_state){
 1670              	 .loc 5 356 0
 1671 0088 B44B     	 ldr r3,.L126+44
 1672 008a 1B78     	 ldrb r3,[r3]
 1673 008c 012B     	 cmp r3,#1
 1674 008e 23D0     	 beq .L79
 1675 0090 022B     	 cmp r3,#2
 1676 0092 41D0     	 beq .L123
 1677 0094 002B     	 cmp r3,#0
 1678 0096 40D1     	 bne .L78
 357:../main.c     **** 			case USB_1_active:
 358:../main.c     **** 				// State code - none atm
 359:../main.c     **** 
 360:../main.c     **** 				// Transition statement
 361:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 1679              	 .loc 5 361 0
 1680 0098 B14B     	 ldr r3,.L126+48
 1681 009a 1B78     	 ldrb r3,[r3]
 1682 009c 012B     	 cmp r3,#1
 1683 009e 1AD1     	 bne .L82
 362:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USBPWR_1);
 1684              	 .loc 5 362 0
 1685 00a0 A54B     	 ldr r3,.L126+8
 1686 00a2 181C     	 mov r0,r3
 1687 00a4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 363:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USB_SI);
 1688              	 .loc 5 363 0
 1689 00a8 A14B     	 ldr r3,.L126
 1690 00aa 181C     	 mov r0,r3
 1691 00ac FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 364:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_LED_USB2);
 1692              	 .loc 5 364 0
 1693 00b0 A44B     	 ldr r3,.L126+20
 1694 00b2 181C     	 mov r0,r3
 1695 00b4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 365:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_LED_USB1);
 1696              	 .loc 5 365 0
 1697 00b8 A04B     	 ldr r3,.L126+12
 1698 00ba 181C     	 mov r0,r3
 1699 00bc FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 366:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USBPWR_2);
 1700              	 .loc 5 366 0
 1701 00c0 9F4B     	 ldr r3,.L126+16
 1702 00c2 181C     	 mov r0,r3
 1703 00c4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 367:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 1704              	 .loc 5 367 0
 1705 00c8 A54B     	 ldr r3,.L126+48
 1706 00ca 0022     	 mov r2,#0
 1707 00cc 1A70     	 strb r2,[r3]
 368:../main.c     **** 
 369:../main.c     **** 					USB_state = USB_2_active;
 1708              	 .loc 5 369 0
 1709 00ce A34B     	 ldr r3,.L126+44
 1710 00d0 0122     	 mov r2,#1
 1711 00d2 1A70     	 strb r2,[r3]
 370:../main.c     **** 				}
 371:../main.c     **** 				break;
 1712              	 .loc 5 371 0
 1713 00d4 21E0     	 b .L78
 1714              	.L82:
 1715 00d6 20E0     	 b .L78
 1716              	.L79:
 372:../main.c     **** 			case USB_2_active:
 373:../main.c     **** 				// State code - none atm
 374:../main.c     **** 
 375:../main.c     **** 				// Transition statement
 376:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 1717              	 .loc 5 376 0
 1718 00d8 A14B     	 ldr r3,.L126+48
 1719 00da 1B78     	 ldrb r3,[r3]
 1720 00dc 012B     	 cmp r3,#1
 1721 00de 1AD1     	 bne .L83
 377:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USBPWR_2);
 1722              	 .loc 5 377 0
 1723 00e0 974B     	 ldr r3,.L126+16
 1724 00e2 181C     	 mov r0,r3
 1725 00e4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 378:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USB_SI);
 1726              	 .loc 5 378 0
 1727 00e8 914B     	 ldr r3,.L126
 1728 00ea 181C     	 mov r0,r3
 1729 00ec FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 379:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 1730              	 .loc 5 379 0
 1731 00f0 924B     	 ldr r3,.L126+12
 1732 00f2 181C     	 mov r0,r3
 1733 00f4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 380:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 1734              	 .loc 5 380 0
 1735 00f8 924B     	 ldr r3,.L126+20
 1736 00fa 181C     	 mov r0,r3
 1737 00fc FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 381:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USBPWR_1);
 1738              	 .loc 5 381 0
 1739 0100 8D4B     	 ldr r3,.L126+8
 1740 0102 181C     	 mov r0,r3
 1741 0104 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 382:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 1742              	 .loc 5 382 0
 1743 0108 954B     	 ldr r3,.L126+48
 1744 010a 0022     	 mov r2,#0
 1745 010c 1A70     	 strb r2,[r3]
 383:../main.c     **** 
 384:../main.c     **** 					USB_state = USB_1_active;
 1746              	 .loc 5 384 0
 1747 010e 934B     	 ldr r3,.L126+44
 1748 0110 0022     	 mov r2,#0
 1749 0112 1A70     	 strb r2,[r3]
 385:../main.c     **** 				}
 386:../main.c     **** 				break;
 1750              	 .loc 5 386 0
 1751 0114 01E0     	 b .L78
 1752              	.L83:
 1753 0116 00E0     	 b .L78
 1754              	.L123:
 387:../main.c     **** 			case USB_inactive:
 388:../main.c     **** 				// Currently not implemented!
 389:../main.c     **** 				break;
 1755              	 .loc 5 389 0
 1756 0118 C046     	 mov r8,r8
 1757              	.L78:
 390:../main.c     **** 		}
 391:../main.c     **** 
 392:../main.c     **** 		/// - Relay handling -
 393:../main.c     **** 		// Check for state change triggers based on current state
 394:../main.c     **** 		switch (relay_state){
 1758              	 .loc 5 394 0
 1759 011a 924B     	 ldr r3,.L126+52
 1760 011c 1B78     	 ldrb r3,[r3]
 1761 011e 002B     	 cmp r3,#0
 1762 0120 4ED0     	 beq .L85
 1763 0122 012B     	 cmp r3,#1
 1764 0124 00D0     	 beq .LCB1416
 1765 0126 95E0     	 b .L84
 1766              	.LCB1416:
 395:../main.c     **** 			case RELAY_LOW:
 396:../main.c     **** 				// State code
 397:../main.c     **** 				// Check if upper threshold is exceeded. If it is and timestamp is not already set - save times
 398:../main.c     **** 				if     (ADC_val_upper_thres_exceed_timestamp == 0 && ADC_val_current > ADC_upper_threshold){
 1767              	 .loc 5 398 0
 1768 0128 8F4B     	 ldr r3,.L126+56
 1769 012a 1B68     	 ldr r3,[r3]
 1770 012c 002B     	 cmp r3,#0
 1771 012e 0CD1     	 bne .L87
 1772              	 .loc 5 398 0 is_stmt 0 discriminator 1
 1773 0130 8E4B     	 ldr r3,.L126+60
 1774 0132 1B68     	 ldr r3,[r3]
 1775 0134 1A1E     	 sub r2,r3,#0
 1776 0136 8E4B     	 ldr r3,.L126+64
 1777 0138 1B68     	 ldr r3,[r3]
 1778 013a 9A42     	 cmp r2,r3
 1779 013c 05D2     	 bcs .L87
 399:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = SYSTIMER_GetTime();
 1780              	 .loc 5 399 0 is_stmt 1
 1781 013e FFF7FEFF 	 bl SYSTIMER_GetTime
 1782 0142 021C     	 mov r2,r0
 1783 0144 884B     	 ldr r3,.L126+56
 1784 0146 1A60     	 str r2,[r3]
 1785 0148 0DE0     	 b .L88
 1786              	.L87:
 400:../main.c     **** 				}
 401:../main.c     **** 				else if(ADC_val_upper_thres_exceed_timestamp != 0 && ADC_val_current < ADC_upper_threshold){
 1787              	 .loc 5 401 0
 1788 014a 874B     	 ldr r3,.L126+56
 1789 014c 1B68     	 ldr r3,[r3]
 1790 014e 002B     	 cmp r3,#0
 1791 0150 09D0     	 beq .L88
 1792              	 .loc 5 401 0 is_stmt 0 discriminator 1
 1793 0152 864B     	 ldr r3,.L126+60
 1794 0154 1B68     	 ldr r3,[r3]
 1795 0156 1A1E     	 sub r2,r3,#0
 1796 0158 854B     	 ldr r3,.L126+64
 1797 015a 1B68     	 ldr r3,[r3]
 1798 015c 9A42     	 cmp r2,r3
 1799 015e 02D9     	 bls .L88
 402:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = 0;
 1800              	 .loc 5 402 0 is_stmt 1
 1801 0160 814B     	 ldr r3,.L126+56
 1802 0162 0022     	 mov r2,#0
 1803 0164 1A60     	 str r2,[r3]
 1804              	.L88:
 403:../main.c     **** 				}
 404:../main.c     **** 
 405:../main.c     **** 				// Transition statement
 406:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 407:../main.c     **** 				if(ADC_val_upper_thres_exceed_timestamp != 0){
 1805              	 .loc 5 407 0
 1806 0166 804B     	 ldr r3,.L126+56
 1807 0168 1B68     	 ldr r3,[r3]
 1808 016a 002B     	 cmp r3,#0
 1809 016c 27D0     	 beq .L89
 1810              	.LBB2:
 408:../main.c     **** 					uint16_t upperThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_upper_thres_exceed_times
 1811              	 .loc 5 408 0
 1812 016e FFF7FEFF 	 bl SYSTIMER_GetTime
 1813 0172 021C     	 mov r2,r0
 1814 0174 7C4B     	 ldr r3,.L126+56
 1815 0176 1B68     	 ldr r3,[r3]
 1816 0178 D31A     	 sub r3,r2,r3
 1817 017a 181C     	 mov r0,r3
 1818 017c FA23     	 mov r3,#250
 1819 017e 9900     	 lsl r1,r3,#2
 1820 0180 FFF7FEFF 	 bl __aeabi_uidiv
 1821 0184 031C     	 mov r3,r0
 1822 0186 1A1C     	 mov r2,r3
 1823 0188 0823     	 mov r3,#8
 1824 018a FB18     	 add r3,r7,r3
 1825 018c 1A80     	 strh r2,[r3]
 409:../main.c     **** 					if(upperThresholdExceedDuration > relay_threshold_latchtime){
 1826              	 .loc 5 409 0
 1827 018e 794B     	 ldr r3,.L126+68
 1828 0190 1B88     	 ldrh r3,[r3]
 1829 0192 0822     	 mov r2,#8
 1830 0194 BA18     	 add r2,r7,r2
 1831 0196 1288     	 ldrh r2,[r2]
 1832 0198 9A42     	 cmp r2,r3
 1833 019a 10D9     	 bls .L89
 410:../main.c     **** 						relay_state = RELAY_HIGH;
 1834              	 .loc 5 410 0
 1835 019c 714B     	 ldr r3,.L126+52
 1836 019e 0022     	 mov r2,#0
 1837 01a0 1A70     	 strb r2,[r3]
 411:../main.c     **** 						DIGITAL_IO_SetOutputHigh(&IO_RELAY);
 1838              	 .loc 5 411 0
 1839 01a2 694B     	 ldr r3,.L126+24
 1840 01a4 181C     	 mov r0,r3
 1841 01a6 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 412:../main.c     **** 						ADC_val_upper_thres_exceed_timestamp = 0;
 1842              	 .loc 5 412 0
 1843 01aa 6F4B     	 ldr r3,.L126+56
 1844 01ac 0022     	 mov r2,#0
 1845 01ae 1A60     	 str r2,[r3]
 413:../main.c     **** 						if(setup_state == SETUP_IDLE)
 1846              	 .loc 5 413 0
 1847 01b0 714B     	 ldr r3,.L126+72
 1848 01b2 1B78     	 ldrb r3,[r3]
 1849 01b4 002B     	 cmp r3,#0
 1850 01b6 02D1     	 bne .L89
 414:../main.c     **** 							reset_status_led_to_relay_state();
 1851              	 .loc 5 414 0
 1852 01b8 FFF7FEFF 	 bl reset_status_led_to_relay_state
 1853              	.LBE2:
 415:../main.c     **** 					}
 416:../main.c     **** 				}
 417:../main.c     **** 				break;
 1854              	 .loc 5 417 0
 1855 01bc 4AE0     	 b .L84
 1856              	.L89:
 1857 01be 49E0     	 b .L84
 1858              	.L85:
 418:../main.c     **** 			case RELAY_HIGH:
 419:../main.c     **** 				// State code
 420:../main.c     **** 				// Check if lower threshold is exceeded. If it is and timestamp is not already set - save times
 421:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp == 0 && ADC_val_current < ADC_lower_threshold){
 1859              	 .loc 5 421 0
 1860 01c0 6E4B     	 ldr r3,.L126+76
 1861 01c2 1B68     	 ldr r3,[r3]
 1862 01c4 002B     	 cmp r3,#0
 1863 01c6 0CD1     	 bne .L90
 1864              	 .loc 5 421 0 is_stmt 0 discriminator 1
 1865 01c8 6D4B     	 ldr r3,.L126+80
 1866 01ca 1B68     	 ldr r3,[r3]
 1867 01cc 1A1E     	 sub r2,r3,#0
 1868 01ce 684B     	 ldr r3,.L126+64
 1869 01d0 1B68     	 ldr r3,[r3]
 1870 01d2 9A42     	 cmp r2,r3
 1871 01d4 05D9     	 bls .L90
 422:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = SYSTIMER_GetTime();
 1872              	 .loc 5 422 0 is_stmt 1
 1873 01d6 FFF7FEFF 	 bl SYSTIMER_GetTime
 1874 01da 021C     	 mov r2,r0
 1875 01dc 674B     	 ldr r3,.L126+76
 1876 01de 1A60     	 str r2,[r3]
 1877 01e0 0DE0     	 b .L91
 1878              	.L90:
 423:../main.c     **** 				}
 424:../main.c     **** 				else if(ADC_val_lower_thres_exceed_timestamp != 0 && ADC_val_current > ADC_lower_threshold){
 1879              	 .loc 5 424 0
 1880 01e2 664B     	 ldr r3,.L126+76
 1881 01e4 1B68     	 ldr r3,[r3]
 1882 01e6 002B     	 cmp r3,#0
 1883 01e8 09D0     	 beq .L91
 1884              	 .loc 5 424 0 is_stmt 0 discriminator 1
 1885 01ea 654B     	 ldr r3,.L126+80
 1886 01ec 1B68     	 ldr r3,[r3]
 1887 01ee 1A1E     	 sub r2,r3,#0
 1888 01f0 5F4B     	 ldr r3,.L126+64
 1889 01f2 1B68     	 ldr r3,[r3]
 1890 01f4 9A42     	 cmp r2,r3
 1891 01f6 02D2     	 bcs .L91
 425:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = 0;
 1892              	 .loc 5 425 0 is_stmt 1
 1893 01f8 604B     	 ldr r3,.L126+76
 1894 01fa 0022     	 mov r2,#0
 1895 01fc 1A60     	 str r2,[r3]
 1896              	.L91:
 426:../main.c     **** 				}
 427:../main.c     **** 
 428:../main.c     **** 				// Transition statement
 429:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 430:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp != 0){
 1897              	 .loc 5 430 0
 1898 01fe 5F4B     	 ldr r3,.L126+76
 1899 0200 1B68     	 ldr r3,[r3]
 1900 0202 002B     	 cmp r3,#0
 1901 0204 25D0     	 beq .L92
 1902              	.LBB3:
 431:../main.c     **** 					uint16_t lowerThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_lower_thres_exceed_times
 1903              	 .loc 5 431 0
 1904 0206 FFF7FEFF 	 bl SYSTIMER_GetTime
 1905 020a 021C     	 mov r2,r0
 1906 020c 5B4B     	 ldr r3,.L126+76
 1907 020e 1B68     	 ldr r3,[r3]
 1908 0210 D31A     	 sub r3,r2,r3
 1909 0212 181C     	 mov r0,r3
 1910 0214 FA23     	 mov r3,#250
 1911 0216 9900     	 lsl r1,r3,#2
 1912 0218 FFF7FEFF 	 bl __aeabi_uidiv
 1913 021c 031C     	 mov r3,r0
 1914 021e 1A1C     	 mov r2,r3
 1915 0220 BB1D     	 add r3,r7,#6
 1916 0222 1A80     	 strh r2,[r3]
 432:../main.c     **** 					if(lowerThresholdExceedDuration > relay_threshold_latchtime){
 1917              	 .loc 5 432 0
 1918 0224 534B     	 ldr r3,.L126+68
 1919 0226 1B88     	 ldrh r3,[r3]
 1920 0228 BA1D     	 add r2,r7,#6
 1921 022a 1288     	 ldrh r2,[r2]
 1922 022c 9A42     	 cmp r2,r3
 1923 022e 10D9     	 bls .L92
 433:../main.c     **** 						relay_state = RELAY_LOW;
 1924              	 .loc 5 433 0
 1925 0230 4C4B     	 ldr r3,.L126+52
 1926 0232 0122     	 mov r2,#1
 1927 0234 1A70     	 strb r2,[r3]
 434:../main.c     **** 						DIGITAL_IO_SetOutputLow(&IO_RELAY);
 1928              	 .loc 5 434 0
 1929 0236 444B     	 ldr r3,.L126+24
 1930 0238 181C     	 mov r0,r3
 1931 023a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 435:../main.c     **** 						ADC_val_lower_thres_exceed_timestamp = 0;
 1932              	 .loc 5 435 0
 1933 023e 4F4B     	 ldr r3,.L126+76
 1934 0240 0022     	 mov r2,#0
 1935 0242 1A60     	 str r2,[r3]
 436:../main.c     **** 						if(setup_state == SETUP_IDLE)
 1936              	 .loc 5 436 0
 1937 0244 4C4B     	 ldr r3,.L126+72
 1938 0246 1B78     	 ldrb r3,[r3]
 1939 0248 002B     	 cmp r3,#0
 1940 024a 02D1     	 bne .L92
 437:../main.c     **** 							reset_status_led_to_relay_state();
 1941              	 .loc 5 437 0
 1942 024c FFF7FEFF 	 bl reset_status_led_to_relay_state
 1943              	.LBE3:
 438:../main.c     **** 					}
 439:../main.c     **** 				}
 440:../main.c     **** 				break;
 1944              	 .loc 5 440 0
 1945 0250 FFE7     	 b .L124
 1946              	.L92:
 1947              	.L124:
 1948 0252 C046     	 mov r8,r8
 1949              	.L84:
 441:../main.c     **** 		}
 442:../main.c     **** 		// Init next value conversion
 443:../main.c     **** 		ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 1950              	 .loc 5 443 0
 1951 0254 3F4B     	 ldr r3,.L126+36
 1952 0256 181C     	 mov r0,r3
 1953 0258 FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 444:../main.c     **** 
 445:../main.c     **** 		/// - Relay settings handling - Todo auto exit menus after time?, led signal when reaching max?, 
 446:../main.c     **** 		switch(setup_state){
 1954              	 .loc 5 446 0
 1955 025c 464B     	 ldr r3,.L126+72
 1956 025e 1B78     	 ldrb r3,[r3]
 1957 0260 012B     	 cmp r3,#1
 1958 0262 36D0     	 beq .L94
 1959 0264 02DC     	 bgt .L95
 1960 0266 002B     	 cmp r3,#0
 1961 0268 07D0     	 beq .L96
 1962 026a 6EE1     	 b .L93
 1963              	.L95:
 1964 026c 022B     	 cmp r3,#2
 1965 026e 00D1     	 bne .LCB1600
 1966 0270 CEE0     	 b .L97
 1967              	.LCB1600:
 1968 0272 032B     	 cmp r3,#3
 1969 0274 00D1     	 bne .LCB1602
 1970 0276 31E1     	 b .L98
 1971              	.LCB1602:
 1972 0278 67E1     	 b .L93
 1973              	.L96:
 447:../main.c     **** 			case SETUP_IDLE:
 448:../main.c     **** 				/// Interpret button press and change to according setup sub-menu (state)
 449:../main.c     **** 				// A long  press of up or down brings system in time setup menu
 450:../main.c     **** 				// A short press of up         brings system in upper threshold setup menu
 451:../main.c     **** 				// A short press of down       brings system in lower threshold setup menu
 452:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 1974              	 .loc 5 452 0
 1975 027a 424B     	 ldr r3,.L126+84
 1976 027c 1B78     	 ldrb r3,[r3]
 1977 027e 022B     	 cmp r3,#2
 1978 0280 03D0     	 beq .L99
 1979              	 .loc 5 452 0 is_stmt 0 discriminator 1
 1980 0282 414B     	 ldr r3,.L126+88
 1981 0284 1B78     	 ldrb r3,[r3]
 1982 0286 022B     	 cmp r3,#2
 1983 0288 09D1     	 bne .L100
 1984              	.L99:
 453:../main.c     **** 					setup_state = SETUP_TIME_TH;
 1985              	 .loc 5 453 0 is_stmt 1
 1986 028a 3B4B     	 ldr r3,.L126+72
 1987 028c 0322     	 mov r2,#3
 1988 028e 1A70     	 strb r2,[r3]
 454:../main.c     **** 					led_status_pattern = LED_NUMBER;
 1989              	 .loc 5 454 0
 1990 0290 3E4B     	 ldr r3,.L126+92
 1991 0292 0222     	 mov r2,#2
 1992 0294 1A70     	 strb r2,[r3]
 455:../main.c     **** 					led_number = 1;
 1993              	 .loc 5 455 0
 1994 0296 3E4B     	 ldr r3,.L126+96
 1995 0298 0122     	 mov r2,#1
 1996 029a 1A80     	 strh r2,[r3]
 1997 029c 18E0     	 b .L101
 1998              	.L100:
 456:../main.c     **** 				}
 457:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 1999              	 .loc 5 457 0
 2000 029e 394B     	 ldr r3,.L126+84
 2001 02a0 1B78     	 ldrb r3,[r3]
 2002 02a2 012B     	 cmp r3,#1
 2003 02a4 06D1     	 bne .L102
 458:../main.c     **** 					setup_state = SETUP_UPPER_TH;
 2004              	 .loc 5 458 0
 2005 02a6 344B     	 ldr r3,.L126+72
 2006 02a8 0122     	 mov r2,#1
 2007 02aa 1A70     	 strb r2,[r3]
 459:../main.c     **** 					//led_status_pattern = LED_NUMBER;
 460:../main.c     **** 					//led_number = 5;
 461:../main.c     **** 					led_status_pattern = LED_FADE_UP;
 2008              	 .loc 5 461 0
 2009 02ac 374B     	 ldr r3,.L126+92
 2010 02ae 0422     	 mov r2,#4
 2011 02b0 1A70     	 strb r2,[r3]
 2012 02b2 0DE0     	 b .L101
 2013              	.L102:
 462:../main.c     **** 				}
 463:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 2014              	 .loc 5 463 0
 2015 02b4 344B     	 ldr r3,.L126+88
 2016 02b6 1B78     	 ldrb r3,[r3]
 2017 02b8 012B     	 cmp r3,#1
 2018 02ba 09D1     	 bne .L101
 464:../main.c     **** 					setup_state = SETUP_LOWER_TH;
 2019              	 .loc 5 464 0
 2020 02bc 2E4B     	 ldr r3,.L126+72
 2021 02be 0222     	 mov r2,#2
 2022 02c0 1A70     	 strb r2,[r3]
 465:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2023              	 .loc 5 465 0
 2024 02c2 324B     	 ldr r3,.L126+92
 2025 02c4 0222     	 mov r2,#2
 2026 02c6 1A70     	 strb r2,[r3]
 466:../main.c     **** 					led_number = 3;
 2027              	 .loc 5 466 0
 2028 02c8 314B     	 ldr r3,.L126+96
 2029 02ca 0322     	 mov r2,#3
 2030 02cc 1A80     	 strh r2,[r3]
 467:../main.c     **** 					//led_status_pattern = LED_FADE_DOWN;
 468:../main.c     **** 				}
 469:../main.c     **** 				break;
 2031              	 .loc 5 469 0
 2032 02ce 3CE1     	 b .L93
 2033              	.L101:
 2034 02d0 3BE1     	 b .L93
 2035              	.L94:
 470:../main.c     **** 			case SETUP_UPPER_TH:
 471:../main.c     **** 				// Blink relay LED
 472:../main.c     **** 
 473:../main.c     **** 				/// Interpret button press:
 474:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 475:../main.c     **** 				// A short press of up         increases the upper threshold value
 476:../main.c     **** 				// A short press of down       decreases the upper threshold value
 477:../main.c     **** 				// A longest press of up saves the current ADC value as threshold
 478:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2036              	 .loc 5 478 0
 2037 02d2 2C4B     	 ldr r3,.L126+84
 2038 02d4 1B78     	 ldrb r3,[r3]
 2039 02d6 022B     	 cmp r3,#2
 2040 02d8 03D0     	 beq .L103
 2041              	 .loc 5 478 0 is_stmt 0 discriminator 1
 2042 02da 2B4B     	 ldr r3,.L126+88
 2043 02dc 1B78     	 ldrb r3,[r3]
 2044 02de 022B     	 cmp r3,#2
 2045 02e0 06D1     	 bne .L104
 2046              	.L103:
 479:../main.c     **** 					setup_state = SETUP_IDLE;
 2047              	 .loc 5 479 0 is_stmt 1
 2048 02e2 254B     	 ldr r3,.L126+72
 2049 02e4 0022     	 mov r2,#0
 2050 02e6 1A70     	 strb r2,[r3]
 480:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2051              	 .loc 5 480 0
 2052 02e8 284B     	 ldr r3,.L126+92
 2053 02ea 0522     	 mov r2,#5
 2054 02ec 1A70     	 strb r2,[r3]
 2055 02ee 8EE0     	 b .L105
 2056              	.L104:
 481:../main.c     **** 				}
 482:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2057              	 .loc 5 482 0
 2058 02f0 244B     	 ldr r3,.L126+84
 2059 02f2 1B78     	 ldrb r3,[r3]
 2060 02f4 012B     	 cmp r3,#1
 2061 02f6 53D1     	 bne .L106
 483:../main.c     **** 					ADC_upper_threshold += ADC_THRESHOLD_INCREMENT;
 2062              	 .loc 5 483 0
 2063 02f8 1C4B     	 ldr r3,.L126+60
 2064 02fa 1B68     	 ldr r3,[r3]
 2065 02fc 7C33     	 add r3,r3,#124
 2066 02fe 1A1C     	 mov r2,r3
 2067 0300 1A4B     	 ldr r3,.L126+60
 2068 0302 1A60     	 str r2,[r3]
 484:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 485:../main.c     **** 					if(ADC_upper_threshold > ADC_THRESHOLD_MAX){
 2069              	 .loc 5 485 0
 2070 0304 194B     	 ldr r3,.L126+60
 2071 0306 1B68     	 ldr r3,[r3]
 2072 0308 224A     	 ldr r2,.L126+100
 2073 030a 9342     	 cmp r3,r2
 2074 030c 00DC     	 bgt .LCB1697
 2075 030e 7EE0     	 b .L105
 2076              	.LCB1697:
 486:../main.c     **** 						ADC_upper_threshold = ADC_THRESHOLD_MAX;
 2077              	 .loc 5 486 0
 2078 0310 164B     	 ldr r3,.L126+60
 2079 0312 204A     	 ldr r2,.L126+100
 2080 0314 1A60     	 str r2,[r3]
 487:../main.c     **** 						led_number = 2;
 2081              	 .loc 5 487 0
 2082 0316 1E4B     	 ldr r3,.L126+96
 2083 0318 0222     	 mov r2,#2
 2084 031a 1A80     	 strh r2,[r3]
 488:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2085              	 .loc 5 488 0
 2086 031c 1B4B     	 ldr r3,.L126+92
 2087 031e 0222     	 mov r2,#2
 2088 0320 1A70     	 strb r2,[r3]
 489:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2089              	 .loc 5 489 0
 2090 0322 1D4B     	 ldr r3,.L126+104
 2091 0324 0122     	 mov r2,#1
 2092 0326 1A70     	 strb r2,[r3]
 490:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2093              	 .loc 5 490 0
 2094 0328 1C4B     	 ldr r3,.L126+108
 2095 032a 0422     	 mov r2,#4
 2096 032c 1A70     	 strb r2,[r3]
 491:../main.c     **** 					}
 492:../main.c     **** 				}
 493:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 494:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 495:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 496:../main.c     **** 					if(ADC_upper_threshold <= 0){
 497:../main.c     **** 						ADC_upper_threshold = 0;
 498:../main.c     **** 						led_number = 2;
 499:../main.c     **** 						led_status_pattern = LED_NUMBER;
 500:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 501:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 502:../main.c     **** 					}
 503:../main.c     **** 					//if(ADC_upper_threshold <= ADC_lower_threshold)
 504:../main.c     **** 						//ADC_upper_threshold = ADC_lower_threshold;
 505:../main.c     **** 				}
 506:../main.c     **** 				else if(buttonpress_up == BTNPRESS_LONGEST){
 507:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 508:../main.c     **** 					ADC_upper_threshold = ADC_val_current;
 509:../main.c     **** 					setup_state = SETUP_IDLE;
 510:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 511:../main.c     **** 					led_number = 3;
 512:../main.c     **** 					led_status_pattern = LED_NUMBER;
 513:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 514:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 515:../main.c     **** 				}
 516:../main.c     **** 				break;
 2097              	 .loc 5 516 0
 2098 032e 0CE1     	 b .L93
 2099              	.L127:
 2100              	 .align 2
 2101              	.L126:
 2102 0330 00000000 	 .word IO_USB_SI
 2103 0334 00000000 	 .word IO_USB_OE
 2104 0338 00000000 	 .word IO_USBPWR_1
 2105 033c 00000000 	 .word IO_LED_USB1
 2106 0340 00000000 	 .word IO_USBPWR_2
 2107 0344 00000000 	 .word IO_LED_USB2
 2108 0348 00000000 	 .word IO_RELAY
 2109 034c 00000000 	 .word PWM_CCU4_LED_STATUS
 2110 0350 10270000 	 .word 10000
 2111 0354 00000000 	 .word ADC_SENSOR
 2112 0358 00000000 	 .word systime_debug
 2113 035c 00000000 	 .word USB_state
 2114 0360 00000000 	 .word buttonpress_usb
 2115 0364 00000000 	 .word relay_state
 2116 0368 00000000 	 .word ADC_val_upper_thres_exceed_timestamp
 2117 036c 00000000 	 .word ADC_upper_threshold
 2118 0370 00000000 	 .word ADC_val_current
 2119 0374 00000000 	 .word relay_threshold_latchtime
 2120 0378 00000000 	 .word setup_state
 2121 037c 00000000 	 .word ADC_val_lower_thres_exceed_timestamp
 2122 0380 00000000 	 .word ADC_lower_threshold
 2123 0384 00000000 	 .word buttonpress_up
 2124 0388 00000000 	 .word buttonpress_down
 2125 038c 00000000 	 .word led_status_pattern
 2126 0390 00000000 	 .word led_number
 2127 0394 FF0F0000 	 .word 4095
 2128 0398 00000000 	 .word led_pattern_mode
 2129 039c 00000000 	 .word led_status_pattern_after_single
 2130              	.L106:
 493:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 2131              	 .loc 5 493 0
 2132 03a0 6F4B     	 ldr r3,.L128
 2133 03a2 1B78     	 ldrb r3,[r3]
 2134 03a4 012B     	 cmp r3,#1
 2135 03a6 19D1     	 bne .L108
 494:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2136              	 .loc 5 494 0
 2137 03a8 6E4B     	 ldr r3,.L128+4
 2138 03aa 1B68     	 ldr r3,[r3]
 2139 03ac 7C3B     	 sub r3,r3,#124
 2140 03ae 1A1C     	 mov r2,r3
 2141 03b0 6C4B     	 ldr r3,.L128+4
 2142 03b2 1A60     	 str r2,[r3]
 496:../main.c     **** 						ADC_upper_threshold = 0;
 2143              	 .loc 5 496 0
 2144 03b4 6B4B     	 ldr r3,.L128+4
 2145 03b6 1B68     	 ldr r3,[r3]
 2146 03b8 002B     	 cmp r3,#0
 2147 03ba 28DC     	 bgt .L105
 497:../main.c     **** 						led_number = 2;
 2148              	 .loc 5 497 0
 2149 03bc 694B     	 ldr r3,.L128+4
 2150 03be 0022     	 mov r2,#0
 2151 03c0 1A60     	 str r2,[r3]
 498:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2152              	 .loc 5 498 0
 2153 03c2 694B     	 ldr r3,.L128+8
 2154 03c4 0222     	 mov r2,#2
 2155 03c6 1A80     	 strh r2,[r3]
 499:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2156              	 .loc 5 499 0
 2157 03c8 684B     	 ldr r3,.L128+12
 2158 03ca 0222     	 mov r2,#2
 2159 03cc 1A70     	 strb r2,[r3]
 500:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2160              	 .loc 5 500 0
 2161 03ce 684B     	 ldr r3,.L128+16
 2162 03d0 0122     	 mov r2,#1
 2163 03d2 1A70     	 strb r2,[r3]
 501:../main.c     **** 					}
 2164              	 .loc 5 501 0
 2165 03d4 674B     	 ldr r3,.L128+20
 2166 03d6 0422     	 mov r2,#4
 2167 03d8 1A70     	 strb r2,[r3]
 2168              	 .loc 5 516 0
 2169 03da B6E0     	 b .L93
 2170              	.L108:
 506:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 2171              	 .loc 5 506 0
 2172 03dc 664B     	 ldr r3,.L128+24
 2173 03de 1B78     	 ldrb r3,[r3]
 2174 03e0 032B     	 cmp r3,#3
 2175 03e2 14D1     	 bne .L105
 508:../main.c     **** 					setup_state = SETUP_IDLE;
 2176              	 .loc 5 508 0
 2177 03e4 654B     	 ldr r3,.L128+28
 2178 03e6 1B68     	 ldr r3,[r3]
 2179 03e8 1A1C     	 mov r2,r3
 2180 03ea 5E4B     	 ldr r3,.L128+4
 2181 03ec 1A60     	 str r2,[r3]
 509:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2182              	 .loc 5 509 0
 2183 03ee 644B     	 ldr r3,.L128+32
 2184 03f0 0022     	 mov r2,#0
 2185 03f2 1A70     	 strb r2,[r3]
 511:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2186              	 .loc 5 511 0
 2187 03f4 5C4B     	 ldr r3,.L128+8
 2188 03f6 0322     	 mov r2,#3
 2189 03f8 1A80     	 strh r2,[r3]
 512:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 2190              	 .loc 5 512 0
 2191 03fa 5C4B     	 ldr r3,.L128+12
 2192 03fc 0222     	 mov r2,#2
 2193 03fe 1A70     	 strb r2,[r3]
 513:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 2194              	 .loc 5 513 0
 2195 0400 5B4B     	 ldr r3,.L128+16
 2196 0402 0122     	 mov r2,#1
 2197 0404 1A70     	 strb r2,[r3]
 514:../main.c     **** 				}
 2198              	 .loc 5 514 0
 2199 0406 5B4B     	 ldr r3,.L128+20
 2200 0408 0522     	 mov r2,#5
 2201 040a 1A70     	 strb r2,[r3]
 2202              	 .loc 5 516 0
 2203 040c 9DE0     	 b .L93
 2204              	.L105:
 2205              	 .loc 5 516 0 is_stmt 0 discriminator 2
 2206 040e 9CE0     	 b .L93
 2207              	.L97:
 517:../main.c     **** 			case SETUP_LOWER_TH:
 518:../main.c     **** 				// Blink relay LED
 519:../main.c     **** 
 520:../main.c     **** 				/// Interpret button press:
 521:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 522:../main.c     **** 				// A short press of up         increases the lower threshold value
 523:../main.c     **** 				// A short press of down       decreases the lower threshold value
 524:../main.c     **** 				// A longest press of down saves the current ADC value as threshold
 525:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2208              	 .loc 5 525 0 is_stmt 1
 2209 0410 594B     	 ldr r3,.L128+24
 2210 0412 1B78     	 ldrb r3,[r3]
 2211 0414 022B     	 cmp r3,#2
 2212 0416 03D0     	 beq .L110
 2213              	 .loc 5 525 0 is_stmt 0 discriminator 1
 2214 0418 514B     	 ldr r3,.L128
 2215 041a 1B78     	 ldrb r3,[r3]
 2216 041c 022B     	 cmp r3,#2
 2217 041e 06D1     	 bne .L111
 2218              	.L110:
 526:../main.c     **** 					setup_state = SETUP_IDLE;
 2219              	 .loc 5 526 0 is_stmt 1
 2220 0420 574B     	 ldr r3,.L128+32
 2221 0422 0022     	 mov r2,#0
 2222 0424 1A70     	 strb r2,[r3]
 527:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2223              	 .loc 5 527 0
 2224 0426 514B     	 ldr r3,.L128+12
 2225 0428 0522     	 mov r2,#5
 2226 042a 1A70     	 strb r2,[r3]
 2227 042c 55E0     	 b .L112
 2228              	.L111:
 528:../main.c     **** 				}
 529:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2229              	 .loc 5 529 0
 2230 042e 524B     	 ldr r3,.L128+24
 2231 0430 1B78     	 ldrb r3,[r3]
 2232 0432 012B     	 cmp r3,#1
 2233 0434 1AD1     	 bne .L113
 530:../main.c     **** 					ADC_lower_threshold += ADC_THRESHOLD_INCREMENT;
 2234              	 .loc 5 530 0
 2235 0436 534B     	 ldr r3,.L128+36
 2236 0438 1B68     	 ldr r3,[r3]
 2237 043a 7C33     	 add r3,r3,#124
 2238 043c 1A1C     	 mov r2,r3
 2239 043e 514B     	 ldr r3,.L128+36
 2240 0440 1A60     	 str r2,[r3]
 531:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 532:../main.c     **** 					if(ADC_lower_threshold > ADC_THRESHOLD_MAX){
 2241              	 .loc 5 532 0
 2242 0442 504B     	 ldr r3,.L128+36
 2243 0444 1B68     	 ldr r3,[r3]
 2244 0446 504A     	 ldr r2,.L128+40
 2245 0448 9342     	 cmp r3,r2
 2246 044a 46DD     	 ble .L112
 533:../main.c     **** 						ADC_lower_threshold = ADC_THRESHOLD_MAX;
 2247              	 .loc 5 533 0
 2248 044c 4D4B     	 ldr r3,.L128+36
 2249 044e 4E4A     	 ldr r2,.L128+40
 2250 0450 1A60     	 str r2,[r3]
 534:../main.c     **** 						led_number = 2;
 2251              	 .loc 5 534 0
 2252 0452 454B     	 ldr r3,.L128+8
 2253 0454 0222     	 mov r2,#2
 2254 0456 1A80     	 strh r2,[r3]
 535:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2255              	 .loc 5 535 0
 2256 0458 444B     	 ldr r3,.L128+12
 2257 045a 0222     	 mov r2,#2
 2258 045c 1A70     	 strb r2,[r3]
 536:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2259              	 .loc 5 536 0
 2260 045e 444B     	 ldr r3,.L128+16
 2261 0460 0122     	 mov r2,#1
 2262 0462 1A70     	 strb r2,[r3]
 537:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2263              	 .loc 5 537 0
 2264 0464 434B     	 ldr r3,.L128+20
 2265 0466 0322     	 mov r2,#3
 2266 0468 1A70     	 strb r2,[r3]
 538:../main.c     **** 					}
 539:../main.c     **** 				}
 540:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 541:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 542:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 543:../main.c     **** 					if(ADC_lower_threshold <= 0){
 544:../main.c     **** 						ADC_lower_threshold = 0;
 545:../main.c     **** 						led_number = 2;
 546:../main.c     **** 						led_status_pattern = LED_NUMBER;
 547:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 548:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 549:../main.c     **** 					}
 550:../main.c     **** 				}
 551:../main.c     **** 				else if(buttonpress_down == BTNPRESS_LONGEST){
 552:../main.c     **** 					// Save current ADC value as threshold
 553:../main.c     **** 					ADC_lower_threshold = ADC_val_current;
 554:../main.c     **** 					setup_state = SETUP_IDLE;
 555:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 556:../main.c     **** 					led_number = 3;
 557:../main.c     **** 					led_status_pattern = LED_NUMBER;
 558:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 559:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 560:../main.c     **** 				}
 561:../main.c     **** 				break;
 2267              	 .loc 5 561 0
 2268 046a 6EE0     	 b .L93
 2269              	.L113:
 540:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 2270              	 .loc 5 540 0
 2271 046c 3C4B     	 ldr r3,.L128
 2272 046e 1B78     	 ldrb r3,[r3]
 2273 0470 012B     	 cmp r3,#1
 2274 0472 19D1     	 bne .L115
 541:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2275              	 .loc 5 541 0
 2276 0474 434B     	 ldr r3,.L128+36
 2277 0476 1B68     	 ldr r3,[r3]
 2278 0478 7C3B     	 sub r3,r3,#124
 2279 047a 1A1C     	 mov r2,r3
 2280 047c 414B     	 ldr r3,.L128+36
 2281 047e 1A60     	 str r2,[r3]
 543:../main.c     **** 						ADC_lower_threshold = 0;
 2282              	 .loc 5 543 0
 2283 0480 404B     	 ldr r3,.L128+36
 2284 0482 1B68     	 ldr r3,[r3]
 2285 0484 002B     	 cmp r3,#0
 2286 0486 28DC     	 bgt .L112
 544:../main.c     **** 						led_number = 2;
 2287              	 .loc 5 544 0
 2288 0488 3E4B     	 ldr r3,.L128+36
 2289 048a 0022     	 mov r2,#0
 2290 048c 1A60     	 str r2,[r3]
 545:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2291              	 .loc 5 545 0
 2292 048e 364B     	 ldr r3,.L128+8
 2293 0490 0222     	 mov r2,#2
 2294 0492 1A80     	 strh r2,[r3]
 546:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2295              	 .loc 5 546 0
 2296 0494 354B     	 ldr r3,.L128+12
 2297 0496 0222     	 mov r2,#2
 2298 0498 1A70     	 strb r2,[r3]
 547:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2299              	 .loc 5 547 0
 2300 049a 354B     	 ldr r3,.L128+16
 2301 049c 0122     	 mov r2,#1
 2302 049e 1A70     	 strb r2,[r3]
 548:../main.c     **** 					}
 2303              	 .loc 5 548 0
 2304 04a0 344B     	 ldr r3,.L128+20
 2305 04a2 0322     	 mov r2,#3
 2306 04a4 1A70     	 strb r2,[r3]
 2307              	 .loc 5 561 0
 2308 04a6 50E0     	 b .L93
 2309              	.L115:
 551:../main.c     **** 					// Save current ADC value as threshold
 2310              	 .loc 5 551 0
 2311 04a8 2D4B     	 ldr r3,.L128
 2312 04aa 1B78     	 ldrb r3,[r3]
 2313 04ac 032B     	 cmp r3,#3
 2314 04ae 14D1     	 bne .L112
 553:../main.c     **** 					setup_state = SETUP_IDLE;
 2315              	 .loc 5 553 0
 2316 04b0 324B     	 ldr r3,.L128+28
 2317 04b2 1B68     	 ldr r3,[r3]
 2318 04b4 1A1C     	 mov r2,r3
 2319 04b6 334B     	 ldr r3,.L128+36
 2320 04b8 1A60     	 str r2,[r3]
 554:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2321              	 .loc 5 554 0
 2322 04ba 314B     	 ldr r3,.L128+32
 2323 04bc 0022     	 mov r2,#0
 2324 04be 1A70     	 strb r2,[r3]
 556:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2325              	 .loc 5 556 0
 2326 04c0 294B     	 ldr r3,.L128+8
 2327 04c2 0322     	 mov r2,#3
 2328 04c4 1A80     	 strh r2,[r3]
 557:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 2329              	 .loc 5 557 0
 2330 04c6 294B     	 ldr r3,.L128+12
 2331 04c8 0222     	 mov r2,#2
 2332 04ca 1A70     	 strb r2,[r3]
 558:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 2333              	 .loc 5 558 0
 2334 04cc 284B     	 ldr r3,.L128+16
 2335 04ce 0122     	 mov r2,#1
 2336 04d0 1A70     	 strb r2,[r3]
 559:../main.c     **** 				}
 2337              	 .loc 5 559 0
 2338 04d2 284B     	 ldr r3,.L128+20
 2339 04d4 0522     	 mov r2,#5
 2340 04d6 1A70     	 strb r2,[r3]
 2341              	 .loc 5 561 0
 2342 04d8 37E0     	 b .L93
 2343              	.L112:
 2344              	 .loc 5 561 0 is_stmt 0 discriminator 4
 2345 04da 36E0     	 b .L93
 2346              	.L98:
 562:../main.c     **** 			case SETUP_TIME_TH:
 563:../main.c     **** 				/// Interpret button press:
 564:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 565:../main.c     **** 				// A short press of up         increases the threshold exceed time
 566:../main.c     **** 				// A short press of down       decreases the threshold exceed time
 567:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2347              	 .loc 5 567 0 is_stmt 1
 2348 04dc 264B     	 ldr r3,.L128+24
 2349 04de 1B78     	 ldrb r3,[r3]
 2350 04e0 022B     	 cmp r3,#2
 2351 04e2 03D0     	 beq .L117
 2352              	 .loc 5 567 0 is_stmt 0 discriminator 1
 2353 04e4 1E4B     	 ldr r3,.L128
 2354 04e6 1B78     	 ldrb r3,[r3]
 2355 04e8 022B     	 cmp r3,#2
 2356 04ea 06D1     	 bne .L118
 2357              	.L117:
 568:../main.c     **** 					setup_state = SETUP_IDLE;
 2358              	 .loc 5 568 0 is_stmt 1
 2359 04ec 244B     	 ldr r3,.L128+32
 2360 04ee 0022     	 mov r2,#0
 2361 04f0 1A70     	 strb r2,[r3]
 569:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2362              	 .loc 5 569 0
 2363 04f2 1E4B     	 ldr r3,.L128+12
 2364 04f4 0522     	 mov r2,#5
 2365 04f6 1A70     	 strb r2,[r3]
 2366 04f8 26E0     	 b .L119
 2367              	.L118:
 570:../main.c     **** 				}
 571:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 2368              	 .loc 5 571 0
 2369 04fa 1F4B     	 ldr r3,.L128+24
 2370 04fc 1B78     	 ldrb r3,[r3]
 2371 04fe 012B     	 cmp r3,#1
 2372 0500 0FD1     	 bne .L120
 572:../main.c     **** 					relay_threshold_latchtime += RELAY_LATCHTIME_INCREMENT;
 2373              	 .loc 5 572 0
 2374 0502 224B     	 ldr r3,.L128+44
 2375 0504 1B88     	 ldrh r3,[r3]
 2376 0506 F533     	 add r3,r3,#245
 2377 0508 FF33     	 add r3,r3,#255
 2378 050a 9AB2     	 uxth r2,r3
 2379 050c 1F4B     	 ldr r3,.L128+44
 2380 050e 1A80     	 strh r2,[r3]
 573:../main.c     **** 					if(relay_threshold_latchtime > RELAY_LATCHTIME_MAX)
 2381              	 .loc 5 573 0
 2382 0510 1E4B     	 ldr r3,.L128+44
 2383 0512 1B88     	 ldrh r3,[r3]
 2384 0514 1E4A     	 ldr r2,.L128+48
 2385 0516 9342     	 cmp r3,r2
 2386 0518 16D9     	 bls .L119
 574:../main.c     **** 						relay_threshold_latchtime = RELAY_LATCHTIME_MAX;
 2387              	 .loc 5 574 0
 2388 051a 1C4B     	 ldr r3,.L128+44
 2389 051c 1D4A     	 ldr r2,.L128+52
 2390 051e 1A80     	 strh r2,[r3]
 575:../main.c     **** 				}
 576:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 577:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 578:../main.c     **** 					if(relay_threshold_latchtime <= 0)
 579:../main.c     **** 						relay_threshold_latchtime = 0;
 580:../main.c     **** 				}
 581:../main.c     **** 				break;
 2391              	 .loc 5 581 0
 2392 0520 12E0     	 b .L125
 2393              	.L120:
 576:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 2394              	 .loc 5 576 0
 2395 0522 0F4B     	 ldr r3,.L128
 2396 0524 1B78     	 ldrb r3,[r3]
 2397 0526 012B     	 cmp r3,#1
 2398 0528 0ED1     	 bne .L119
 577:../main.c     **** 					if(relay_threshold_latchtime <= 0)
 2399              	 .loc 5 577 0
 2400 052a 184B     	 ldr r3,.L128+44
 2401 052c 1B88     	 ldrh r3,[r3]
 2402 052e F53B     	 sub r3,r3,#245
 2403 0530 FF3B     	 sub r3,r3,#255
 2404 0532 9AB2     	 uxth r2,r3
 2405 0534 154B     	 ldr r3,.L128+44
 2406 0536 1A80     	 strh r2,[r3]
 578:../main.c     **** 						relay_threshold_latchtime = 0;
 2407              	 .loc 5 578 0
 2408 0538 144B     	 ldr r3,.L128+44
 2409 053a 1B88     	 ldrh r3,[r3]
 2410 053c 002B     	 cmp r3,#0
 2411 053e 03D1     	 bne .L119
 579:../main.c     **** 				}
 2412              	 .loc 5 579 0
 2413 0540 124B     	 ldr r3,.L128+44
 2414 0542 0022     	 mov r2,#0
 2415 0544 1A80     	 strh r2,[r3]
 2416              	 .loc 5 581 0
 2417 0546 FFE7     	 b .L125
 2418              	.L119:
 2419              	.L125:
 2420 0548 C046     	 mov r8,r8
 2421              	.L93:
 582:../main.c     **** 		}
 583:../main.c     **** 
 584:../main.c     **** 		// Reset all button presses
 585:../main.c     **** 		buttonpress_usb = BTNPRESS_NOT;
 2422              	 .loc 5 585 0
 2423 054a 134B     	 ldr r3,.L128+56
 2424 054c 0022     	 mov r2,#0
 2425 054e 1A70     	 strb r2,[r3]
 586:../main.c     **** 		buttonpress_up = BTNPRESS_NOT;
 2426              	 .loc 5 586 0
 2427 0550 094B     	 ldr r3,.L128+24
 2428 0552 0022     	 mov r2,#0
 2429 0554 1A70     	 strb r2,[r3]
 587:../main.c     **** 		buttonpress_down = BTNPRESS_NOT;
 2430              	 .loc 5 587 0
 2431 0556 024B     	 ldr r3,.L128
 2432 0558 0022     	 mov r2,#0
 2433 055a 1A70     	 strb r2,[r3]
 588:../main.c     **** 	}
 2434              	 .loc 5 588 0
 2435 055c 87E5     	 b .L122
 2436              	.L129:
 2437 055e C046     	 .align 2
 2438              	.L128:
 2439 0560 00000000 	 .word buttonpress_down
 2440 0564 00000000 	 .word ADC_upper_threshold
 2441 0568 00000000 	 .word led_number
 2442 056c 00000000 	 .word led_status_pattern
 2443 0570 00000000 	 .word led_pattern_mode
 2444 0574 00000000 	 .word led_status_pattern_after_single
 2445 0578 00000000 	 .word buttonpress_up
 2446 057c 00000000 	 .word ADC_val_current
 2447 0580 00000000 	 .word setup_state
 2448 0584 00000000 	 .word ADC_lower_threshold
 2449 0588 FF0F0000 	 .word 4095
 2450 058c 00000000 	 .word relay_threshold_latchtime
 2451 0590 60EA0000 	 .word 60000
 2452 0594 60EAFFFF 	 .word -5536
 2453 0598 00000000 	 .word buttonpress_usb
 2454              	 .cfi_endproc
 2455              	.LFE157:
 2457              	 .global meas_invalid_count
 2458              	 .section .bss.meas_invalid_count,"aw",%nobits
 2459              	 .align 2
 2462              	meas_invalid_count:
 2463 0000 00000000 	 .space 4
 2464              	 .section .text.VADC0_C0_0_IRQHandler,"ax",%progbits
 2465              	 .align 2
 2466              	 .global VADC0_C0_0_IRQHandler
 2467              	 .code 16
 2468              	 .thumb_func
 2470              	VADC0_C0_0_IRQHandler:
 2471              	.LFB158:
 589:../main.c     **** }
 590:../main.c     **** 
 591:../main.c     **** 
 592:../main.c     **** 
 593:../main.c     **** //void Adc_Measurement_Handler()
 594:../main.c     **** //{
 595:../main.c     **** ////	#if(UC_SERIES == XMC11)
 596:../main.c     **** ////		ADC_val_current = ADC_MEASUREMENT_GetGlobalResult();
 597:../main.c     **** ////		ADC_val_current = ADC_val_current >> ((uint32_t)ADC_SENSOR.iclass_config_handle->conversion_m
 598:../main.c     **** ////	#endif
 599:../main.c     **** //}
 600:../main.c     **** 
 601:../main.c     **** int meas_invalid_count = 0;
 602:../main.c     **** 
 603:../main.c     **** void Adc_Measurement_Handler()
 604:../main.c     **** {
 2472              	 .loc 5 604 0
 2473              	 .cfi_startproc
 2474 0000 80B5     	 push {r7,lr}
 2475              	.LCFI37:
 2476              	 .cfi_def_cfa_offset 8
 2477              	 .cfi_offset 7,-8
 2478              	 .cfi_offset 14,-4
 2479 0002 82B0     	 sub sp,sp,#8
 2480              	.LCFI38:
 2481              	 .cfi_def_cfa_offset 16
 2482 0004 00AF     	 add r7,sp,#0
 2483              	.LCFI39:
 2484              	 .cfi_def_cfa_register 7
 605:../main.c     **** 	//uint8_t channel_num;
 606:../main.c     **** 	//uint8_t group_num;
 607:../main.c     **** 	uint32_t adc_register;
 608:../main.c     **** 
 609:../main.c     **** 	#if(UC_SERIES == XMC11)
 610:../main.c     **** 	adc_register = ADC_MEASUREMENT_GetGlobalDetailedResult();
 2485              	 .loc 5 610 0
 2486 0006 FFF7FEFF 	 bl ADC_MEASUREMENT_GetGlobalDetailedResult
 2487 000a 031C     	 mov r3,r0
 2488 000c 7B60     	 str r3,[r7,#4]
 611:../main.c     **** 	#endif
 612:../main.c     **** 
 613:../main.c     **** 	if((bool)(adc_register >> VADC_GLOBRES_VF_Pos))
 2489              	 .loc 5 613 0
 2490 000e 7B68     	 ldr r3,[r7,#4]
 2491 0010 002B     	 cmp r3,#0
 2492 0012 0DDA     	 bge .L131
 614:../main.c     **** 	{
 615:../main.c     **** 		//channel_num = (adc_register & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos;
 616:../main.c     **** 		//group_num = ADC_MEASUREMENT_Channel_A.group_index;
 617:../main.c     **** 		ADC_val_current = (adc_register & VADC_GLOBRES_RESULT_Msk) >> ((uint32_t)(ADC_SENSOR.iclass_confi
 2493              	 .loc 5 617 0
 2494 0014 7B68     	 ldr r3,[r7,#4]
 2495 0016 1B04     	 lsl r3,r3,#16
 2496 0018 1A0C     	 lsr r2,r3,#16
 2497 001a 094B     	 ldr r3,.L133
 2498 001c 9B68     	 ldr r3,[r3,#8]
 2499 001e 5B78     	 ldrb r3,[r3,#1]
 2500 0020 5B07     	 lsl r3,r3,#29
 2501 0022 5B0F     	 lsr r3,r3,#29
 2502 0024 DBB2     	 uxtb r3,r3
 2503 0026 5B00     	 lsl r3,r3,#1
 2504 0028 DA40     	 lsr r2,r2,r3
 2505 002a 064B     	 ldr r3,.L133+4
 2506 002c 1A60     	 str r2,[r3]
 2507 002e 04E0     	 b .L130
 2508              	.L131:
 618:../main.c     **** 	}
 619:../main.c     **** 	else{
 620:../main.c     **** 		meas_invalid_count++;
 2509              	 .loc 5 620 0
 2510 0030 054B     	 ldr r3,.L133+8
 2511 0032 1B68     	 ldr r3,[r3]
 2512 0034 5A1C     	 add r2,r3,#1
 2513 0036 044B     	 ldr r3,.L133+8
 2514 0038 1A60     	 str r2,[r3]
 2515              	.L130:
 621:../main.c     **** 	}
 622:../main.c     **** 
 623:../main.c     **** }
 2516              	 .loc 5 623 0
 2517 003a BD46     	 mov sp,r7
 2518 003c 02B0     	 add sp,sp,#8
 2519              	 
 2520 003e 80BD     	 pop {r7,pc}
 2521              	.L134:
 2522              	 .align 2
 2523              	.L133:
 2524 0040 00000000 	 .word ADC_SENSOR
 2525 0044 00000000 	 .word ADC_val_current
 2526 0048 00000000 	 .word meas_invalid_count
 2527              	 .cfi_endproc
 2528              	.LFE158:
 2530              	 .section .bss.led_pattern_state_timestamp.7000,"aw",%nobits
 2531              	 .align 2
 2534              	led_pattern_state_timestamp.7000:
 2535 0000 00000000 	 .space 4
 2536              	 .section .bss.led_pattern_state_length.7001,"aw",%nobits
 2537              	 .align 1
 2540              	led_pattern_state_length.7001:
 2541 0000 0000     	 .space 2
 2542              	 .section .bss.led_pattern_state.6999,"aw",%nobits
 2543              	 .align 1
 2546              	led_pattern_state.6999:
 2547 0000 0000     	 .space 2
 2548              	 .section .bss.fade_duty_step.7002,"aw",%nobits
 2549              	 .align 1
 2552              	fade_duty_step.7002:
 2553 0000 0000     	 .space 2
 2554              	 .text
 2555              	.Letext0:
 2556              	 .file 6 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2557              	 .file 7 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2558              	 .file 8 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 2559              	 .file 9 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_scu.h"
 2560              	 .file 10 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_ADC/global_adc.h"
 2561              	 .file 11 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_gpio.h"
 2562              	 .file 12 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_ccu4.h"
 2563              	 .file 13 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_CCU4/global_ccu4.h"
 2564              	 .file 14 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4.h"
 2565              	 .file 15 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DAVE.h"
 2566              	 .file 16 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Include/cmsis_gcc.h"
 2567              	 .file 17 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/system_XMC1100.h"
 2568              	 .file 18 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement_extern.h"
 2569              	 .file 19 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io_extern.h"
 2570              	 .file 20 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4_extern.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:18     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 $t
    {standard input}:22     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 XMC_VADC_GLOBAL_GetDetailedResult
    {standard input}:54     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 $t
    {standard input}:58     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 ADC_MEASUREMENT_GetGlobalDetailedResult
    {standard input}:91     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:0000001c $d
    {standard input}:96     .text.XMC_GPIO_SetOutputHigh:00000000 $t
    {standard input}:100    .text.XMC_GPIO_SetOutputHigh:00000000 XMC_GPIO_SetOutputHigh
    {standard input}:136    .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:140    .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:176    .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:180    .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
    {standard input}:218    .text.DIGITAL_IO_SetOutputHigh:00000000 $t
    {standard input}:222    .text.DIGITAL_IO_SetOutputHigh:00000000 DIGITAL_IO_SetOutputHigh
    {standard input}:256    .text.DIGITAL_IO_SetOutputLow:00000000 $t
    {standard input}:260    .text.DIGITAL_IO_SetOutputLow:00000000 DIGITAL_IO_SetOutputLow
    {standard input}:293    .text.DIGITAL_IO_GetInput:00000000 $t
    {standard input}:297    .text.DIGITAL_IO_GetInput:00000000 DIGITAL_IO_GetInput
    {standard input}:336    .data.relay_threshold_latchtime:00000000 relay_threshold_latchtime
    {standard input}:333    .data.relay_threshold_latchtime:00000000 $d
    {standard input}:343    .data.ADC_upper_threshold:00000000 ADC_upper_threshold
    {standard input}:340    .data.ADC_upper_threshold:00000000 $d
    {standard input}:350    .data.ADC_lower_threshold:00000000 ADC_lower_threshold
    {standard input}:347    .data.ADC_lower_threshold:00000000 $d
                            *COM*:00000001 USB_state
                            *COM*:00000001 relay_state
                            *COM*:00000001 setup_state
    {standard input}:359    .bss.led_status_pattern:00000000 led_status_pattern
    {standard input}:360    .bss.led_status_pattern:00000000 $d
    {standard input}:365    .bss.led_status_pattern_last:00000000 led_status_pattern_last
    {standard input}:366    .bss.led_status_pattern_last:00000000 $d
    {standard input}:371    .bss.led_pattern_mode:00000000 led_pattern_mode
    {standard input}:372    .bss.led_pattern_mode:00000000 $d
    {standard input}:377    .bss.led_status_pattern_after_single:00000000 led_status_pattern_after_single
    {standard input}:378    .bss.led_status_pattern_after_single:00000000 $d
    {standard input}:384    .bss.led_number:00000000 led_number
    {standard input}:381    .bss.led_number:00000000 $d
    {standard input}:391    .data.led_fadetime:00000000 led_fadetime
    {standard input}:388    .data.led_fadetime:00000000 $d
    {standard input}:398    .data.led_fadesteps:00000000 led_fadesteps
    {standard input}:395    .data.led_fadesteps:00000000 $d
    {standard input}:404    .bss.buttonpress_usb:00000000 buttonpress_usb
    {standard input}:405    .bss.buttonpress_usb:00000000 $d
    {standard input}:410    .bss.buttonpress_up:00000000 buttonpress_up
    {standard input}:411    .bss.buttonpress_up:00000000 $d
    {standard input}:416    .bss.buttonpress_down:00000000 buttonpress_down
    {standard input}:417    .bss.buttonpress_down:00000000 $d
    {standard input}:423    .bss.button_usb_pressed_timestamp:00000000 button_usb_pressed_timestamp
    {standard input}:420    .bss.button_usb_pressed_timestamp:00000000 $d
    {standard input}:430    .bss.button_up_pressed_timestamp:00000000 button_up_pressed_timestamp
    {standard input}:427    .bss.button_up_pressed_timestamp:00000000 $d
    {standard input}:437    .bss.button_down_pressed_timestamp:00000000 button_down_pressed_timestamp
    {standard input}:434    .bss.button_down_pressed_timestamp:00000000 $d
    {standard input}:444    .bss.button_usb_pressed_duration:00000000 button_usb_pressed_duration
    {standard input}:441    .bss.button_usb_pressed_duration:00000000 $d
    {standard input}:451    .bss.button_up_pressed_duration:00000000 button_up_pressed_duration
    {standard input}:448    .bss.button_up_pressed_duration:00000000 $d
    {standard input}:458    .bss.button_down_pressed_duration:00000000 button_down_pressed_duration
    {standard input}:455    .bss.button_down_pressed_duration:00000000 $d
    {standard input}:465    .bss.ADC_val_current:00000000 ADC_val_current
    {standard input}:462    .bss.ADC_val_current:00000000 $d
    {standard input}:472    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 ADC_val_upper_thres_exceed_timestamp
    {standard input}:469    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 $d
    {standard input}:479    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 ADC_val_lower_thres_exceed_timestamp
    {standard input}:476    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 $d
    {standard input}:486    .bss.systime_debug:00000000 systime_debug
    {standard input}:483    .bss.systime_debug:00000000 $d
    {standard input}:489    .text.delay_ms:00000000 $t
    {standard input}:494    .text.delay_ms:00000000 delay_ms
    {standard input}:544    .text.reset_status_led_to_relay_state:00000000 $t
    {standard input}:549    .text.reset_status_led_to_relay_state:00000000 reset_status_led_to_relay_state
    {standard input}:604    .text.reset_status_led_to_relay_state:00000044 $d
    {standard input}:613    .text.manage_status_led:00000000 $t
    {standard input}:618    .text.manage_status_led:00000000 manage_status_led
    {standard input}:652    .rodata.manage_status_led:00000000 $d
    {standard input}:1049   .text.manage_status_led:000002ac $d
    {standard input}:2534   .bss.led_pattern_state_timestamp.7000:00000000 led_pattern_state_timestamp.7000
    {standard input}:2540   .bss.led_pattern_state_length.7001:00000000 led_pattern_state_length.7001
    {standard input}:2546   .bss.led_pattern_state.6999:00000000 led_pattern_state.6999
    {standard input}:2552   .bss.fade_duty_step.7002:00000000 fade_duty_step.7002
    {standard input}:1066   .text.manage_status_led:000002e8 $t
    {standard input}:1178   .text.manage_status_led:000003a8 $d
    {standard input}:1192   .text.manage_buttons:00000000 $t
    {standard input}:1197   .text.manage_buttons:00000000 manage_buttons
    {standard input}:1558   .text.manage_buttons:00000244 $d
    {standard input}:1577   .text.main:00000000 $t
    {standard input}:1582   .text.main:00000000 main
    {standard input}:2102   .text.main:00000330 $d
    {standard input}:2132   .text.main:000003a0 $t
    {standard input}:2439   .text.main:00000560 $d
    {standard input}:2462   .bss.meas_invalid_count:00000000 meas_invalid_count
    {standard input}:2459   .bss.meas_invalid_count:00000000 $d
    {standard input}:2465   .text.VADC0_C0_0_IRQHandler:00000000 $t
    {standard input}:2470   .text.VADC0_C0_0_IRQHandler:00000000 VADC0_C0_0_IRQHandler
    {standard input}:2524   .text.VADC0_C0_0_IRQHandler:00000040 $d
    {standard input}:2531   .bss.led_pattern_state_timestamp.7000:00000000 $d
    {standard input}:2537   .bss.led_pattern_state_length.7001:00000000 $d
    {standard input}:2543   .bss.led_pattern_state.6999:00000000 $d
    {standard input}:2549   .bss.fade_duty_step.7002:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SYSTIMER_GetTime
PWM_CCU4_SetDutyCycle
IO_RELAY
PWM_CCU4_LED_STATUS
__aeabi_uidiv
IO_SW_USB
IO_SW_UP
IO_SW_DOWN
DAVE_Init
ADC_MEASUREMENT_StartConversion
IO_USB_SI
IO_USB_OE
IO_USBPWR_1
IO_LED_USB1
IO_USBPWR_2
IO_LED_USB2
ADC_SENSOR
