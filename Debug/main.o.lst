   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "main.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_VADC_GLOBAL_GetDetailedResult,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	XMC_VADC_GLOBAL_GetDetailedResult:
  23              	.LFB66:
  24              	 .file 1 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_vadc.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @file xmc_vadc.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @date 2019-12-02
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-15:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Initial <br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-20:
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised for XMC1201 device.<br>
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-04-27:
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for SHS.<br>
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added New APIs for trigger edge selection.<BR>
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for Queue flush entries, boundary selection, Boundary node pointer.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised GatingMode APIs and EMUX Control Init API.<BR>
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-20:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-25:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - BFL configuration in channel initialization fixed.
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-07-28:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - CLOCK_GATING_SUPPORTED and PERIPHERAL_RESET_SUPPORTED macros used
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC13 XMC12 and XMC14
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC44 XMC47 and XMC48
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GLOBAL_SetIndividualBoundary
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetIndividualBoundary
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAlias
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetInputClass
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelSetIclass
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetResultAlignment
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetInputClass
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultSubtractionValue
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC4300 device supported
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_TriggerEvent API updated. OR operation removed.
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_ClearEvent API updated. Multiple events triggering on clearing the event i
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Wrong MACRO name defined in xmc_vadc_map.h file corrected for XMC4200/4100 devices.
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       XMC_VADC_G3_SAMPLE renamed to XMC_VADC_G1_SAMPLE
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the analog calibration voltage for XMC1100 to external reference upper supply range.
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the XMC_VADC_GLOBAL_StartupCalibration() for XMC1100.
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-09:
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Optimization of write only registers
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-18:
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_IsConverterReady(): API checks the STEPCFG register for the read
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       SHSCFG SFR.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-06-17:
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New macros added XMC_VADC_SHS_FULL_SET_REG, XMC_VADC_RESULT_PRIORITY_AVAILABLE
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New Enum added XMC_VADC_SHS_GAIN_LEVEL_t and XMC_VADC_SYNCTR_EVAL_t
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs added are:
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncSlaveReadySignal
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetAssertedEvents
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAssertedResultEvents
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultRegPriority
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncReadySignal
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetSyncReadySignal
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetResultRegPriority
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-02-06:
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new functions to remove channels from background request source, XMC_VADC_GLOBAL_Bac
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-06-24:
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new function XMC_VADC_GLOBAL_SHS_SetAnalogReference() for XMC1 family
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-08-14:
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GLOBAL_DETAILED_RESULT_t
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       You can cast the return of XMC_VADC_GLOBAL_GetDetailedResult() to a varible of type XMC_VA
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() to update AREF bitfield correctly
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-03-30:
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Changed XMC_VADC_GROUP_SetChannelAlias() to inline function
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetChannelAlias()
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-12-02:
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fix including files following the convention: angle brackets are used for standard include
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-09-03:
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetPowerMode()
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-11-11:
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() and XMC_VADC_GROUP_SetChannelAlias()
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @endcond
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifndef XMC_VADC_H
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_H
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * HEADER FILES
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_common.h"
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_scu.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_vadc_map.h"
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup XMClib XMC Peripheral Library
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup VADC
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @brief Versatile Analog to Digital Converter (VADC) driver for XMC microcontroller family.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC microcontroller provides a series of analog input channels connected to a cluster of Ana
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Converters using the Successive Approximation Register (SAR) principle to convert analog input v
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * to discrete digital values.
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC1
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC1x is based on Sample & Hold converters, where a cluster contains 2 Sample&Hold units whi
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter.
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter of the ADC cluster can operate independent of the others, controlled by a dedicat
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * registers and triggered by a dedicated group request source. The results of each channel can be 
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * dedicated channel-specific result register or in a group-specific result register.<BR>
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Versatile Analog to Digital Converter module (VADC) of the XMC comprises a set of converter 
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can be operated either independently or via a common request source that emulates a background c
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter block is equipped with a dedicated input multiplexer and dedicated request source
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * which together build separate groups.
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC4
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc4x.png"
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \else
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc1x.png"
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The VADC LLD is split into GLOBAL and GROUP related APIs.<BR>
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GLOBAL: </B><BR>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Global APIs act on the entire ADC module. Configures global configuration registers</LI>
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Allows configuration of the background request source of the VADC.</LI>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The clock related configurations for the VADC module are configured in the Global APIs/</LI>
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Global API names are prefixed by the \b XMC_VADC_GLOBAL_ and they accept ::XMC_VADC_GLOB
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the background request source of the VADC. The APIs which act on the background r
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_Background</LI>
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the sample and hold unit of the VADC. The APIs which act on the SHS related regis
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_SHS_</LI>
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GROUP: </B><BR>
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Group APIs act on a VADC group. Configures the group configuration registers</LI>
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the queue request source of the VADC. The APIs which act on the queue related reg
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Queue</LI>
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the scan request source of the VADC. The APIs which act on the scan related regis
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Scan</LI>
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configuration of the channels of each group are done by the API which have a prefix as
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     \b XMC_VADC_GROUP_Channel.</LI>
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Group API names are prefixed by the \b XMC_VADC_GROUP_ and they accept ::XMC_VADC_GROUP_
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * MACROS
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if ((UC_SERIES == XMC42)||(UC_SERIES == XMC41) || (UC_SERIES == XMC43))
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE           (1U) /*  Defines the availability of group resource in a
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE           (1U) /*  Defines the availability of scan request resour
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE           (1U) /*  Defines the availability of queue request resou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE            (1U) /*  Defines the availability of external multiplexe
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE        (1U) /*  Defines the availability of boundary check supp
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS      (1U) /*  Defines the availability of synchronous request
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS        (2U) /*  Defines the maximum number of groups available 
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT      (1U) /*  Defines the availability of boundary flags in a
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE         (1U) /*  Defines the external multiplexer channel select
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE             (0U) /* Defines the availability of sample and hold modu
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG          (0U) /* Defines the availability of sample and hold modu
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE    (1U) /* Define the availability of a source specific res
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC44 || UC_SERIES == XMC47 || UC_SERIES == XMC48)
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC45)
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC14 || UC_SERIES == XMC13 || UC_SERIES == XMC12)
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (1U) /* Defines the availability of sample and hold module
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (1U) /* Define the availability of a priority for result
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC11)
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (0U) /*  Defines the availability of group resource in a d
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (0U) /*  Defines the availability of scan request resource
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (0U) /*  Defines the availability of queue request resourc
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (0U) /*  Defines the availability of external multiplexer 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (0U) /*  Defines the availability of boundary check suppor
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (0U) /*  Defines the availability of synchronous request s
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_START_UP_CAL_ACTIVE (3U) /*  Defines the need for SHS startup calibration acti
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 devices */
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_CONV_ENABLE_FOR_XMC11   (*(uint32_t*) 0x40010500UL) /*  Defines the additional err
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 device for effective working*/
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_PORTS               (16U) /* Defines the number of hardware ports that can be 
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     as triggers and gating signals */
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_RESULT_REGISTERS    (16U) /* Defines the number of result holding registers pe
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_CHANNELS_PER_GROUP  (8U)  /**< Defines the number of ADC channels per group */
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ENUMS
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef uint16_t XMC_VADC_RESULT_SIZE_t; /**< Type defined the converted result size to unsigned 16
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_GLOBAL_TypeDef XMC_VADC_GLOBAL_t; /**< Type defined the device header file vadc global
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC type*/
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_G_TypeDef XMC_VADC_GROUP_t; /**< Type defined the device header file vadc group regist
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC Group type*/
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef SHS_Type XMC_VADC_GLOBAL_SHS_t; /**< Type defined the sample and hold register structure*/
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the return status after execution of VADC specific API's. Use @ref XMC_VADC_STATUS_t fo
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STATUS
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_SUCCESS = 0,   /**< Returned when the API has been able to fulfill the callers re
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_ERROR          /**< Returned when the API cannot fulfill the request */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STATUS_t;
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various service requests lines. Each group can raise up to 4 service requests indep
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  all groups together have the possibility of raising 4 module wide service requests. Use @ref XM
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SR
 345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR0 = 0, /**< Group specific Service Request-0 */
 347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR1,     /**< Group specific Service Request-1 */
 348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR2,     /**< Group specific Service Request-2 */
 349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR3,     /**< Group specific Service Request-3 */
 350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR0,    /**< Module Wide Common Service Request-0 */
 351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR1,    /**< Module Wide Common Service Request-1 */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR2,    /**< Module Wide Common Service Request-2 */
 353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR3    /**< Module Wide Common Service Request-3 */
 354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SR_t;
 355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the mode of operation of a channel, when an ongoing conversion gets interrupted in betw
 358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_STARTMODE_t for this enumeration.
 359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STARTMODE
 361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_WFS = 0, /**< An ongoing conversion completes without interruption */
 363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CIR,     /**< An ongoing conversion can be interrupted and resumed later*/
 364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CNR     /**< An ongoing conversion can be interrupted and never resumed */
 365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STARTMODE_t;
 366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the edge sensitivity of the trigger signal which can assert a conversion.
 369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_EDGE_t for this enumeration.
 370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_EDGE
 372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_NONE = 0, /**< No external trigger. Conversion request can be asserted by s
 374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_FALLING,  /**< The falling edge of the external trigger can assert conversi
 375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_RISING,   /**< The rising edge of the external trigger can assert conversio
 376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_ANY       /**< Both the edges can assert conversion request */
 377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_EDGE_t;
 378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external trigger input selection possibilities, to assert a conversion. Refer the V
 381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  section of the reference manual for details of peripherals which can be used. Also refer xmc_va
 382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  detailed definitions of the peripherals which can take the control of these enumeration items.
 383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_INPUT_SELECT_t for this enumeration.
 384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_INPUT_SELECT
 386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_A = 0, /**< Trigger select signal A */
 388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_B,     /**< Trigger select signal B */
 389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_C,     /**< Trigger select signal C */
 390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_D,     /**< Trigger select signal D */
 391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_E,     /**< Trigger select signal E */
 392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_F,     /**< Trigger select signal F */
 393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_G,     /**< Trigger select signal G */
 394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_H,     /**< Trigger select signal H */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_I,     /**< Trigger select signal I */
 396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_J,     /**< Trigger select signal J */
 397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_K,     /**< Trigger select signal K */
 398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_L,     /**< Trigger select signal L */
 399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_M,     /**< Trigger select signal M */
 400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_N,     /**< Trigger select signal N */
 401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_O,     /**< Trigger select signal O */
 402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_P      /**< Trigger select signal P */
 403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_INPUT_SELECT_t;
 405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external gating input selection possibilities, to gate the conversion requests. Ref
 408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  interconnects section of the reference manual for details of peripherals which can be used. Als
 409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of t
 410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  items. Use @ref XMC_VADC_GATE_INPUT_SELECT_t for this enumeration.
 411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATE_INPUT_SELECT
 413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_A = 0, /**< Gating select signal A */
 415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_B,     /**< Gating select signal B */
 416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_C,     /**< Gating select signal C */
 417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_D,     /**< Gating select signal D */
 418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_E,     /**< Gating select signal E */
 419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_F,     /**< Gating select signal F */
 420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_G,     /**< Gating select signal G */
 421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_H,     /**< Gating select signal H */
 422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_I,     /**< Gating select signal I */
 423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_J,     /**< Gating select signal J */
 424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_K,     /**< Gating select signal K */
 425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_L,     /**< Gating select signal L */
 426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_M,     /**< Gating select signal M */
 427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_N,     /**< Gating select signal N */
 428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_O,     /**< Gating select signal O */
 429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_P      /**< Gating select signal P */
 430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATE_INPUT_SELECT_t;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the condition for gating the conversion requests. It can be used to set the ENGT field
 435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of ASMR/BSMR/QMR register respectively for auto_scan/background_scan/queue request sources.
 436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_GATEMODE_t for this enumeration.
 437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATEMODE
 439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_BLOCK = 0,  /**< External triggers are permanently blocked */
 441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_IGNORE,     /**< External triggers are unconditionally passed */
 442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVEHIGH, /**< External trigger is passed only if the gate signal is high */
 443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVELOW  /**< External trigger is passed only if the gate signal is low */
 444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATEMODE_t;
 445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion result handling mode. Use @ref XMC_VADC_DMM_t for this enumeration.
 448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_DMM
 450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_REDUCTION_MODE = 0, /**< Standard Data reduction mode*/
 452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_FILTERING_MODE,     /**< Provide option to select Finite Impulse Response Filter (FI
 453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                         Infinite Impulse Response Filter (IIR)*/
 454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_DIFFERENCE_MODE,    /**< Difference mode is selected*/
 455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DMM_t;
 456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the conversion mode. It defines the resolution of conversion. Use XMC_VADC_CONVMODE_t f
 459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CONVMODE
 461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_12BIT       = 0,  /**< Results of conversion are 12bits wide */
 463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_10BIT       = 1,  /**< Results of conversion are 10bits wide */
 464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_8BIT        = 2,  /**< Results of conversion are 8bits wide */
 465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_FASTCOMPARE = 5  /**< Input signal compared with a preset range */
 466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CONVMODE_t;
 467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the output of a fast compare mode. Use @ref XMC_VADC_FAST_COMPARE_t for
 470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  this enumeration.
 471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_FAST_COMPARE
 473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_LOW = 0, /**< Input lower than than programmed reference */
 475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_HIGH,    /**< Input higher than than programmed reference */
 476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_UNKNOWN  /**< Unknown, Conversion probably still ongoing */
 477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_FAST_COMPARE_t;
 478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the type of scan request source to be used. It can choose between auto scan and backgrou
 481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * source methods. Use @ref XMC_VADC_SCAN_TYPE_t for this enumeration.
 482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_TYPE
 484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_GROUPSCAN = 0, /**< Auto scan mode of operation selected. Also called as Group
 486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_BACKGROUND    /**< Background scan mode of operation selected. Also called as 
 487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_TYPE_t;
 488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the behavior of load event for the scan request source. Use @ref XMC_VADC_SCAN_LOAD_t fo
 491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_LOAD
 493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_OVERWRITE = 0, /**< The old set of channels is discarded in favor of the new s
 495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          awaiting conversion */
 496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_COMBINE       /**< The new set of channels are combined with the pending chann
 497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          previous set */
 498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_LOAD_t;
 499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion classes that can be selected for each channel. The enumeration members ho
 502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * global classes. The conversion classes decides the properties of conversion, like resolution, sa
 503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_CHANNEL_CONV_t for this enumeration.
 504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_CONV
 507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 = 0, /**< Conversion property set-0 specific to the group */
 509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS1,     /**< Conversion property set-1 specific to the group */
 510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,    /**< Conversion property set-0, Module wide */
 511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1    /**< Conversion property set-1, Module wide */
 512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONV_t;
 513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the references to boundary values used for limit checking feature. Each of these can be 
 516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * either an upper bound or a lower bound. Use @ref XMC_VADC_CHANNEL_BOUNDARY_t for this enumeratio
 517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY
 520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 = 0, /**< Group specific Boundary-0 value */
 522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1,     /**< Group specific Boundary-1 value */
 523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0,    /**< Module wide Boundary-0 value */
 524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1    /**< Module wide Boundary-1 value */
 525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_t;
 526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the voltage which the capacitor is charged to. Used in Broken wire detection feature. Us
 529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @ref XMC_VADC_CHANNEL_BWDCH_t for this enumeration.
 530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BWDCH
 532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAGND = 0, /**< Capacitor pre-charged to ground*/
 534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAREF     /**< Capacitor pre-charged to reference voltage*/
 535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BWDCH_t;
 536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Defines the criteria for event generation by the channel. Use @ref XMC_VADC_CHANNEL_EVGEN_t fo
 539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_EVGEN
 541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_NEVER     = 0,  /**< No event generated */
 543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_INBOUND   = 1U, /**< Event generated when the result is within the normal 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPHIGH  = 1U, /**< Event generated when the result of fast compare opera
 545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_OUTBOUND  = 2U, /**< Event generated when the result is outside the normal
 546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPLOW   = 2U, /**< Event generated when the result result of fast compar
 547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_ALWAYS    = 3U /**< Event generated always after conversion - unconditiona
 548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_EVGEN_t;
 549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the reference voltage selection for conversion. Use @ref XMC_VADC_CHANNEL_REF_t for this
 552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_REF
 554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_INTREF = 0, /**< Internal VARef */
 556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_ALT_CH0    /**< External voltage available on Channel-0 of the perticular gr
 557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_REF_t;
 558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the criteria for boundary flag assertion. Use @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t
 561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY_CONDITION
 564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND = 0, /**< Set Boundary condition criteria to asser
 566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND     /**< Set Boundary condition criteria to assert
 567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t;
 568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the event which can lead to a global service request assertion. Use @ref XMC_VADC_GLOBAL
 571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_EVENT
 574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE = VADC_GLOBEFLAG_SEVGLB_Msk, /**< Background scan request sourc
 576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_RESULT      = VADC_GLOBEFLAG_REVGLB_Msk  /**< Global result event */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_EVENT_t;
 578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the power modes of a VADC Group. Use @ref XMC_VADC_GROUP_POWERMODE_t for this enumeratio
 581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_POWERMODE
 583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_OFF       = 0, /**< Group is powered down */
 585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED1,     /**< Reserved */
 586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED2,     /**< Reserved */
 587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_NORMAL        /**< Group is powered up */
 588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_POWERMODE_t;
 589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the status of a VADC group (also known as kernel). Use @ref XMC_VADC_GROUP_STATE_t for 
 592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_STATE
 594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_IDLE = 0, /**< Idle and can convert if requested */
 596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_BUSY      /**< Busy with an ongoing conversion */
 597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_STATE_t;
 598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the reference to sample time and conversion mode settings. Use @ref XMC_VADC_GROUP_CONV
 601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_CONV
 604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_STD = 0, /**< Settings pertaining to channels directly attached to VADC modul
 606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_EMUX    /**< Settings pertaining to channels connected to VADC via EMUX */
 607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONV_t;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbiter behavior. Use @ref XMC_VADC_GROUP_ARBMODE_t for this enumera
 611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_ARBMODE
 613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ALWAYS = 0, /**< Arbiter runs all the time */
 615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ONDEMAND    /**< Arbiter runs only if a conversion request is asserted by 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                           request sources */
 617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_ARBMODE_t;
 618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX mode of operation. Use @ref XMC_VADC_GROUP_EMUXMODE_t for this enumeration.
 621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXMODE
 623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SWCTRL = 0,     /**< Perform EMUX in Software control mode*/
 625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_STEADYMODE,     /**< Perform EMUX in Steady mode (Use EMUX set value)*/
 626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SINGLEMODE,     /**< Perform EMUX in Single step mode*/
 627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE,   /**< Perform EMUX in Sequence mode*/
 628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXMODE_t;
 629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX channel selection encoding scheme. Use @ref XMC_VADC_GROUP_EMUXCODE_t for this
 632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXCODE
 634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_BINARY = 0, /**< A linearly incrementing code serves are MUX-SEL */
 636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_GRAY       /**< The MUX-SEL is gray encoded */
 637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCODE_t;
 638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the service request set used. Use @ref XMC_VADC_GROUP_IRQ_t for this enumeration.
 641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_IRQ
 643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_KERNEL = 0, /**< Refers to Group specific service request */
 645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_SHARED     /**< Refers to Module wide service request */
 646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_IRQ_t;
 647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the alignment of the converted result. Use @ref XMC_VADC_RESULT_ALIGN_t for this enumer
 650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_ALIGN
 652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_LEFT = 0,  /**< Always align result to left */
 654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_RIGHT      /**< Always align result to right */
 655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_ALIGN_t;
 656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_SUBTRATION
 658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_LEFT_ALIGN  = 0U,  /**< Always align result to left */
 660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_LEFT_ALIGN  = 2U,  /**< Always align result to left */
 662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_LEFT_ALIGN   = 4U,  /**< Always align result to left */
 664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_RIGHT_ALIGN  = 0U,  /**< Always align result to right */
 665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_SUBTRATION_t;
 666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbitration priority. Use @ref XMC_VADC_GROUP_RS_PRIORITY_t for this
 669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_RS_PRIORITY
 671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_0 = 0, /**< Lowest priority for the request source*/
 673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_1,     /**< Second lowest priority for the request source*/
 674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_2,     /**< Second highest priority for the request source*/
 675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_3,     /**< Highest priority for the request source*/
 676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_RS_PRIORITY_t;
 677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various modes for the boundary flag. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t f
 680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_BOUNDARY_FLAG_MODE
 682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED = 0,       /**< Disable boundary flag*/
 684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED,            /**< Always enable boundary*/
 685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW, /**< Enable boundary flag when gate level i
 686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH /**< Enable boundary flag when gate level i
 687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t;
 688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the boundary select for Channel. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t for this 
 692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_SELECT
 694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_LOWER_BOUND = 0U,       /**< Select the lower boundary*/
 696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_UPPER_BOUND = 2U        /**< Selects the upper boundary*/
 697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_SELECT_t;
 698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the group indices. Use @ref XMC_VADC_GROUP_INDEX_t for this enumeration.
 702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_INDEX
 704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_0   = 0,
 706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_1,
 707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_2,
 709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_3
 710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_INDEX_t;
 712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * Defines channel alias.
 715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * All enum items are available for channels 0 and 1. Other Channels can accept only XMC_VADC_CHANNE
 716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** */
 717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_ALIAS
 718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_DISABLED = -1,
 720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH0 = 0,
 721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH1 = 1,
 722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH2 = 2,
 723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH3 = 3,
 724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH4 = 4,
 725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH5 = 5,
 726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH6 = 6,
 727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH7 = 7
 728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_ALIAS_t;
 729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selection of the reference voltage that is required for conversions (VREF).
 734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_AREF
 736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_EXTERNAL_VDD_UPPER_RANGE = 0 << SHS_SHSCFG_AREF_Pos, /**< External refer
 738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_UPPER_RANGE = 2 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_LOWER_RANGE = 3 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_AREF_t;
 741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the gain calibration selection.
 745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_GAIN_LEVEL
 747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_0 = SHS_CALOC0_CALOFFVAL0_Pos, /**< Select the calibration value for gain
 749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_1 = SHS_CALOC0_CALOFFVAL1_Pos, /**< Select the calibration value for gain
 750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_2 = SHS_CALOC0_CALOFFVAL2_Pos, /**< Select the calibration value for gain
 751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_3 = SHS_CALOC0_CALOFFVAL3_Pos  /**< Select the calibration value for gain
 752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_GAIN_LEVEL_t;
 753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the Delta sigma loop.
 757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_LOOP_CH
 759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_0 = SHS_LOOP_LPCH0_Pos, /**< Select Delta-sigma loop 0*/
 761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_1 = SHS_LOOP_LPCH1_Pos /**< Select Delta-sigma loop 1*/
 762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_LOOP_CH_t;
 763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides the order in which the SHS should do the calibration
 766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER
 768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_POST_CONV = 0, /**< Calibration occur after conversion take
 770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_PRE_CONV   /**< Calibration occur before conversion takes p
 771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t;
 772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides possible routing values for the boundary flag.
 777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_NODE
 779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_0 = 0U, /**<Route the Group boundary flag to Common b
 781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_1,      /**<Route the Group boundary flag to Common b
 782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_2,      /**<Route the Group boundary flag to Common b
 783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_3,      /**<Route the Group boundary flag to Common b
 784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_0,  /**<Route the Group boundary flag to Common Service Req
 785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_1,  /**<Route the Group boundary flag to Common Service Req
 786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_2,  /**<Route the Group boundary flag to Common Service Req
 787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_3   /**<Route the Group boundary flag to Common Service Req
 788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_NODE_t;
 789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 791:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 792:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 793:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the ready signal selection
 794:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 795:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SYNCTR_EVAL
 796:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 797:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_1 = VADC_G_SYNCTR_EVALR1_Msk, /**<Mask to set the EVAL1 bits of SYNCTR */
 798:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 799:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_2 = VADC_G_SYNCTR_EVALR2_Msk, /**<Mask to set the EVAL2 bits of SYNCTR */
 800:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_3 = VADC_G_SYNCTR_EVALR3_Msk  /**<Mask to set the EVAL3 bits of SYNCTR */
 801:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 802:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SYNCTR_EVAL_t;
 803:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 804:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 805:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DATA STRUCTURES
 806:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 807:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard start*/
 808:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
 809:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma push
 810:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma anon_unions
 811:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
 812:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning 586
 813:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 814:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 815:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 816:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC scan request source. Use type @ref XMC_VADC_SCAN_CONFIG_t for t
 817:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 818:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_SCAN_CONFIG
 819:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 820:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 821:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how scan request source would
 822:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 823:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter. If the Conversion s
 824:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          selected as Cancel inject repeat/Never mode then this fiel
 825:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          priority of scan request source. Uses @ref XMC_VADC_GROUP_
 826:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 827:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 828:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 829:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 830:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 831:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Use any one Group related result register as the 
 832:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
 833:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
 834:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 835:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 836:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 837:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 838:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger. U
 839:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_INPUT_SELECT_t enumeration*/
 840:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 841:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal. Uses @ref
 842:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_EDGE_t */
 843:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 844:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating. Us
 845:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_GATE_INPUT_SELECT_t */
 846:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
 847:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Decides whether timer mode for equi-distant sampl
 848:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       activated or not.*/
 849:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
 850:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 851:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asctrl;
 852:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 853:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 854:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 855:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 856:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 857:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 2;
 858:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversions be initiated by external hardware trigger 
 859:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t req_src_interrupt  : 1;  /**< Request source event can be generated after a conversi
 860:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_auto_scan   : 1;  /**< Enables the continuous conversion mode. Conversion com
 861:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  of the last channel in a scan sequence will cause 
 862:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t load_mode          : 1;  /**< Selects load event mode. Uses @ref XMC_VADC_SCAN_LOAD_
 863:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 26;
 864:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 865:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asmr;
 866:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 867:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_CONFIG_t;
 868:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 869:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 870:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef XMC_VADC_SCAN_CONFIG_t XMC_VADC_BACKGROUND_CONFIG_t; /**< Type defined the scan configurati
 871:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                  structure for background Request S
 872:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 873:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 874:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC channel. Use type XMC_VADC_CHANNEL_CONFIG_t for this enumeratio
 875:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 876:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_CHANNEL_CONFIG
 877:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 878:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 879:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 880:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 881:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 882:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t input_class                : 2;  /**< Input conversion class selection.
 883:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_CONV_t */
 884:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 2;
 885:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t lower_boundary_select      : 2;  /**< Which boundary register serves as lower bound?
 886:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 887:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t upper_boundary_select      : 2;  /**< Which boundary register serves as upper bound?
 888:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 889:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_criteria         : 2;  /**< When should an event be generated?
 890:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_EVGEN_t */
 891:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sync_conversion            : 1;  /**< Enables synchronous conversion for the configu
 892:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t alternate_reference        : 1;  /**< Input reference voltage selection either VARef
 893:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_REF_t*/
 894:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 4;
 895:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_reg_number          : 4;  /**< Group result register number */
 896:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t use_global_result          : 1;  /**< Use global result register for background requ
 897:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_alignment           : 1;  /**< Alignment of the results read in the result re
 898:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_RESULT_ALIGN_t */
 899:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 6;
 900:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect_channel : 2;  /**< Source to be used to charge the capacitor for 
 901:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BWDCH_t. */
 902:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect         : 1;  /**< Configures extra phase before the capacitor is
 903:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 904:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t chctr;
 905:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 906:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 907:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 908:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 909:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 910:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 8;
 911:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 912:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch0 : 1; /**< Condition for which the boundary flag should cha
 913:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITIO
 914:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch1 : 1; /**< Condition for which the boundary flag should cha
 915:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 916:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch2 : 1; /**< Condition for which the boundary flag should cha
 917:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 918:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch3 : 1; /**< Condition for which the boundary flag should cha
 919:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 920:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 921:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 922:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 923:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 924:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 925:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch0  : 1; /**< Inverts boundary flag output.*/
 926:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch1  : 1; /**< Inverts boundary flag output.*/
 927:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch2  : 1; /**< Inverts boundary flag output.*/
 928:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch3  : 1; /**< Inverts boundary flag output.*/
 929:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 930:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 931:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch0  : 1; /**< Enable the boundary flag output on the specific 
 932:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch1  : 1; /**< Enable the boundary flag output on the specific 
 933:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch2  : 1; /**< Enable the boundary flag output on the specific 
 934:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch3  : 1; /**< Enable the boundary flag output on the specific 
 935:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 936:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 12;
 937:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 938:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bfl;
 939:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 940:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 941:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 942:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 943:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 944:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 945:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch0    : 4; /**< Specify the basic operation of boundary flag 0
 946:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 947:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch1    : 4; /**< Specify the basic operation of boundary flag 1
 948:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 949:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch2    : 4; /**< Specify the basic operation of boundary flag 2
 950:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 951:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch3    : 4; /**< Specify the basic operation of boundary flag 3
 952:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 953:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 16;
 954:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 955:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bflc;
 956:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 957:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 958:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   bool    channel_priority;  /**< Only non priority channels can be converted by Background Request
 959:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   int8_t  alias_channel;     /**< Specifies the channel which has to be aliased with CH0/CH1 (which
 960:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Force the value to \b(int8_t)-1 to bypass alias feature.
 961:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Uses @ref XMC_VADC_CHANNEL_ALIAS_t  for configuration.*/
 962:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONFIG_t;
 963:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 964:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 965:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize a queue entry. Use type @ref XMC_VADC_QUEUE_ENTRY_t.
 966:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 967:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_ENTRY
 968:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 969:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 970:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 971:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 972:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 973:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_num        : 5;  /**< Channel number associated with this queue entry.<BR>Ra
 974:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t refill_needed      : 1;  /**< Conversion completed channel gets inserted back into t
 975:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t generate_interrupt : 1;  /**< Generates a queue request source event */
 976:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversion requests are raised on an external trigger.
 977:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 24;
 978:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 979:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 980:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qinr0;
 981:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 982:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_ENTRY_t;
 983:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 984:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 985:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing a VADC queue request source. Use type @ref XMC_VADC_QUEUE_CONFIG_t.
 986:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 987:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_CONFIG
 988:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 989:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 990:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how queue request source woul
 991:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 992:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter.Uses @ref XMC_VADC_G
 993:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 994:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 995:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 996:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 997:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 998:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Uses any one Group related result register as the
 999:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
1000:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
1001:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1002:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1003:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1004:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1005:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger.
1006:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_INPUT_SELECT_t */
1007:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1008:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal.
1009:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_EDGE_t */
1010:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1011:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating.
1012:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GATE_INPUT_SELECT_t */
1013:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
1014:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Timer mode for equi-distant sampling shall be act
1015:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
1016:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1017:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qctrl0;
1018:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1019:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1020:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1021:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1022:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1023:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 2;
1024:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger  : 1;  /**< Are external triggers supported? */
1025:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 29;
1026:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1027:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qmr0;
1028:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1029:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_CONFIG_t;
1030:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1031:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1032:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1033:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the global input class configuration. Configured parameters are sample 
1034:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1035:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1036:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLASS
1037:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1038:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1039:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1040:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1041:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1042:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1043:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1044:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1045:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1046:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1047:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1048:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
1049:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1050:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1051:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1052:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1053:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1054:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1055:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1056:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 16;
1057:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1058:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1059:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globiclass;
1060:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1061:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLASS_t;
1062:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1063:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1064:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1065:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize converter and arbiter clock configuration
1066:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1067:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLOCK
1068:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1069:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1070:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1071:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1072:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1073:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1074:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_clock_divider     : 5;  /**< Clock for the converter. <BR>Range: [0x0 to 0x1F
1075:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 2;
1076:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t msb_conversion_clock     : 1;  /**< Additional clock cycle for analog converter */
1077:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_clock_divider    : 2;  /**< Request source arbiter clock divider. <BR>Range:
1078:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 5;
1079:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 17;
1080:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1081:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globcfg;
1082:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1083:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLOCK_t;
1084:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1085:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1086:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1087:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1088:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize the VADC Global functions
1089:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1090:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CONFIG
1091:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1092:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1093:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1094:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1095:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1096:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1097:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1098:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1099:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globbound;
1102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLOCK_t clock_config; /**< ADC clock configurations*/
1105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class0;      /**< ADC input conversion configurations for GLOBICLASS[0]*
1107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class1;      /**< ADC input conversion configurations for GLOBICLASS[1]*
1108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Data reduction stages */
1114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Results of the next conversion will not be overwr
1116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       result register until the previous value is r
1117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 6;
1118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globrcr;
1121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t module_disable              : 1;  /**< Disables the module clock.*/
1127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 2;
1128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t disable_sleep_mode_control  : 1;  /**< Set it to true in order to disable the Sleep 
1129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 28;
1130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t clc;
1132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CONFIG_t;
1134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the group input class configuration. Configured parameters are sample t
1138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CLASS
1141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_iclass0;
1160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CLASS_t;
1162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  EMUX related configuration structure.
1166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_EMUXCFG
1168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t starting_external_channel : 3;  /**< External channel number to which the VADC will
1174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         generate a control signal (needed to select
1175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         the analog multiplexer)*/
1176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 13;
1177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 10; /**< The Channel to which the EMUX is connected. */
1179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 5;  /**< The Channel to which the EMUX is connected. */
1181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 5;
1182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_mode                 : 2;  /**< Selects the external multiplexer modes: Steady,
1184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         Uses @ref XMC_VADC_GROUP_EMUXMODE_t*/
1185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_coding               : 1;  /**< Select Binary or Gray coding. Uses @ref XMC_VAD
1186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t stce_usage                : 1;  /**< Use STCE for each conversion of an external cha
1187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_select_style : 1;  /**< Selects the style of configuring the \b connect
1189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         (Each bit represents the channel or entire 
1190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 1;
1191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 2;
1193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_emuxctr;
1196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCFG_t;
1198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Group Configuration Data Structures
1202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CONFIG
1205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCFG_t emux_config;    /**< External multiplexer related configurations */
1207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class0;           /**< ADC input conversion configurations for GxICLASS[0]
1208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class1;           /**< ADC input conversion configurations for GxICLASS[1]
1209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_bound;
1219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 4;
1225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbitration_round_length : 2;  /**< Number of arbiter slots to be considered */
1226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 1;
1227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_mode             : 1;  /**< Arbiter mode - Select either Continuous mode or 
1228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_ARBMODE_t */
1229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 24;
1230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_arbcfg;
1232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONFIG_t;
1234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize VADC Group result register.
1237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_RESULT_CONFIG
1240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Configures the data reduction stages */
1247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t post_processing_mode    : 2;  /**< Result data processing mode. Uses @ref  XMC_VADC_
1248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       For normal operation select
1249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_DMM_t::XMC_VADC_DMM_REDUCTION_MODE
1250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       and data_reduction_control as 0*/
1251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 2;
1252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Allow the conversion only after previous results 
1253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t part_of_fifo            : 2;  /**< Make the result register a part of Result FIFO? *
1254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_rcr;
1258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_CONFIG_t;
1260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
1262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Structure to initialize the Stepper configurations
1265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_STEP_CONFIG
1267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step0            : 3;  /**< Select a Sample and hold unit for the stepper's 
1273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step0             : 1; /**< Should the step be added to the sequence */
1275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step1            : 3;  /**< Select a Sample and hold unit for the stepper's 
1276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step1             : 1; /**< Should the step be added to the sequence */
1278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step2            : 3;  /**< Select a Sample and hold unit for the stepper's 
1279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step2             : 1; /**< Should the step be added to the sequence */
1281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step3            : 3;  /**< Select a Sample and hold unit for the stepper's 
1282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step3             : 1; /**< Should the step be added to the sequence */
1284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step4            : 3;  /**< Select a Sample and hold unit for the stepper's 
1285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step4             : 1; /**< Should the step be added to the sequence */
1287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step5            : 3;  /**< Select a Sample and hold unit for the stepper's 
1288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step5             : 1; /**< Should the step be added to the sequence */
1290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step6            : 3;  /**< Select a Sample and hold unit for the stepper's 
1291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step6             : 1; /**< Should the step be added to the sequence */
1293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step7            : 3;  /**< Select a Sample and hold unit for the stepper's 
1294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step7             : 1; /**< Should the step be added to the sequence */
1296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t stepcfg;
1299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_STEP_CONFIG_t;
1301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sample and hold Initialization structure
1304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_CONFIG
1306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t shs_clock_divider        : 4; /**< The divider value for the SHS clock. Range: [0x0 
1313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 6;
1314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 10;
1316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_reference_select  : 2; /**< It is possible to different reference voltage for
1318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 20;
1319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t shscfg;
1321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t calibration_order; /**< order in which the calibration sh
1324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CONFIG_t;
1326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed global result structure
1331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_DETAILED_RESULT
1333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t group_number             : 4;  /**< Indicates the group to which the channel_number 
1340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_DETAILED_RESULT_t;
1350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed channel result structure
1353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_DETAILED_RESULT
1355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_counter   : 4;  /**< Results reduction counter value*/
1362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DETAILED_RESULT_t;
1372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard end*/
1375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
1376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma pop
1377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
1378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning restore
1379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * static inline functions
1382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_CHECK_GROUP_PTR(XMC_VADC_GROUP_t *const group_ptr)
1386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS == 4U)
1388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1) || (group_ptr == VADC_G2) || (group_ptr 
1389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1));
1391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * API Prototypes
1396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifdef __cplusplus
1399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** extern "C" {
1400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module.<BR>\n
1409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would ungate the clock to the VADC module (if applicable). Also this API would bring
1410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module out of reset state(if applicable), by asserting the appropriate registers.
1411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_UngatePeripheralClock() and XMC_SCU_RESET_DeassertPeripheral
1412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * if needed. Directly accessed register is  COMPARATOR.ORCCTRL (Refer to the errata for XMC1100).
1413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableModule().
1416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_EnableModule(void);
1418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module.<BR>\n
1426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would gate the clock to the VADC module (if applicable). Also this API would put
1427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module into the reset state(if applicable) by asserting the appropriate registers.
1428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_GatePeripheralClock() and XMC_SCU_RESET_AssertPeripheralRese
1429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModule().
1432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_DisableModule(void);
1434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module.
1438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config Pointer to initialization data structure
1439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC global module with the associated configuration structure pointed by \a con
1444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enables the global access to registers by configuring reset and clock un-gating for selected dev
1445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * initializes global class, boundary , result resources by setting GLOBICLASS,GLOBBOUND,GLOBRCR re
1446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * configures the global analog and digital clock dividers by setting GLOBCFG register. Refer relat
1447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the configurations later in the program.
1448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_ClockInit()<BR>
1451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *conf
1453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module clock.\n\n Call this API before any further configuration of VADC. It se
1462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * register to enable.
1463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Enable:Wrong Module Pointer", (global_ptr == VADC))
1471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_DISR_Msk);
1472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module clock.\n\n After this API call, no conversion will occur. Call
1482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModuleClock() to enable the VADC module later in the program.
1483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Disable:Wrong Module Pointer", (global_ptr == VADC))
1491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_DISR_Pos);
1492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables VADC module to sleep if a sleep request comes.\n\n
1502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * It resets the EDIS bit of CLC register for enabling the sleep mode.
1503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableSleepMode().
1506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_EDIS_Msk);
1511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Ignores the sleep mode request for the VADC.\n\n
1521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * With the sleep feature enabled, the module will respond to sleep
1522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * requests by going into a low power mode. It resets the EDIS bit of CLC register for enabling the
1523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableSleepMode().
1526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_EDIS_Pos);
1531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to the data structure containing clock configuration data
1538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the VADC clock.<BR>\n
1543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the clock configuration of the VADC module using the config structure pointed by \a conf
1544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The clock to the analog converter and to the request source arbiter is configured by setting the
1545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ClockInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_
1551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClockInit:Wrong Module Pointer", (global_ptr == VADC))
1553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Write the Clock configuration into the GLOBCFG register */
1555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG = (uint32_t)(config->globcfg | (VADC_GLOBCFG_DIVWC_Msk));
1556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Conversion class parameter structure
1563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_type configure the input call for either standard conversion or EMUX related convers
1564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param set_num Conversion class set<BR>
1565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                Range: [0x0, 0x1]
1566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the ADC conversion settings like sample time and resolution.<BR>\n
1569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the conversion settings for vadc global resource associated with \a config structure. It
1570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * conversion class properties like sampling time and resolution for selected \a conv_type channels
1571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the GLOBALICLASS register specified by \a set_num with the required settings.
1572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLAS
1580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num);
1581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC global module
1585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to result configuration data structure
1586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes global result register.<BR>\n
1591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes Global Result Register with specified settings configured in the \a config structure
1592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * results in configuration of GLOBRCR register. This helps in configuring the Data reduction mode,
1593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * , wait for read mode on the GLOBRES register.
1594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ResultInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC
1602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ResultInit:Wrong Module Pointer", (global_ptr == VADC))
1604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Configure GLOBRCR*/
1606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBRCR = config->g_rcr;
1607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of G
1617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enable the startup calibration feature. After turning it on, it loops until all active groups fi
1618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call XMC_VADC_GLOBAL_Enable() and XMC_VADC_GLOBAL_ClockInit() before calling this API in sequenc
1619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableStartupCalibration() can disable the calibration feature at runtime.
1620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr);
1627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr  Constant pointer to the VADC module.
1632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of 
1637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * disable the startup calibration feature. Calling the API XMC_VADC_GLOBAL_EnsableStartupCalibrati
1638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * calibration feature at runtime.
1639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableStartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
1645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableStartupCalibration:Wrong Module Pointer", (global_ptr == VADC)
1647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= ~((uint32_t)VADC_GLOBCFG_SUCAL_Msk);
1648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be disabled. <BR>
1655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the post calibration for a particular group specified as \a group_number.\n\n It config
1661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to disable the post calibration feature. Call XMC_VADC_GLOBAL_Enable() and
1662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit() before calling this API in sequence. Calling the API
1663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnablePostCalibration() can enable back the calibration feature at runtime.
1664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, ui
1673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_numbe
1677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be enabled. <BR>
1683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the post calibration for a particular group specified as \a group_number.\n\n It configu
1689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to enable the post calibration feature. Calling the API XMC_VADC_GLOBAL_Disa
1690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can disable the calibration feature at runtime.
1691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uin
1697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= (~ (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_nu
1701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
1705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary0  Boundary-0 Value<BR>Range[0 - 4095]
1709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary1  Boundary-1 Value<BR>Range[0 - 4095]
1710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundaries with \a boundary0 and boundary1 for result comparison.\n\n These two bou
1715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * absolute boundaries. They define a range against which the result of a conversion can be compare
1716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any c
1717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * values entered here form a boundary pallete. There are dedicated upper and lower boundary regist
1718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * GLOBBOUND1 who will derive their values from this palette.
1719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetBoundaries(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t boundary0, c
1725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_value.
1730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_value  Boundary Value<BR>Range[0 - 4095]
1731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs either the boundary 0 or boundary 1 for result comparison.\n\n This defines a range aga
1736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result of a conversion can be compared. In the fast compare mode, the two boundaries provide
1737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * capability to a compare value.
1738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetIndividualBoundary(XMC_VADC_GLOBAL_t *const global_ptr,
1744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const XMC_VADC_CHANNEL_BOUNDARY_t selection,
1745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const uint16_t boundary_value);
1746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_AVAILABLE== 1U)
1749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module
1752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param emuxif       The EMUX interface<BR>Range[0x0 - 0x1]
1753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group        The VADC group which must be bound to the desired emux
1754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds a VADC \a group to an EMUX interface specified in \a emuxif.<BR>\n
1759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects which group's scan request source will control the EMUX interface (set of control select
1760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * By passing \b group it would configure that group's scan request source to control the EMUX sele
1761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \b emuxif.
1762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BindGroupToEMux(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t emuxif, co
1767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return uint32_t Complete global result register value GLOBRES
1774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Retrieves the complete result from the global result register associated with the \a global_ptr.
1777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result register GLOBRES for the validity of the data. If the validity is assured, data is fi
1778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the global result register, cached locally next and subsequently returned to the caller.
1779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @note You can cast the return to a varible of type XMC_VADC_GLOBAL_DETAILED_RESULT_t to easily a
1781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_GetResult()
1784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GLOBAL_GetDetailedResult(XMC_VADC_GLOBAL_t *const global_ptr)
1786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
  25              	 .loc 1 1786 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 7860     	 str r0,[r7,#4]
1787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetDetailedResult:Wrong Module Pointer", (global_ptr == VADC))
1788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return (global_ptr->GLOBRES);
  39              	 .loc 1 1789 0
  40 0008 7A68     	 ldr r2,[r7,#4]
  41 000a C023     	 mov r3,#192
  42 000c 9B00     	 lsl r3,r3,#2
  43 000e D358     	 ldr r3,[r2,r3]
1790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
  44              	 .loc 1 1790 0
  45 0010 181C     	 mov r0,r3
  46 0012 BD46     	 mov sp,r7
  47 0014 02B0     	 add sp,sp,#8
  48              	 
  49 0016 80BD     	 pop {r7,pc}
  50              	 .cfi_endproc
  51              	.LFE66:
  53              	 .section .text.ADC_MEASUREMENT_GetGlobalDetailedResult,"ax",%progbits
  54              	 .align 2
  55              	 .code 16
  56              	 .thumb_func
  58              	ADC_MEASUREMENT_GetGlobalDetailedResult:
  59              	.LFB92:
  60              	 .file 2 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @file adc_measurement.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @date 2021-01-08
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * NOTE:
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @cond
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT v4.1.24 - Incorporates analog to digital conversion for the required measurement
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * All rights reserved.
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * following conditions are met:
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   disclaimer.
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   products derived from this software without specific prior written permission.
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Change History
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * --------------
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-16:
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Initial version for DAVEv4.<BR>
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-19:
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added GetResult APIs for XMC1100 devices.
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-05-14:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Optimized the Manifest.<BR>
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified the structure ADC_MEASUREMENT_channel_t to ADC_MEASUREMENT_CHANNEL_t.<BR>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-06-26:
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added input class resource consumption.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   * 2015-07-09:
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-07-31:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support new devices.<BR>
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-01:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support the interrupt control in XMC14.<BR>
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-08:
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4700/XMC4800 devices.<BR>
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-20:
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-12-03:
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4300 device.<BR>
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-02-09:
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP for the minimum required ANALOG_IO APP version.<BR>
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-03-18:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Maximum number of channels for XMC41/42 increased to 9.<BR>
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added Post calibration time for XMC1x series in Total conversion Time.<BR>
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Fixed the ADC_MEASUREMENT_Init() for ANALOG_IO initialization.<BR>
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Deprecated the API ADC_MEASUREMENT_GetResult() and
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetDetailedResult().<BR>
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Added new API ADC_MEASUREMENT_GetGlobalResult() and
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetGlobalDetailedResult().<BR>
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-08-18:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_A
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2021-01-08:
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified check for minimum XMCLib version
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcond
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /*CODE_BLOCK_BEGIN*/
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifndef ADC_MEASUREMENT_H
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_H
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * HEADER FILES
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "GLOBAL_ADC/global_adc.h"
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "adc_measurement_conf.h"
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * MACROS
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION 2
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MINOR_VERSION 0
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_PATCH_VERSION 0
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if !((XMC_LIB_MAJOR_VERSION > ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) ||\
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION >
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION =
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #error "ADC_MEASUREMENT requires XMC Peripheral Library v2.0.0 or higher"
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if defined (__GNUC__) || defined (__CC_ARM)
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED   __attribute__((deprecated))
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_MODULE_PTR ((XMC_VADC_GLOBAL_t *) (void *) VADC)
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ENUMS
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_enumerations
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**@brief Return value of an API  */
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef enum ADC_MEASUREMENT_STATUS
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_SUCCESS = 0, /**< APP is Initialized */
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_FAILURE, /**< APP Initialization failed*/
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_UNINITIALIZED /**<  APP has not been Initialized */
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_STATUS_t;
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** * DATA STRUCTURES
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ***************************************************************************************************
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_datastructures
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef void (*ADC_MEASUREMENT_MUX_CONFIG_t)(void); /**< Function pointer to the mux configuration*
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  Structure to initialize  Request Source Interrupt's NVIC Node
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_ISR
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t node_id; 		/**< This holds the Node ID of the NVIC.*/
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t priority; 		/**< This holds the NVIC priority.*/
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(UC_FAMILY == XMC4)
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t sub_priority; 	/**< This holds the SubPriority of the NVIC. for Only XMC4x Devices*/
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_NON_DEFAULT_IRQ_SOURCE_SELECTED
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t irqctrl; 	     /**< This indicates the service request source selected for the consumed N
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_ISR_t;
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to initialize ADC channels.
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_CHANNEL_CONFIG_t *ch_handle; /**< This holds the VADC Channel LLD struct*/
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_GROUP_t *group_handle; 		/**< This holds the group to which the channel belongs*/
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_ANALOG_IO_USED
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ANALOG_IO_t   *analog_io_config;    /**< This hold the address of the ANALOG_IO configuration str
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t group_index; 					/**< This holds the group index*/
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t ch_num; 						/**< This Holds the Channel Number*/
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_t;
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to hold channels handles that are configured
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL_ARRAY
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_t *const channel_array[ADC_MEASUREMENT_MAXCHANNELS]; /**< Array whi
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                                         of APPs Cha
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 0U)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_ARRAY_t;
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to configure ADC_MEASUREMENT APP.
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_ARRAY_t *const array; 		 /**< This holds ADC_MEASUREMENT_Channel_Ha
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_BACKGROUND_CONFIG_t *const backgnd_config_handle; /**< This holds the LLD Backgrou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                         Structure*/
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_GLOBAL_CLASS_t *const iclass_config_handle;  /**< This holds the adc global ICLASS
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   GLOBAL_ADC_t *const global_handle; 						 /**< This hold the ADC Global APP handle*/
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if (UC_SERIES != XMC11)
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const req_src_intr_handle; 	 /**< This has the NVIC configuration st
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const result_intr_handle; 	 /**< This has the NVIC configuration str
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_MUX_CONFIG_t mux_config; /**< This hold the pointer to the function that does mux
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_t init_state; 	  /**< Holds information regarding the APP initialization *
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_SR_t srv_req_node; 	  /**< Service Request Line selected*/
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const bool start_conversion; 			  /**< This indicates whether to start at initialization of the A
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_t;
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef __cplusplus
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** extern "C" {
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * API Prototypes
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_apidoc
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Get ADC_MEASUREMENT APP version
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * The function can be used to check application software compatibility with a
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specific version of the APP.
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Example Usage:
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void) 
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_STATUS_t init_status;
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_APP_VERSION_t version;
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // Initialize ADC_MEASUREMENT APP:
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // ADC_MEASUREMENT_Init() is called from within DAVE_Init().
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   init_status = DAVE_Init();
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   version = ADC_MEASUREMENT_GetAppVersion();
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   if (version.major != 1U) {
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     // Probably, not the right version.
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // More code here
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   while(1) {
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   return (0);
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcode
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** DAVE_APP_VERSION_t ADC_MEASUREMENT_GetAppVersion(void);
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Initializes the APP to measure a set of analog inputs. <BR>
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return ADC_MEASUREMENT_STATUS_SUCCESS when initialization succeeds else, return ADC_MEASUREMENT
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Initializes the VADC background scan request source, group channels and result registers with th
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specified in the handle structure. The API configures the conversion timing parameters of VADC, 
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GLOBICLASS] register. The API initializes the channel and result configurations by setting the 
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GxRCRy] registers respectively. It adds all channels into the background request source channel
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [BRSSEL]. For microcontrollers apart from XMC1100, the APP uses background request source event 
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * the interrupt. For XMC1100 devices, global result event is used to generate the interrupt. If "S
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * initialization" has been selected in the GUI, the ADC conversions starts immediately at the end 
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    DAVE_Init(); //ADC_MEASUREMENT_Init is called within DAVE_Init
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    return 0;
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */ 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr);
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Starts the conversion of the required measurements. <BR>
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the APP handle structure<BR>
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return None <BR>
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  If "Start conversion after initialization" option is not selected in the GUI, the conversions c
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  calling this API. A call to this API sets the register bit field BRSMR.LDEV to generate a load 
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  load event triggers the conversion of selected channels in a fixed sequence. A conversion reque
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  upon detection of a hardware trigger. Hence, if "Start conversion after initialization" option 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  "Trigger edge Selection" is configured to any edge, this API call is not mandatory to start the
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #else
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr);
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value for a specific channel. Not Applicable for XMC1100.<BR>
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the channel handle structure of type @ref ADC_MEASUREMENT_
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the result register [GxRESy.RESULT], assigned to the specif
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where separate result registers are available for storing ea
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * For these microcontrollers, each channel is configured to a particular group result register. Th
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is defined in the channel handle structure @ref ADC_MEASUREMENT_CHANNEL_t. Hence this API shall 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * pointer to the channel handle of type  @ref ADC_MEASUREMENT_CHANNEL_t (Directly use the channel 
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * macros which are defined in adc_measurement_conf.h).
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) for XMC1
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Not Applicable for XMC1100. <BR>
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the channel handle structure.
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete result register.<BR>
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GxRES[y]) completely. The result of conversion as well as ot
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) 
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result;
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_Channel_A);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_G_RES_VF_Pos))
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 437:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 438:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.channel_num = (result & VADC_G_RES_CHNR_Msk) >> VADC_G_RES_CHNR_Pos;
 439:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.group_num = ADC_MEASUREMENT_Channel_A.group_index;
 440:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.conversion_result = result & VADC_G_RES_RESULT_Msk;
 441:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 442:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 443:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 444:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 445:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 446:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 447:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 448:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 449:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 450:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 451:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 452:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 453:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 454:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 455:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 456:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else /* Applicable for XMC1100 devices*/
 457:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 459:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 460:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 461:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 462:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 463:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 464:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 465:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 466:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 467:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 469:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetDetailedResult API.
 470:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 471:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 472:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 473:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 474:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 475:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 476:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 477:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 478:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 479:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 480:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 481:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 482:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 483:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 484:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 485:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 486:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 487:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 488:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 489:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_0);
 490:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 491:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 492:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 493:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 494:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 495:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 496:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 497:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 498:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 499:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 500:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 501:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 502:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 503:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREME
 504:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 505:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 506:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 507:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 508:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 509:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 510:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 511:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 512:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 513:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 514:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 515:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 516:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 517:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 518:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 519:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 520:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 521:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 522:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 523:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 524:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 525:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 526:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 527:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 528:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 529:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 530:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 531:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 532:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 533:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 534:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 535:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 536:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 538:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 539:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 540:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 541:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 542:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 543:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 545:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 546:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 547:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 548:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 549:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 550:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 551:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 552:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 553:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 554:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_0);
 555:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 556:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 557:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 558:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 559:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 560:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 561:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 562:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 563:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 564:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 565:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 566:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 567:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 568:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 569:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 570:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 571:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 572:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 573:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 574:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 575:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 576:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREMENT_DEP
 578:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 581:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 582:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 583:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 584:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 585:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 586:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 587:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 588:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 589:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 591:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetGlobalDetailedResult API.
 592:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 593:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 594:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 595:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 596:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 597:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 598:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 599:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 600:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 601:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 602:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 603:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 604:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 605:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 606:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 607:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 609:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 610:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 611:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 612:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 613:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 614:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 615:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 617:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 618:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 619:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 620:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 621:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 622:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 623:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 624:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 625:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE XMC_VADC_RESULT_SIZE_t  ADC_MEASUREMENT_GetGlobalResult(void)
 626:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 627:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 628:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 629:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
 630:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 631:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
 632:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
 633:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 634:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 635:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 636:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 637:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 638:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 639:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 640:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 641:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 642:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 643:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 644:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 645:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 646:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 647:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 648:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 649:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 650:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 651:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 652:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 653:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 654:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 655:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 656:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 657:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 658:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 659:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 660:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 661:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 662:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 663:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 664:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 665:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 666:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 667:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 668:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 669:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 670:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 671:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 672:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 673:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 674:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 675:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 676:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 677:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 678:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 679:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 680:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 681:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 682:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 683:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalDetailedResult();
 684:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 685:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 686:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 687:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 688:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 689:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 690:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 691:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 692:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 693:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 694:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 695:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 696:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 697:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 698:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 699:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 700:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 701:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 702:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 703:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 704:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 705:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 706:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE uint32_t ADC_MEASUREMENT_GetGlobalDetailedResult(void)
 707:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
  61              	 .loc 2 707 0
  62              	 .cfi_startproc
  63 0000 80B5     	 push {r7,lr}
  64              	.LCFI3:
  65              	 .cfi_def_cfa_offset 8
  66              	 .cfi_offset 7,-8
  67              	 .cfi_offset 14,-4
  68 0002 82B0     	 sub sp,sp,#8
  69              	.LCFI4:
  70              	 .cfi_def_cfa_offset 16
  71 0004 00AF     	 add r7,sp,#0
  72              	.LCFI5:
  73              	 .cfi_def_cfa_register 7
 708:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 709:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
  74              	 .loc 2 709 0
  75 0006 054B     	 ldr r3,.L5
  76 0008 181C     	 mov r0,r3
  77 000a FFF7FEFF 	 bl XMC_VADC_GLOBAL_GetDetailedResult
  78 000e 031C     	 mov r3,r0
  79 0010 7B60     	 str r3,[r7,#4]
 710:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 711:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
  80              	 .loc 2 711 0
  81 0012 7B68     	 ldr r3,[r7,#4]
 712:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
  82              	 .loc 2 712 0
  83 0014 181C     	 mov r0,r3
  84 0016 BD46     	 mov sp,r7
  85 0018 02B0     	 add sp,sp,#8
  86              	 
  87 001a 80BD     	 pop {r7,pc}
  88              	.L6:
  89              	 .align 2
  90              	.L5:
  91 001c 00000348 	 .word 1208156160
  92              	 .cfi_endproc
  93              	.LFE92:
  95              	 .section .text.XMC_GPIO_SetOutputHigh,"ax",%progbits
  96              	 .align 2
  97              	 .code 16
  98              	 .thumb_func
 100              	XMC_GPIO_SetOutputHigh:
 101              	.LFB95:
 102              	 .file 3 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics.
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #if UC_FAMILY == XMC1
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 103              	 .loc 3 262 0
 104              	 .cfi_startproc
 105 0000 80B5     	 push {r7,lr}
 106              	.LCFI6:
 107              	 .cfi_def_cfa_offset 8
 108              	 .cfi_offset 7,-8
 109              	 .cfi_offset 14,-4
 110 0002 82B0     	 sub sp,sp,#8
 111              	.LCFI7:
 112              	 .cfi_def_cfa_offset 16
 113 0004 00AF     	 add r7,sp,#0
 114              	.LCFI8:
 115              	 .cfi_def_cfa_register 7
 116 0006 7860     	 str r0,[r7,#4]
 117 0008 0A1C     	 mov r2,r1
 118 000a FB1C     	 add r3,r7,#3
 119 000c 1A70     	 strb r2,[r3]
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
 120              	 .loc 3 265 0
 121 000e FB1C     	 add r3,r7,#3
 122 0010 1B78     	 ldrb r3,[r3]
 123 0012 0122     	 mov r2,#1
 124 0014 9A40     	 lsl r2,r2,r3
 125 0016 7B68     	 ldr r3,[r7,#4]
 126 0018 5A60     	 str r2,[r3,#4]
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 127              	 .loc 3 266 0
 128 001a BD46     	 mov sp,r7
 129 001c 02B0     	 add sp,sp,#8
 130              	 
 131 001e 80BD     	 pop {r7,pc}
 132              	 .cfi_endproc
 133              	.LFE95:
 135              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
 136              	 .align 2
 137              	 .code 16
 138              	 .thumb_func
 140              	XMC_GPIO_SetOutputLow:
 141              	.LFB96:
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 142              	 .loc 3 288 0
 143              	 .cfi_startproc
 144 0000 80B5     	 push {r7,lr}
 145              	.LCFI9:
 146              	 .cfi_def_cfa_offset 8
 147              	 .cfi_offset 7,-8
 148              	 .cfi_offset 14,-4
 149 0002 82B0     	 sub sp,sp,#8
 150              	.LCFI10:
 151              	 .cfi_def_cfa_offset 16
 152 0004 00AF     	 add r7,sp,#0
 153              	.LCFI11:
 154              	 .cfi_def_cfa_register 7
 155 0006 7860     	 str r0,[r7,#4]
 156 0008 0A1C     	 mov r2,r1
 157 000a FB1C     	 add r3,r7,#3
 158 000c 1A70     	 strb r2,[r3]
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
 159              	 .loc 3 291 0
 160 000e FB1C     	 add r3,r7,#3
 161 0010 1B78     	 ldrb r3,[r3]
 162 0012 8022     	 mov r2,#128
 163 0014 5202     	 lsl r2,r2,#9
 164 0016 9A40     	 lsl r2,r2,r3
 165 0018 7B68     	 ldr r3,[r7,#4]
 166 001a 5A60     	 str r2,[r3,#4]
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 167              	 .loc 3 292 0
 168 001c BD46     	 mov sp,r7
 169 001e 02B0     	 add sp,sp,#8
 170              	 
 171 0020 80BD     	 pop {r7,pc}
 172              	 .cfi_endproc
 173              	.LFE96:
 175 0022 C046     	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
 176              	 .align 2
 177              	 .code 16
 178              	 .thumb_func
 180              	XMC_GPIO_GetInput:
 181              	.LFB98:
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  port pin number.
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  Port pin number.
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * None
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 182              	 .loc 3 339 0
 183              	 .cfi_startproc
 184 0000 80B5     	 push {r7,lr}
 185              	.LCFI12:
 186              	 .cfi_def_cfa_offset 8
 187              	 .cfi_offset 7,-8
 188              	 .cfi_offset 14,-4
 189 0002 82B0     	 sub sp,sp,#8
 190              	.LCFI13:
 191              	 .cfi_def_cfa_offset 16
 192 0004 00AF     	 add r7,sp,#0
 193              	.LCFI14:
 194              	 .cfi_def_cfa_register 7
 195 0006 7860     	 str r0,[r7,#4]
 196 0008 0A1C     	 mov r2,r1
 197 000a FB1C     	 add r3,r7,#3
 198 000c 1A70     	 strb r2,[r3]
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
 199              	 .loc 3 342 0
 200 000e 7B68     	 ldr r3,[r7,#4]
 201 0010 5A6A     	 ldr r2,[r3,#36]
 202 0012 FB1C     	 add r3,r7,#3
 203 0014 1B78     	 ldrb r3,[r3]
 204 0016 DA40     	 lsr r2,r2,r3
 205 0018 131C     	 mov r3,r2
 206 001a 0122     	 mov r2,#1
 207 001c 1340     	 and r3,r2
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 208              	 .loc 3 343 0
 209 001e 181C     	 mov r0,r3
 210 0020 BD46     	 mov sp,r7
 211 0022 02B0     	 add sp,sp,#8
 212              	 
 213 0024 80BD     	 pop {r7,pc}
 214              	 .cfi_endproc
 215              	.LFE98:
 217 0026 C046     	 .section .text.DIGITAL_IO_SetOutputHigh,"ax",%progbits
 218              	 .align 2
 219              	 .code 16
 220              	 .thumb_func
 222              	DIGITAL_IO_SetOutputHigh:
 223              	.LFB103:
 224              	 .file 4 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /*
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @file digital_io.h
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @date 2021-01-08
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * NOTE:
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @cond
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DIGITAL_IO v4.0.18 - The DIGITAL_IO APP is used to configure a port pin as digital Input/Output.
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * All rights reserved.
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * following conditions are met:
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   disclaimer.
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   products derived from this software without specific prior written permission.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * with Infineon Technologies AG (dave@infineon.com).
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Change History
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * --------------
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-02-16
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Initial version
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-04-22
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - XMC_ASSERT is added in static inline functions.<br>
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-06-20
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Version check added for XMCLib dependency.<br>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-12-22
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Added hardware controlled IO feature.
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2016-07-08:
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Fixed incorrect case for an included header.<br>
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2021-01-08:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Modified check for minimum XMCLib version
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @endcond
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  */
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * HEADER FILES
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifndef DIGITAL_IO_H
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_H
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "xmc_gpio.h"
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "DAVE_Common.h"
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "digital_io_conf.h"
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * MACROS
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MAJOR_VERSION 2
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MINOR_VERSION 0
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_PATCH_VERSION 0
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #if !((XMC_LIB_MAJOR_VERSION > DIGITAL_IO_XMC_LIB_MAJOR_VERSION) ||\
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > DIGI
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == DIG
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #error "DIGITAL_IO requires XMC Peripheral Library v2.0.0 or higher"
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  /*************************************************************************************************
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * ENUMS
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_enumerations
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization status of DIGITAL_IO APP.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef enum DIGITAL_IO_STATUS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_OK = 0U,/**< 0=Status OK */
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_FAILURE = 1U/**< 1=Status Failed */
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_STATUS_t;
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DATA STRUCTURES
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_datastructures
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization data structure of DIGITAL_IO APP
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef struct DIGITAL_IO
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_PORT_t *const gpio_port;             /**< port number */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_CONFIG_t gpio_config;          /**< mode, initial output level and pad driver stre
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const uint8_t gpio_pin;                       /**< pin number */
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_HWCTRL_t hwctrl;               /**< Hardware port control */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_t;
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * API Prototypes
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifdef __cplusplus
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** extern "C" {
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_apidoc
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Get DIGITAL_IO APP version
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description: </b><br>
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * The function can be used to check application software compatibility with a
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * specific version of the APP.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h"
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t init_status;
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_APP_VERSION_t version;
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // Initialize DIGITAL_IO APP:
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // DIGITAL_IO_Init() is called from within DAVE_Init().
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   init_status = DAVE_Init();
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(init_status == DAVE_STATUS_SUCCESS)
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     version = DIGITAL_IO_GetAppVersion();
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if (version.major != 4U) {
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Probably, not the right version.
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // More code here
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1) {
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     return (1);
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @endcode<BR>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DAVE_APP_VERSION_t DIGITAL_IO_GetAppVersion(void);
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to initialize the port pin as per UI settings.
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status. Refer @ref DIGITAL_IO_STATUS_t structure for d
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function initializes GPIO port registers IOCR,PDISC,OMR,PDR/PHCR to configure pin direction,
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * and pad driver strength/hysteresis.
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * None
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return 1U;
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler);
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to set port pin high.
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to high level
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  DIGITAL_IO_SetOutputLow()
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_0);
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Add application code here
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 225              	 .loc 4 277 0
 226              	 .cfi_startproc
 227 0000 80B5     	 push {r7,lr}
 228              	.LCFI15:
 229              	 .cfi_def_cfa_offset 8
 230              	 .cfi_offset 7,-8
 231              	 .cfi_offset 14,-4
 232 0002 82B0     	 sub sp,sp,#8
 233              	.LCFI16:
 234              	 .cfi_def_cfa_offset 16
 235 0004 00AF     	 add r7,sp,#0
 236              	.LCFI17:
 237              	 .cfi_def_cfa_register 7
 238 0006 7860     	 str r0,[r7,#4]
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 239              	 .loc 4 279 0
 240 0008 7B68     	 ldr r3,[r7,#4]
 241 000a 1A68     	 ldr r2,[r3]
 242 000c 7B68     	 ldr r3,[r7,#4]
 243 000e 1B7B     	 ldrb r3,[r3,#12]
 244 0010 101C     	 mov r0,r2
 245 0012 191C     	 mov r1,r3
 246 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 247              	 .loc 4 280 0
 248 0018 BD46     	 mov sp,r7
 249 001a 02B0     	 add sp,sp,#8
 250              	 
 251 001c 80BD     	 pop {r7,pc}
 252              	 .cfi_endproc
 253              	.LFE103:
 255 001e C046     	 .section .text.DIGITAL_IO_SetOutputLow,"ax",%progbits
 256              	 .align 2
 257              	 .code 16
 258              	 .thumb_func
 260              	DIGITAL_IO_SetOutputLow:
 261              	.LFB104:
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to reset port pin.
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to low level.
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputHigh()
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  int main(void)
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  {
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DAVE_STATUS_t status;
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_I
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    if(status == DAVE_STATUS_SUCCESS)
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG("DAVE Apps initialization success\n");
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    else
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    //Placeholder for user application code. The while loop below can be replaced with user applic
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DIGITAL_IO_SetOutputLow(&DIGITAL_IO_0);
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    while(1U)
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      // Add application code here
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 262              	 .loc 4 325 0
 263              	 .cfi_startproc
 264 0000 80B5     	 push {r7,lr}
 265              	.LCFI18:
 266              	 .cfi_def_cfa_offset 8
 267              	 .cfi_offset 7,-8
 268              	 .cfi_offset 14,-4
 269 0002 82B0     	 sub sp,sp,#8
 270              	.LCFI19:
 271              	 .cfi_def_cfa_offset 16
 272 0004 00AF     	 add r7,sp,#0
 273              	.LCFI20:
 274              	 .cfi_def_cfa_register 7
 275 0006 7860     	 str r0,[r7,#4]
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 276              	 .loc 4 327 0
 277 0008 7B68     	 ldr r3,[r7,#4]
 278 000a 1A68     	 ldr r2,[r3]
 279 000c 7B68     	 ldr r3,[r7,#4]
 280 000e 1B7B     	 ldrb r3,[r3,#12]
 281 0010 101C     	 mov r0,r2
 282 0012 191C     	 mov r1,r3
 283 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 284              	 .loc 4 328 0
 285 0018 BD46     	 mov sp,r7
 286 001a 02B0     	 add sp,sp,#8
 287              	 
 288 001c 80BD     	 pop {r7,pc}
 289              	 .cfi_endproc
 290              	.LFE104:
 292 001e C046     	 .section .text.DIGITAL_IO_GetInput,"ax",%progbits
 293              	 .align 2
 294              	 .code 16
 295              	 .thumb_func
 297              	DIGITAL_IO_GetInput:
 298              	.LFB106:
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to Toggle port pin.
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to toggle port pin.
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputLow(), DIGITAL_IO_SetOutputHigh()
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t delay_count;;
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 1 -> 0 (if initial output level is logic
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 0 -> 1
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to read input level of port pin.
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return uint32_t input logic level. Range:0-1
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function reads the Pn_IN register and returns the current logical value at the GPIO pin.
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  None
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t pin_status;
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();   // (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     pin_status = DIGITAL_IO_GetInput(&DIGITAL_IO_0);
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if(pin_status == 1)
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     else
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 299              	 .loc 4 433 0
 300              	 .cfi_startproc
 301 0000 80B5     	 push {r7,lr}
 302              	.LCFI21:
 303              	 .cfi_def_cfa_offset 8
 304              	 .cfi_offset 7,-8
 305              	 .cfi_offset 14,-4
 306 0002 82B0     	 sub sp,sp,#8
 307              	.LCFI22:
 308              	 .cfi_def_cfa_offset 16
 309 0004 00AF     	 add r7,sp,#0
 310              	.LCFI23:
 311              	 .cfi_def_cfa_register 7
 312 0006 7860     	 str r0,[r7,#4]
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
 313              	 .loc 4 435 0
 314 0008 7B68     	 ldr r3,[r7,#4]
 315 000a 1A68     	 ldr r2,[r3]
 316 000c 7B68     	 ldr r3,[r7,#4]
 317 000e 1B7B     	 ldrb r3,[r3,#12]
 318 0010 101C     	 mov r0,r2
 319 0012 191C     	 mov r1,r3
 320 0014 FFF7FEFF 	 bl XMC_GPIO_GetInput
 321 0018 031C     	 mov r3,r0
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 322              	 .loc 4 436 0
 323 001a 181C     	 mov r0,r3
 324 001c BD46     	 mov sp,r7
 325 001e 02B0     	 add sp,sp,#8
 326              	 
 327 0020 80BD     	 pop {r7,pc}
 328              	 .cfi_endproc
 329              	.LFE106:
 331              	 .global relay_threshold_latchtime
 332 0022 C046     	 .section .data.relay_threshold_latchtime,"aw",%progbits
 333              	 .align 2
 336              	relay_threshold_latchtime:
 337 0000 F4010000 	 .word 500
 338              	 .global ADC_upper_threshold
 339              	 .section .data.ADC_upper_threshold,"aw",%progbits
 340              	 .align 2
 343              	ADC_upper_threshold:
 344 0000 410D0000 	 .word 3393
 345              	 .global ADC_lower_threshold
 346              	 .section .data.ADC_lower_threshold,"aw",%progbits
 347              	 .align 2
 350              	ADC_lower_threshold:
 351 0000 BE020000 	 .word 702
 352              	 .global USB_state
 353              	 .section .bss.USB_state,"aw",%nobits
 356              	USB_state:
 357 0000 00       	 .space 1
 358              	 .global relay_state
 359              	 .section .data.relay_state,"aw",%progbits
 362              	relay_state:
 363 0000 01       	 .byte 1
 364              	 .global setup_state
 365              	 .section .bss.setup_state,"aw",%nobits
 368              	setup_state:
 369 0000 00       	 .space 1
 370              	 .global led_status_pattern
 371              	 .section .bss.led_status_pattern,"aw",%nobits
 374              	led_status_pattern:
 375 0000 00       	 .space 1
 376              	 .global led_status_pattern_last
 377              	 .section .bss.led_status_pattern_last,"aw",%nobits
 380              	led_status_pattern_last:
 381 0000 00       	 .space 1
 382              	 .global led_pattern_mode
 383              	 .section .bss.led_pattern_mode,"aw",%nobits
 386              	led_pattern_mode:
 387 0000 00       	 .space 1
 388              	 .global led_status_pattern_after_single
 389              	 .section .bss.led_status_pattern_after_single,"aw",%nobits
 392              	led_status_pattern_after_single:
 393 0000 00       	 .space 1
 394              	 .global led_number_continuous
 395              	 .section .bss.led_number_continuous,"aw",%nobits
 396              	 .align 1
 399              	led_number_continuous:
 400 0000 0000     	 .space 2
 401              	 .global led_number_single
 402              	 .section .bss.led_number_single,"aw",%nobits
 403              	 .align 1
 406              	led_number_single:
 407 0000 0000     	 .space 2
 408              	 .global led_fadetime
 409              	 .section .data.led_fadetime,"aw",%progbits
 410              	 .align 1
 413              	led_fadetime:
 414 0000 DC05     	 .short 1500
 415              	 .global led_fadesteps
 416              	 .section .data.led_fadesteps,"aw",%progbits
 417              	 .align 1
 420              	led_fadesteps:
 421 0000 E803     	 .short 1000
 422              	 .global buttonpress_usb
 423              	 .section .bss.buttonpress_usb,"aw",%nobits
 426              	buttonpress_usb:
 427 0000 00       	 .space 1
 428              	 .global buttonpress_up
 429              	 .section .bss.buttonpress_up,"aw",%nobits
 432              	buttonpress_up:
 433 0000 00       	 .space 1
 434              	 .global buttonpress_down
 435              	 .section .bss.buttonpress_down,"aw",%nobits
 438              	buttonpress_down:
 439 0000 00       	 .space 1
 440              	 .global button_usb_pressed_timestamp
 441              	 .section .bss.button_usb_pressed_timestamp,"aw",%nobits
 442              	 .align 2
 445              	button_usb_pressed_timestamp:
 446 0000 00000000 	 .space 4
 447              	 .global button_up_pressed_timestamp
 448              	 .section .bss.button_up_pressed_timestamp,"aw",%nobits
 449              	 .align 2
 452              	button_up_pressed_timestamp:
 453 0000 00000000 	 .space 4
 454              	 .global button_down_pressed_timestamp
 455              	 .section .bss.button_down_pressed_timestamp,"aw",%nobits
 456              	 .align 2
 459              	button_down_pressed_timestamp:
 460 0000 00000000 	 .space 4
 461              	 .global button_usb_pressed_duration
 462              	 .section .bss.button_usb_pressed_duration,"aw",%nobits
 463              	 .align 1
 466              	button_usb_pressed_duration:
 467 0000 0000     	 .space 2
 468              	 .global button_up_pressed_duration
 469              	 .section .bss.button_up_pressed_duration,"aw",%nobits
 470              	 .align 1
 473              	button_up_pressed_duration:
 474 0000 0000     	 .space 2
 475              	 .global button_down_pressed_duration
 476              	 .section .bss.button_down_pressed_duration,"aw",%nobits
 477              	 .align 1
 480              	button_down_pressed_duration:
 481 0000 0000     	 .space 2
 482              	 .global ADC_val_current
 483              	 .section .bss.ADC_val_current,"aw",%nobits
 484              	 .align 2
 487              	ADC_val_current:
 488 0000 00000000 	 .space 4
 489              	 .global ADC_val_upper_thres_exceed_timestamp
 490              	 .section .bss.ADC_val_upper_thres_exceed_timestamp,"aw",%nobits
 491              	 .align 2
 494              	ADC_val_upper_thres_exceed_timestamp:
 495 0000 00000000 	 .space 4
 496              	 .global ADC_val_lower_thres_exceed_timestamp
 497              	 .section .bss.ADC_val_lower_thres_exceed_timestamp,"aw",%nobits
 498              	 .align 2
 501              	ADC_val_lower_thres_exceed_timestamp:
 502 0000 00000000 	 .space 4
 503              	 .global systime_debug
 504              	 .section .bss.systime_debug,"aw",%nobits
 505              	 .align 2
 508              	systime_debug:
 509 0000 00000000 	 .space 4
 510              	 .global eeprom_latchtime
 511              	 .section .bss.eeprom_latchtime,"aw",%nobits
 512              	 .align 2
 515              	eeprom_latchtime:
 516 0000 00000000 	 .space 4
 517              	 .global eeprom_upper
 518              	 .section .bss.eeprom_upper,"aw",%nobits
 519              	 .align 2
 522              	eeprom_upper:
 523 0000 00000000 	 .space 4
 524              	 .global eeprom_lower
 525              	 .section .bss.eeprom_lower,"aw",%nobits
 526              	 .align 2
 529              	eeprom_lower:
 530 0000 00000000 	 .space 4
 531              	 .section .text.delay_ms,"ax",%progbits
 532              	 .align 2
 533              	 .global delay_ms
 534              	 .code 16
 535              	 .thumb_func
 537              	delay_ms:
 538              	.LFB160:
 539              	 .file 5 "../main.c"
   1:../main.c     **** /*
   2:../main.c     ****  * main.c
   3:../main.c     ****  *
   4:../main.c     ****  *  Created on: 2022 Mar 03 16:13:51
   5:../main.c     ****  *  Author: RNSANTELER
   6:../main.c     ****  */
   7:../main.c     **** 
   8:../main.c     **** #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
   9:../main.c     **** 
  10:../main.c     **** 
  11:../main.c     **** // Constant settings (must be set hard-coded)
  12:../main.c     **** #define BTN_STD_PRESS_DURATION		60							// The minimum duration of a button press that will be reg
  13:../main.c     **** #define BTN_LONG_PRESS_DURATION		1000						// The minimum duration of a long button press that will
  14:../main.c     **** #define BTN_LONGEST_PRESS_DURATION	4000						// The maximum duration of a button press
  15:../main.c     **** #define ADC_THRESHOLD_MAX			4095						// Maximum ADC value. Note: 4095 can be divided by 1, 3, 5, 7
  16:../main.c     **** #define ADC_THRESHOLD_INCREMENT		(ADC_THRESHOLD_MAX / 35)	// Value added/subtracted when adjusting 
  17:../main.c     **** #define ADC_TH_UPPER_DEFAULT		3510						// Default upper threshold
  18:../main.c     **** #define ADC_TH_LOWER_DEFAULT		585							// Default lower threshold
  19:../main.c     **** #define RELAY_LATCHTIME_MAX			60000						// Maximum configurable time that the threshold must be ex
  20:../main.c     **** #define RELAY_LATCHTIME_INCREMENT	500							// Value added/subtracted when adjusting time
  21:../main.c     **** #define RELAY_LATCHTIME_DEFAULT		500							// Default lower threshold exceed time
  22:../main.c     **** #define LED_PULSE_SHORT				200							// In ms. Duration of a short led pulse used for led pattern "
  23:../main.c     **** #define LED_PULSE_LONG				1100						// In ms. Duration of a long led pulse used for led pattern "nu
  24:../main.c     **** #define PWM_FULL_ON					PWM_CCU4_SYM_DUTY_MIN		// Integer that represents the lowest possible duty 
  25:../main.c     **** #define PWM_FULL_OFF				PWM_CCU4_SYM_DUTY_MAX		// Integer that represents the highest possible duty
  26:../main.c     **** #define TIMESTAMP_DEACTIVATED		UINT32_MAX
  27:../main.c     **** 
  28:../main.c     **** // Dynamic settings (can be changed by user)
  29:../main.c     **** int32_t relay_threshold_latchtime = 500; // Time in ms that the threshold must stay exceeded in ord
  30:../main.c     **** int32_t ADC_upper_threshold = 3393;    // Upper threshold that the ADC value must be exceed to trig
  31:../main.c     **** int32_t ADC_lower_threshold = 702;    // Upper threshold that the ADC value must be exceed to trigg
  32:../main.c     **** 
  33:../main.c     **** 
  34:../main.c     **** // State machines
  35:../main.c     **** typedef enum {USB_1_active, USB_2_active, USB_inactive} USB_states;
  36:../main.c     **** typedef enum {RELAY_HIGH, RELAY_LOW} relay_states;
  37:../main.c     **** typedef enum {SETUP_IDLE, SETUP_UPPER_TH, SETUP_LOWER_TH, SETUP_TIME_TH} setup_states;
  38:../main.c     **** USB_states USB_state = USB_1_active;
  39:../main.c     **** relay_states relay_state = RELAY_LOW;
  40:../main.c     **** setup_states setup_state = SETUP_IDLE;
  41:../main.c     **** typedef enum {LED_OFF, LED_ON, LED_NUMBER, LED_FADE_DOWN, LED_FADE_UP, LED_MATCH_RELAY_STATE} LED_p
  42:../main.c     **** LED_patterns led_status_pattern = LED_OFF;
  43:../main.c     **** LED_patterns led_status_pattern_last = LED_OFF;
  44:../main.c     **** typedef enum {LED_PATTERN_CONTINUOUS, LED_PATTERN_SINGLE} LED_pattern_modes;
  45:../main.c     **** LED_pattern_modes led_pattern_mode = LED_PATTERN_CONTINUOUS;
  46:../main.c     **** LED_patterns led_status_pattern_after_single = LED_OFF; 	// Defines to what pattern will be switche
  47:../main.c     **** uint16_t led_number_continuous = 0;
  48:../main.c     **** uint16_t led_number_single = 0;
  49:../main.c     **** uint16_t led_fadetime = 1500; // Time of one fade from one extreme to the other
  50:../main.c     **** uint16_t led_fadesteps = 1000; // Number of steps used to fade led
  51:../main.c     **** 
  52:../main.c     **** // Buttons
  53:../main.c     **** typedef enum {BTNPRESS_NOT, BTNPRESS_STD, BTNPRESS_LONG, BTNPRESS_LONGEST} button_press_states;
  54:../main.c     **** button_press_states buttonpress_usb = BTNPRESS_NOT;
  55:../main.c     **** button_press_states buttonpress_up = BTNPRESS_NOT;
  56:../main.c     **** button_press_states buttonpress_down = BTNPRESS_NOT;
  57:../main.c     **** uint32_t button_usb_pressed_timestamp = 0; // If a button is pressed (or state = HIGH) the current 
  58:../main.c     **** uint32_t button_up_pressed_timestamp = 0;
  59:../main.c     **** uint32_t button_down_pressed_timestamp = 0;
  60:../main.c     **** uint16_t button_usb_pressed_duration = 0; // If a button is released (or state = LOW) duration is c
  61:../main.c     **** uint16_t button_up_pressed_duration = 0;
  62:../main.c     **** uint16_t button_down_pressed_duration = 0;
  63:../main.c     **** #define SW_ON 0
  64:../main.c     **** #define SW_OFF 1
  65:../main.c     **** 
  66:../main.c     **** // ADC
  67:../main.c     **** uint32_t ADC_val_current = 0;
  68:../main.c     **** uint32_t ADC_val_upper_thres_exceed_timestamp = 0; // If this is 0 the threshold is not exceeded. I
  69:../main.c     **** uint32_t ADC_val_lower_thres_exceed_timestamp = 0;
  70:../main.c     **** 
  71:../main.c     **** // Debug
  72:../main.c     **** int systime_debug = 0;
  73:../main.c     **** int32_t eeprom_latchtime = 0;
  74:../main.c     **** int32_t eeprom_upper = 0;
  75:../main.c     **** int32_t eeprom_lower = 0;
  76:../main.c     **** 
  77:../main.c     **** 
  78:../main.c     **** 
  79:../main.c     **** 
  80:../main.c     **** //****************************************************************************
  81:../main.c     **** // delay_ms - millisecond delay function
  82:../main.c     **** //****************************************************************************
  83:../main.c     **** void delay_ms(uint32_t ms){
 540              	 .loc 5 83 0
 541              	 .cfi_startproc
 542 0000 80B5     	 push {r7,lr}
 543              	.LCFI24:
 544              	 .cfi_def_cfa_offset 8
 545              	 .cfi_offset 7,-8
 546              	 .cfi_offset 14,-4
 547 0002 84B0     	 sub sp,sp,#16
 548              	.LCFI25:
 549              	 .cfi_def_cfa_offset 24
 550 0004 00AF     	 add r7,sp,#0
 551              	.LCFI26:
 552              	 .cfi_def_cfa_register 7
 553 0006 7860     	 str r0,[r7,#4]
  84:../main.c     **** 	uint32_t targetMicroSec = SYSTIMER_GetTime() + (ms*1000);
 554              	 .loc 5 84 0
 555 0008 FFF7FEFF 	 bl SYSTIMER_GetTime
 556 000c 011C     	 mov r1,r0
 557 000e 7B68     	 ldr r3,[r7,#4]
 558 0010 FA22     	 mov r2,#250
 559 0012 9200     	 lsl r2,r2,#2
 560 0014 5343     	 mul r3,r2
 561 0016 CB18     	 add r3,r1,r3
 562 0018 FB60     	 str r3,[r7,#12]
  85:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 563              	 .loc 5 85 0
 564 001a 00E0     	 b .L16
 565              	.L17:
  86:../main.c     **** 		__NOP(); // do nothing
 566              	 .loc 5 86 0
 567              	
 568 001c C046     	 nop
 569              	
 570              	 .code 16
 571              	.L16:
  85:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 572              	 .loc 5 85 0
 573 001e FFF7FEFF 	 bl SYSTIMER_GetTime
 574 0022 021E     	 sub r2,r0,#0
 575 0024 FB68     	 ldr r3,[r7,#12]
 576 0026 9A42     	 cmp r2,r3
 577 0028 F8D3     	 bcc .L17
  87:../main.c     **** }
 578              	 .loc 5 87 0
 579 002a BD46     	 mov sp,r7
 580 002c 04B0     	 add sp,sp,#16
 581              	 
 582 002e 80BD     	 pop {r7,pc}
 583              	 .cfi_endproc
 584              	.LFE160:
 586              	 .section .text.reset_status_led_to_relay_state,"ax",%progbits
 587              	 .align 2
 588              	 .global reset_status_led_to_relay_state
 589              	 .code 16
 590              	 .thumb_func
 592              	reset_status_led_to_relay_state:
 593              	.LFB161:
  88:../main.c     **** 
  89:../main.c     **** //****************************************************************************
  90:../main.c     **** // reset_status_led_to_relay_state - gets state of relay and sets relay led according
  91:../main.c     **** //****************************************************************************
  92:../main.c     **** void reset_status_led_to_relay_state(){
 594              	 .loc 5 92 0
 595              	 .cfi_startproc
 596 0000 80B5     	 push {r7,lr}
 597              	.LCFI27:
 598              	 .cfi_def_cfa_offset 8
 599              	 .cfi_offset 7,-8
 600              	 .cfi_offset 14,-4
 601 0002 82B0     	 sub sp,sp,#8
 602              	.LCFI28:
 603              	 .cfi_def_cfa_offset 16
 604 0004 00AF     	 add r7,sp,#0
 605              	.LCFI29:
 606              	 .cfi_def_cfa_register 7
  93:../main.c     **** 	uint32_t state = DIGITAL_IO_GetInput(&IO_RELAY);
 607              	 .loc 5 93 0
 608 0006 0F4B     	 ldr r3,.L21
 609 0008 181C     	 mov r0,r3
 610 000a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 611 000e 031C     	 mov r3,r0
 612 0010 7B60     	 str r3,[r7,#4]
  94:../main.c     **** 	if(state == 0){
 613              	 .loc 5 94 0
 614 0012 7B68     	 ldr r3,[r7,#4]
 615 0014 002B     	 cmp r3,#0
 616 0016 09D1     	 bne .L19
  95:../main.c     **** 		led_status_pattern = LED_OFF;
 617              	 .loc 5 95 0
 618 0018 0B4B     	 ldr r3,.L21+4
 619 001a 0022     	 mov r2,#0
 620 001c 1A70     	 strb r2,[r3]
  96:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 621              	 .loc 5 96 0
 622 001e 0B4B     	 ldr r3,.L21+8
 623 0020 0B4A     	 ldr r2,.L21+12
 624 0022 181C     	 mov r0,r3
 625 0024 111C     	 mov r1,r2
 626 0026 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 627 002a 07E0     	 b .L18
 628              	.L19:
  97:../main.c     **** 	}
  98:../main.c     **** 	else{
  99:../main.c     **** 		led_status_pattern = LED_ON;
 629              	 .loc 5 99 0
 630 002c 064B     	 ldr r3,.L21+4
 631 002e 0122     	 mov r2,#1
 632 0030 1A70     	 strb r2,[r3]
 100:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 633              	 .loc 5 100 0
 634 0032 064B     	 ldr r3,.L21+8
 635 0034 181C     	 mov r0,r3
 636 0036 0021     	 mov r1,#0
 637 0038 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 638              	.L18:
 101:../main.c     **** 	}
 102:../main.c     **** }
 639              	 .loc 5 102 0
 640 003c BD46     	 mov sp,r7
 641 003e 02B0     	 add sp,sp,#8
 642              	 
 643 0040 80BD     	 pop {r7,pc}
 644              	.L22:
 645 0042 C046     	 .align 2
 646              	.L21:
 647 0044 00000000 	 .word IO_RELAY
 648 0048 00000000 	 .word led_status_pattern
 649 004c 00000000 	 .word PWM_CCU4_LED_STATUS
 650 0050 10270000 	 .word 10000
 651              	 .cfi_endproc
 652              	.LFE161:
 654              	 .global __aeabi_uidiv
 655              	 .section .text.manage_status_led,"ax",%progbits
 656              	 .align 2
 657              	 .global manage_status_led
 658              	 .code 16
 659              	 .thumb_func
 661              	manage_status_led:
 662              	.LFB162:
 103:../main.c     **** 
 104:../main.c     **** //****************************************************************************
 105:../main.c     **** // manage_status_led - blink the status led according to the given pattern and (user interface)
 106:../main.c     **** //****************************************************************************
 107:../main.c     **** void manage_status_led(){
 663              	 .loc 5 107 0
 664              	 .cfi_startproc
 665 0000 80B5     	 push {r7,lr}
 666              	.LCFI30:
 667              	 .cfi_def_cfa_offset 8
 668              	 .cfi_offset 7,-8
 669              	 .cfi_offset 14,-4
 670 0002 82B0     	 sub sp,sp,#8
 671              	.LCFI31:
 672              	 .cfi_def_cfa_offset 16
 673 0004 00AF     	 add r7,sp,#0
 674              	.LCFI32:
 675              	 .cfi_def_cfa_register 7
 108:../main.c     **** 	static uint16_t led_pattern_state;
 109:../main.c     **** 	static uint32_t led_pattern_state_timestamp;
 110:../main.c     **** 	static uint16_t led_pattern_state_length;
 111:../main.c     **** 
 112:../main.c     **** 	static uint16_t fade_duty_step;
 113:../main.c     **** 
 114:../main.c     **** 	// Check target pattern an initiate
 115:../main.c     **** 	if(led_status_pattern != led_status_pattern_last){
 676              	 .loc 5 115 0
 677 0006 B64B     	 ldr r3,.L54
 678 0008 1A78     	 ldrb r2,[r3]
 679 000a B64B     	 ldr r3,.L54+4
 680 000c 1B78     	 ldrb r3,[r3]
 681 000e 9A42     	 cmp r2,r3
 682 0010 00D1     	 bne .LCB406
 683 0012 93E0     	 b .L24
 684              	.LCB406:
 116:../main.c     **** 		switch (led_status_pattern){
 685              	 .loc 5 116 0
 686 0014 B24B     	 ldr r3,.L54
 687 0016 1B78     	 ldrb r3,[r3]
 688 0018 052B     	 cmp r3,#5
 689 001a 00D9     	 bls .LCB410
 690 001c 8AE0     	 b .L25
 691              	.LCB410:
 692 001e 9A00     	 lsl r2,r3,#2
 693 0020 B14B     	 ldr r3,.L54+8
 694 0022 D318     	 add r3,r2,r3
 695 0024 1B68     	 ldr r3,[r3]
 696 0026 9F46     	 mov pc,r3
 697              	 .section .rodata.manage_status_led,"a",%progbits
 698              	 .align 2
 699              	.L27:
 700 0000 28000000 	 .word .L26
 701 0004 36000000 	 .word .L28
 702 0008 42000000 	 .word .L29
 703 000c 88000000 	 .word .L30
 704 0010 DA000000 	 .word .L31
 705 0014 2E010000 	 .word .L32
 706              	 .section .text.manage_status_led
 707              	.L26:
 117:../main.c     **** 			case LED_OFF:
 118:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 708              	 .loc 5 118 0
 709 0028 B04B     	 ldr r3,.L54+12
 710 002a B14A     	 ldr r2,.L54+16
 711 002c 181C     	 mov r0,r3
 712 002e 111C     	 mov r1,r2
 713 0030 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 119:../main.c     **** 				break;
 714              	 .loc 5 119 0
 715 0034 7EE0     	 b .L25
 716              	.L28:
 120:../main.c     **** 			case LED_ON:
 121:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 717              	 .loc 5 121 0
 718 0036 AD4B     	 ldr r3,.L54+12
 719 0038 181C     	 mov r0,r3
 720 003a 0021     	 mov r1,#0
 721 003c FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 122:../main.c     **** 				break;
 722              	 .loc 5 122 0
 723 0040 78E0     	 b .L25
 724              	.L29:
 123:../main.c     **** 			case LED_NUMBER:
 124:../main.c     **** 				if((led_number_continuous >= 1 && led_pattern_mode == LED_PATTERN_CONTINUOUS) || (led_number_si
 725              	 .loc 5 124 0
 726 0042 AC4B     	 ldr r3,.L54+20
 727 0044 1B88     	 ldrh r3,[r3]
 728 0046 002B     	 cmp r3,#0
 729 0048 03D0     	 beq .L33
 730              	 .loc 5 124 0 is_stmt 0 discriminator 1
 731 004a AB4B     	 ldr r3,.L54+24
 732 004c 1B78     	 ldrb r3,[r3]
 733 004e 002B     	 cmp r3,#0
 734 0050 07D0     	 beq .L34
 735              	.L33:
 736              	 .loc 5 124 0 discriminator 3
 737 0052 AA4B     	 ldr r3,.L54+28
 738 0054 1B88     	 ldrh r3,[r3]
 739 0056 002B     	 cmp r3,#0
 740 0058 15D0     	 beq .L35
 741              	 .loc 5 124 0 discriminator 4
 742 005a A74B     	 ldr r3,.L54+24
 743 005c 1B78     	 ldrb r3,[r3]
 744 005e 012B     	 cmp r3,#1
 745 0060 11D1     	 bne .L35
 746              	.L34:
 125:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 747              	 .loc 5 125 0 is_stmt 1
 748 0062 FFF7FEFF 	 bl SYSTIMER_GetTime
 749 0066 021C     	 mov r2,r0
 750 0068 A54B     	 ldr r3,.L54+32
 751 006a 1A60     	 str r2,[r3]
 126:../main.c     **** 					led_pattern_state_length = LED_PULSE_SHORT;
 752              	 .loc 5 126 0
 753 006c A54B     	 ldr r3,.L54+36
 754 006e C822     	 mov r2,#200
 755 0070 1A80     	 strh r2,[r3]
 127:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 756              	 .loc 5 127 0
 757 0072 9E4B     	 ldr r3,.L54+12
 758 0074 9E4A     	 ldr r2,.L54+16
 759 0076 181C     	 mov r0,r3
 760 0078 111C     	 mov r1,r2
 761 007a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 128:../main.c     **** 					led_pattern_state = 0;
 762              	 .loc 5 128 0
 763 007e A24B     	 ldr r3,.L54+40
 764 0080 0022     	 mov r2,#0
 765 0082 1A80     	 strh r2,[r3]
 129:../main.c     **** 				}
 130:../main.c     **** 				break;
 766              	 .loc 5 130 0
 767 0084 56E0     	 b .L25
 768              	.L35:
 769 0086 55E0     	 b .L25
 770              	.L30:
 131:../main.c     **** 			case LED_FADE_DOWN:
 132:../main.c     **** 				if(led_fadetime > 0){
 771              	 .loc 5 132 0
 772 0088 A04B     	 ldr r3,.L54+44
 773 008a 1B88     	 ldrh r3,[r3]
 774 008c 002B     	 cmp r3,#0
 775 008e 23D0     	 beq .L36
 133:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 776              	 .loc 5 133 0
 777 0090 FFF7FEFF 	 bl SYSTIMER_GetTime
 778 0094 021C     	 mov r2,r0
 779 0096 9A4B     	 ldr r3,.L54+32
 780 0098 1A60     	 str r2,[r3]
 134:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 781              	 .loc 5 134 0
 782 009a 9C4B     	 ldr r3,.L54+44
 783 009c 1A88     	 ldrh r2,[r3]
 784 009e 9C4B     	 ldr r3,.L54+48
 785 00a0 1B88     	 ldrh r3,[r3]
 786 00a2 101C     	 mov r0,r2
 787 00a4 191C     	 mov r1,r3
 788 00a6 FFF7FEFF 	 bl __aeabi_uidiv
 789 00aa 031C     	 mov r3,r0
 790 00ac 9AB2     	 uxth r2,r3
 791 00ae 954B     	 ldr r3,.L54+36
 792 00b0 1A80     	 strh r2,[r3]
 135:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 793              	 .loc 5 135 0
 794 00b2 974B     	 ldr r3,.L54+48
 795 00b4 1B88     	 ldrh r3,[r3]
 796 00b6 8E48     	 ldr r0,.L54+16
 797 00b8 191C     	 mov r1,r3
 798 00ba FFF7FEFF 	 bl __aeabi_uidiv
 799 00be 031C     	 mov r3,r0
 800 00c0 9AB2     	 uxth r2,r3
 801 00c2 944B     	 ldr r3,.L54+52
 802 00c4 1A80     	 strh r2,[r3]
 136:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 803              	 .loc 5 136 0
 804 00c6 894B     	 ldr r3,.L54+12
 805 00c8 181C     	 mov r0,r3
 806 00ca 0021     	 mov r1,#0
 807 00cc FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 137:../main.c     **** 					led_pattern_state = 0;
 808              	 .loc 5 137 0
 809 00d0 8D4B     	 ldr r3,.L54+40
 810 00d2 0022     	 mov r2,#0
 811 00d4 1A80     	 strh r2,[r3]
 138:../main.c     **** 				}
 139:../main.c     **** 				break;
 812              	 .loc 5 139 0
 813 00d6 2DE0     	 b .L25
 814              	.L36:
 815 00d8 2CE0     	 b .L25
 816              	.L31:
 140:../main.c     **** 			case LED_FADE_UP:
 141:../main.c     **** 				if(led_fadetime > 0){
 817              	 .loc 5 141 0
 818 00da 8C4B     	 ldr r3,.L54+44
 819 00dc 1B88     	 ldrh r3,[r3]
 820 00de 002B     	 cmp r3,#0
 821 00e0 24D0     	 beq .L37
 142:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 822              	 .loc 5 142 0
 823 00e2 FFF7FEFF 	 bl SYSTIMER_GetTime
 824 00e6 021C     	 mov r2,r0
 825 00e8 854B     	 ldr r3,.L54+32
 826 00ea 1A60     	 str r2,[r3]
 143:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 827              	 .loc 5 143 0
 828 00ec 874B     	 ldr r3,.L54+44
 829 00ee 1A88     	 ldrh r2,[r3]
 830 00f0 874B     	 ldr r3,.L54+48
 831 00f2 1B88     	 ldrh r3,[r3]
 832 00f4 101C     	 mov r0,r2
 833 00f6 191C     	 mov r1,r3
 834 00f8 FFF7FEFF 	 bl __aeabi_uidiv
 835 00fc 031C     	 mov r3,r0
 836 00fe 9AB2     	 uxth r2,r3
 837 0100 804B     	 ldr r3,.L54+36
 838 0102 1A80     	 strh r2,[r3]
 144:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 839              	 .loc 5 144 0
 840 0104 824B     	 ldr r3,.L54+48
 841 0106 1B88     	 ldrh r3,[r3]
 842 0108 7948     	 ldr r0,.L54+16
 843 010a 191C     	 mov r1,r3
 844 010c FFF7FEFF 	 bl __aeabi_uidiv
 845 0110 031C     	 mov r3,r0
 846 0112 9AB2     	 uxth r2,r3
 847 0114 7F4B     	 ldr r3,.L54+52
 848 0116 1A80     	 strh r2,[r3]
 145:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 849              	 .loc 5 145 0
 850 0118 744B     	 ldr r3,.L54+12
 851 011a 754A     	 ldr r2,.L54+16
 852 011c 181C     	 mov r0,r3
 853 011e 111C     	 mov r1,r2
 854 0120 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 146:../main.c     **** 					led_pattern_state = 0;
 855              	 .loc 5 146 0
 856 0124 784B     	 ldr r3,.L54+40
 857 0126 0022     	 mov r2,#0
 858 0128 1A80     	 strh r2,[r3]
 147:../main.c     **** 				}
 148:../main.c     **** 				break;
 859              	 .loc 5 148 0
 860 012a 03E0     	 b .L25
 861              	.L37:
 862 012c 02E0     	 b .L25
 863              	.L32:
 149:../main.c     **** 			case LED_MATCH_RELAY_STATE:
 150:../main.c     **** 				reset_status_led_to_relay_state();
 864              	 .loc 5 150 0
 865 012e FFF7FEFF 	 bl reset_status_led_to_relay_state
 151:../main.c     **** 				break;
 866              	 .loc 5 151 0
 867 0132 C046     	 mov r8,r8
 868              	.L25:
 152:../main.c     **** 		}
 153:../main.c     **** 		led_status_pattern_last = led_status_pattern;
 869              	 .loc 5 153 0
 870 0134 6A4B     	 ldr r3,.L54
 871 0136 1A78     	 ldrb r2,[r3]
 872 0138 6A4B     	 ldr r3,.L54+4
 873 013a 1A70     	 strb r2,[r3]
 874              	.L24:
 154:../main.c     **** 	}
 155:../main.c     **** 
 156:../main.c     **** 	// Handle LED_NUMBER pattern
 157:../main.c     **** 	if(led_status_pattern == LED_NUMBER){
 875              	 .loc 5 157 0
 876 013c 684B     	 ldr r3,.L54
 877 013e 1B78     	 ldrb r3,[r3]
 878 0140 022B     	 cmp r3,#2
 879 0142 00D0     	 beq .LCB580
 880 0144 6BE0     	 b .L38
 881              	.LCB580:
 158:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 882              	 .loc 5 158 0
 883 0146 FFF7FEFF 	 bl SYSTIMER_GetTime
 884 014a 021C     	 mov r2,r0
 885 014c 6C4B     	 ldr r3,.L54+32
 886 014e 1B68     	 ldr r3,[r3]
 887 0150 D31A     	 sub r3,r2,r3
 888 0152 181C     	 mov r0,r3
 889 0154 FA23     	 mov r3,#250
 890 0156 9900     	 lsl r1,r3,#2
 891 0158 FFF7FEFF 	 bl __aeabi_uidiv
 892 015c 031C     	 mov r3,r0
 893 015e 1A1C     	 mov r2,r3
 894 0160 684B     	 ldr r3,.L54+36
 895 0162 1B88     	 ldrh r3,[r3]
 896 0164 9A42     	 cmp r2,r3
 897 0166 59D3     	 bcc .L39
 898              	.LBB2:
 159:../main.c     **** 			// Next state
 160:../main.c     **** 			led_pattern_state++;
 899              	 .loc 5 160 0
 900 0168 674B     	 ldr r3,.L54+40
 901 016a 1B88     	 ldrh r3,[r3]
 902 016c 0133     	 add r3,r3,#1
 903 016e 9AB2     	 uxth r2,r3
 904 0170 654B     	 ldr r3,.L54+40
 905 0172 1A80     	 strh r2,[r3]
 161:../main.c     **** 
 162:../main.c     **** 			// Use right pulse number based on current pattern mode
 163:../main.c     **** 			uint16_t led_number;
 164:../main.c     **** 			if(led_pattern_mode == LED_PATTERN_CONTINUOUS)
 906              	 .loc 5 164 0
 907 0174 604B     	 ldr r3,.L54+24
 908 0176 1B78     	 ldrb r3,[r3]
 909 0178 002B     	 cmp r3,#0
 910 017a 04D1     	 bne .L40
 165:../main.c     **** 				led_number = led_number_continuous;
 911              	 .loc 5 165 0
 912 017c BB1D     	 add r3,r7,#6
 913 017e 5D4A     	 ldr r2,.L54+20
 914 0180 1288     	 ldrh r2,[r2]
 915 0182 1A80     	 strh r2,[r3]
 916 0184 03E0     	 b .L41
 917              	.L40:
 166:../main.c     **** 			else
 167:../main.c     **** 				led_number = led_number_single;
 918              	 .loc 5 167 0
 919 0186 BB1D     	 add r3,r7,#6
 920 0188 5C4A     	 ldr r2,.L54+28
 921 018a 1288     	 ldrh r2,[r2]
 922 018c 1A80     	 strh r2,[r3]
 923              	.L41:
 168:../main.c     **** 
 169:../main.c     **** 			// Check if LED must be powered on or off for this state
 170:../main.c     **** 			if(led_pattern_state % 2)
 924              	 .loc 5 170 0
 925 018e 5E4B     	 ldr r3,.L54+40
 926 0190 1B88     	 ldrh r3,[r3]
 927 0192 0122     	 mov r2,#1
 928 0194 1340     	 and r3,r2
 929 0196 9BB2     	 uxth r3,r3
 930 0198 002B     	 cmp r3,#0
 931 019a 05D0     	 beq .L42
 171:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 932              	 .loc 5 171 0
 933 019c 534B     	 ldr r3,.L54+12
 934 019e 181C     	 mov r0,r3
 935 01a0 0021     	 mov r1,#0
 936 01a2 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 937 01a6 05E0     	 b .L43
 938              	.L42:
 172:../main.c     **** 			else
 173:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 939              	 .loc 5 173 0
 940 01a8 504B     	 ldr r3,.L54+12
 941 01aa 514A     	 ldr r2,.L54+16
 942 01ac 181C     	 mov r0,r3
 943 01ae 111C     	 mov r1,r2
 944 01b0 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 945              	.L43:
 174:../main.c     **** 
 175:../main.c     **** 			// Detect last low phase and make it longer
 176:../main.c     **** 			if(led_pattern_state == (led_number*2) && led_pattern_mode == LED_PATTERN_CONTINUOUS)
 946              	 .loc 5 176 0
 947 01b4 544B     	 ldr r3,.L54+40
 948 01b6 1B88     	 ldrh r3,[r3]
 949 01b8 1A1C     	 mov r2,r3
 950 01ba BB1D     	 add r3,r7,#6
 951 01bc 1B88     	 ldrh r3,[r3]
 952 01be 5B00     	 lsl r3,r3,#1
 953 01c0 9A42     	 cmp r2,r3
 954 01c2 07D1     	 bne .L44
 955              	 .loc 5 176 0 is_stmt 0 discriminator 1
 956 01c4 4C4B     	 ldr r3,.L54+24
 957 01c6 1B78     	 ldrb r3,[r3]
 958 01c8 002B     	 cmp r3,#0
 959 01ca 03D1     	 bne .L44
 177:../main.c     **** 				led_pattern_state_length = LED_PULSE_LONG;
 960              	 .loc 5 177 0 is_stmt 1
 961 01cc 4D4B     	 ldr r3,.L54+36
 962 01ce 524A     	 ldr r2,.L54+56
 963 01d0 1A80     	 strh r2,[r3]
 964 01d2 02E0     	 b .L45
 965              	.L44:
 178:../main.c     **** 			else
 179:../main.c     **** 				led_pattern_state_length = LED_PULSE_SHORT;
 966              	 .loc 5 179 0
 967 01d4 4B4B     	 ldr r3,.L54+36
 968 01d6 C822     	 mov r2,#200
 969 01d8 1A80     	 strh r2,[r3]
 970              	.L45:
 180:../main.c     **** 
 181:../main.c     **** 			// Store current time
 182:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 971              	 .loc 5 182 0
 972 01da FFF7FEFF 	 bl SYSTIMER_GetTime
 973 01de 021C     	 mov r2,r0
 974 01e0 474B     	 ldr r3,.L54+32
 975 01e2 1A60     	 str r2,[r3]
 183:../main.c     **** 
 184:../main.c     **** 			// Check if LED pattern is finished
 185:../main.c     **** 			if(led_pattern_state > led_number*2){
 976              	 .loc 5 185 0
 977 01e4 484B     	 ldr r3,.L54+40
 978 01e6 1B88     	 ldrh r3,[r3]
 979 01e8 1A1C     	 mov r2,r3
 980 01ea BB1D     	 add r3,r7,#6
 981 01ec 1B88     	 ldrh r3,[r3]
 982 01ee 5B00     	 lsl r3,r3,#1
 983 01f0 9A42     	 cmp r2,r3
 984 01f2 13DD     	 ble .L39
 186:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS) // Repeat pattern
 985              	 .loc 5 186 0
 986 01f4 404B     	 ldr r3,.L54+24
 987 01f6 1B78     	 ldrb r3,[r3]
 988 01f8 002B     	 cmp r3,#0
 989 01fa 03D1     	 bne .L46
 187:../main.c     **** 					led_pattern_state = 1;
 990              	 .loc 5 187 0
 991 01fc 424B     	 ldr r3,.L54+40
 992 01fe 0122     	 mov r2,#1
 993 0200 1A80     	 strh r2,[r3]
 994 0202 0BE0     	 b .L39
 995              	.L46:
 188:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 996              	 .loc 5 188 0
 997 0204 3C4B     	 ldr r3,.L54+24
 998 0206 1B78     	 ldrb r3,[r3]
 999 0208 012B     	 cmp r3,#1
 1000 020a 07D1     	 bne .L39
 189:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1001              	 .loc 5 189 0
 1002 020c 3A4B     	 ldr r3,.L54+24
 1003 020e 0022     	 mov r2,#0
 1004 0210 1A70     	 strb r2,[r3]
 190:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1005              	 .loc 5 190 0
 1006 0212 424B     	 ldr r3,.L54+60
 1007 0214 1A78     	 ldrb r2,[r3]
 1008 0216 324B     	 ldr r3,.L54
 1009 0218 1A70     	 strb r2,[r3]
 1010              	.LBE2:
 1011 021a DEE0     	 b .L23
 1012              	.L39:
 1013 021c DDE0     	 b .L23
 1014              	.L38:
 191:../main.c     **** 				}
 192:../main.c     **** 			}
 193:../main.c     **** 		}
 194:../main.c     **** 	}
 195:../main.c     **** 
 196:../main.c     **** 	// Handle LED_FADE_UP pattern
 197:../main.c     **** 	else if(led_status_pattern == LED_FADE_DOWN){
 1015              	 .loc 5 197 0
 1016 021e 304B     	 ldr r3,.L54
 1017 0220 1B78     	 ldrb r3,[r3]
 1018 0222 032B     	 cmp r3,#3
 1019 0224 00D0     	 beq .LCB713
 1020 0226 7BE0     	 b .L48
 1021              	.LCB713:
 198:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 1022              	 .loc 5 198 0
 1023 0228 FFF7FEFF 	 bl SYSTIMER_GetTime
 1024 022c 021C     	 mov r2,r0
 1025 022e 344B     	 ldr r3,.L54+32
 1026 0230 1B68     	 ldr r3,[r3]
 1027 0232 D31A     	 sub r3,r2,r3
 1028 0234 181C     	 mov r0,r3
 1029 0236 FA23     	 mov r3,#250
 1030 0238 9900     	 lsl r1,r3,#2
 1031 023a FFF7FEFF 	 bl __aeabi_uidiv
 1032 023e 031C     	 mov r3,r0
 1033 0240 1A1C     	 mov r2,r3
 1034 0242 304B     	 ldr r3,.L54+36
 1035 0244 1B88     	 ldrh r3,[r3]
 1036 0246 9A42     	 cmp r2,r3
 1037 0248 00D2     	 bcs .LCB728
 1038 024a C6E0     	 b .L23
 1039              	.LCB728:
 199:../main.c     **** 			// Set intensity of led to a level based on maximum value and current step
 200:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, (led_pattern_state*fade_duty_step) + PWM_FULL_ON);
 1040              	 .loc 5 200 0
 1041 024c 2E4B     	 ldr r3,.L54+40
 1042 024e 1B88     	 ldrh r3,[r3]
 1043 0250 1A1C     	 mov r2,r3
 1044 0252 304B     	 ldr r3,.L54+52
 1045 0254 1B88     	 ldrh r3,[r3]
 1046 0256 5343     	 mul r3,r2
 1047 0258 1A1C     	 mov r2,r3
 1048 025a 244B     	 ldr r3,.L54+12
 1049 025c 181C     	 mov r0,r3
 1050 025e 111C     	 mov r1,r2
 1051 0260 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 201:../main.c     **** 
 202:../main.c     **** 			// Store current time
 203:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 1052              	 .loc 5 203 0
 1053 0264 FFF7FEFF 	 bl SYSTIMER_GetTime
 1054 0268 021C     	 mov r2,r0
 1055 026a 254B     	 ldr r3,.L54+32
 1056 026c 1A60     	 str r2,[r3]
 204:../main.c     **** 
 205:../main.c     **** 			// Next state
 206:../main.c     **** 			led_pattern_state++;
 1057              	 .loc 5 206 0
 1058 026e 264B     	 ldr r3,.L54+40
 1059 0270 1B88     	 ldrh r3,[r3]
 1060 0272 0133     	 add r3,r3,#1
 1061 0274 9AB2     	 uxth r2,r3
 1062 0276 244B     	 ldr r3,.L54+40
 1063 0278 1A80     	 strh r2,[r3]
 207:../main.c     **** 
 208:../main.c     **** 			// Make last state longer
 209:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 1064              	 .loc 5 209 0
 1065 027a 234B     	 ldr r3,.L54+40
 1066 027c 1B88     	 ldrh r3,[r3]
 1067 027e 1A1C     	 mov r2,r3
 1068 0280 234B     	 ldr r3,.L54+48
 1069 0282 1B88     	 ldrh r3,[r3]
 1070 0284 013B     	 sub r3,r3,#1
 1071 0286 9A42     	 cmp r2,r3
 1072 0288 06D1     	 bne .L50
 210:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 1073              	 .loc 5 210 0
 1074 028a 1E4B     	 ldr r3,.L54+36
 1075 028c 1B88     	 ldrh r3,[r3]
 1076 028e 9133     	 add r3,r3,#145
 1077 0290 FF33     	 add r3,r3,#255
 1078 0292 9AB2     	 uxth r2,r3
 1079 0294 1B4B     	 ldr r3,.L54+36
 1080 0296 1A80     	 strh r2,[r3]
 1081              	.L50:
 211:../main.c     **** 
 212:../main.c     **** 			// Check if LED pattern is finished
 213:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1082              	 .loc 5 213 0
 1083 0298 1B4B     	 ldr r3,.L54+40
 1084 029a 1A88     	 ldrh r2,[r3]
 1085 029c 1C4B     	 ldr r3,.L54+48
 1086 029e 1B88     	 ldrh r3,[r3]
 1087 02a0 9A42     	 cmp r2,r3
 1088 02a2 00D2     	 bcs .LCB772
 1089 02a4 99E0     	 b .L23
 1090              	.LCB772:
 214:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1091              	 .loc 5 214 0
 1092 02a6 144B     	 ldr r3,.L54+24
 1093 02a8 1B78     	 ldrb r3,[r3]
 1094 02aa 002B     	 cmp r3,#0
 1095 02ac 0AD1     	 bne .L51
 215:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1096              	 .loc 5 215 0
 1097 02ae 154B     	 ldr r3,.L54+36
 1098 02b0 1B88     	 ldrh r3,[r3]
 1099 02b2 913B     	 sub r3,r3,#145
 1100 02b4 FF3B     	 sub r3,r3,#255
 1101 02b6 9AB2     	 uxth r2,r3
 1102 02b8 124B     	 ldr r3,.L54+36
 1103 02ba 1A80     	 strh r2,[r3]
 216:../main.c     **** 					led_pattern_state = 0;
 1104              	 .loc 5 216 0
 1105 02bc 124B     	 ldr r3,.L54+40
 1106 02be 0022     	 mov r2,#0
 1107 02c0 1A80     	 strh r2,[r3]
 1108 02c2 8AE0     	 b .L23
 1109              	.L51:
 217:../main.c     **** 				}
 218:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1110              	 .loc 5 218 0
 1111 02c4 0C4B     	 ldr r3,.L54+24
 1112 02c6 1B78     	 ldrb r3,[r3]
 1113 02c8 012B     	 cmp r3,#1
 1114 02ca 00D0     	 beq .LCB794
 1115 02cc 85E0     	 b .L23
 1116              	.LCB794:
 219:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1117              	 .loc 5 219 0
 1118 02ce 0A4B     	 ldr r3,.L54+24
 1119 02d0 0022     	 mov r2,#0
 1120 02d2 1A70     	 strb r2,[r3]
 220:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1121              	 .loc 5 220 0
 1122 02d4 114B     	 ldr r3,.L54+60
 1123 02d6 1A78     	 ldrb r2,[r3]
 1124 02d8 014B     	 ldr r3,.L54
 1125 02da 1A70     	 strb r2,[r3]
 1126 02dc 7DE0     	 b .L23
 1127              	.L55:
 1128 02de C046     	 .align 2
 1129              	.L54:
 1130 02e0 00000000 	 .word led_status_pattern
 1131 02e4 00000000 	 .word led_status_pattern_last
 1132 02e8 00000000 	 .word .L27
 1133 02ec 00000000 	 .word PWM_CCU4_LED_STATUS
 1134 02f0 10270000 	 .word 10000
 1135 02f4 00000000 	 .word led_number_continuous
 1136 02f8 00000000 	 .word led_pattern_mode
 1137 02fc 00000000 	 .word led_number_single
 1138 0300 00000000 	 .word led_pattern_state_timestamp.7187
 1139 0304 00000000 	 .word led_pattern_state_length.7188
 1140 0308 00000000 	 .word led_pattern_state.7186
 1141 030c 00000000 	 .word led_fadetime
 1142 0310 00000000 	 .word led_fadesteps
 1143 0314 00000000 	 .word fade_duty_step.7189
 1144 0318 4C040000 	 .word 1100
 1145 031c 00000000 	 .word led_status_pattern_after_single
 1146              	.L48:
 221:../main.c     **** 				}
 222:../main.c     **** 			}
 223:../main.c     **** 		}
 224:../main.c     **** 	}
 225:../main.c     **** 
 226:../main.c     **** 	// Handle LED_FADE_DOWN pattern
 227:../main.c     **** 	else if(led_status_pattern == LED_FADE_UP){
 1147              	 .loc 5 227 0
 1148 0320 2F4B     	 ldr r3,.L56
 1149 0322 1B78     	 ldrb r3,[r3]
 1150 0324 042B     	 cmp r3,#4
 1151 0326 58D1     	 bne .L23
 228:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 1152              	 .loc 5 228 0
 1153 0328 FFF7FEFF 	 bl SYSTIMER_GetTime
 1154 032c 021C     	 mov r2,r0
 1155 032e 2D4B     	 ldr r3,.L56+4
 1156 0330 1B68     	 ldr r3,[r3]
 1157 0332 D31A     	 sub r3,r2,r3
 1158 0334 181C     	 mov r0,r3
 1159 0336 FA23     	 mov r3,#250
 1160 0338 9900     	 lsl r1,r3,#2
 1161 033a FFF7FEFF 	 bl __aeabi_uidiv
 1162 033e 031C     	 mov r3,r0
 1163 0340 1A1C     	 mov r2,r3
 1164 0342 294B     	 ldr r3,.L56+8
 1165 0344 1B88     	 ldrh r3,[r3]
 1166 0346 9A42     	 cmp r2,r3
 1167 0348 47D3     	 bcc .L23
 229:../main.c     **** 			// Set intensity of led to a level based on maximum value and current step
 230:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF - (led_pattern_state*fade_duty_step) );
 1168              	 .loc 5 230 0
 1169 034a 284B     	 ldr r3,.L56+12
 1170 034c 1B88     	 ldrh r3,[r3]
 1171 034e 1A1C     	 mov r2,r3
 1172 0350 274B     	 ldr r3,.L56+16
 1173 0352 1B88     	 ldrh r3,[r3]
 1174 0354 5343     	 mul r3,r2
 1175 0356 1A1C     	 mov r2,r3
 1176 0358 264B     	 ldr r3,.L56+20
 1177 035a 9B1A     	 sub r3,r3,r2
 1178 035c 264A     	 ldr r2,.L56+24
 1179 035e 101C     	 mov r0,r2
 1180 0360 191C     	 mov r1,r3
 1181 0362 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 231:../main.c     **** 
 232:../main.c     **** 			// Store current time
 233:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 1182              	 .loc 5 233 0
 1183 0366 FFF7FEFF 	 bl SYSTIMER_GetTime
 1184 036a 021C     	 mov r2,r0
 1185 036c 1D4B     	 ldr r3,.L56+4
 1186 036e 1A60     	 str r2,[r3]
 234:../main.c     **** 
 235:../main.c     **** 			// Next state
 236:../main.c     **** 			led_pattern_state++;
 1187              	 .loc 5 236 0
 1188 0370 1E4B     	 ldr r3,.L56+12
 1189 0372 1B88     	 ldrh r3,[r3]
 1190 0374 0133     	 add r3,r3,#1
 1191 0376 9AB2     	 uxth r2,r3
 1192 0378 1C4B     	 ldr r3,.L56+12
 1193 037a 1A80     	 strh r2,[r3]
 237:../main.c     **** 
 238:../main.c     **** 			// Make last state longer
 239:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 1194              	 .loc 5 239 0
 1195 037c 1B4B     	 ldr r3,.L56+12
 1196 037e 1B88     	 ldrh r3,[r3]
 1197 0380 1A1C     	 mov r2,r3
 1198 0382 1E4B     	 ldr r3,.L56+28
 1199 0384 1B88     	 ldrh r3,[r3]
 1200 0386 013B     	 sub r3,r3,#1
 1201 0388 9A42     	 cmp r2,r3
 1202 038a 06D1     	 bne .L52
 240:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 1203              	 .loc 5 240 0
 1204 038c 164B     	 ldr r3,.L56+8
 1205 038e 1B88     	 ldrh r3,[r3]
 1206 0390 9133     	 add r3,r3,#145
 1207 0392 FF33     	 add r3,r3,#255
 1208 0394 9AB2     	 uxth r2,r3
 1209 0396 144B     	 ldr r3,.L56+8
 1210 0398 1A80     	 strh r2,[r3]
 1211              	.L52:
 241:../main.c     **** 
 242:../main.c     **** 			// Check if LED pattern is finished
 243:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1212              	 .loc 5 243 0
 1213 039a 144B     	 ldr r3,.L56+12
 1214 039c 1A88     	 ldrh r2,[r3]
 1215 039e 174B     	 ldr r3,.L56+28
 1216 03a0 1B88     	 ldrh r3,[r3]
 1217 03a2 9A42     	 cmp r2,r3
 1218 03a4 19D3     	 bcc .L23
 244:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1219              	 .loc 5 244 0
 1220 03a6 164B     	 ldr r3,.L56+32
 1221 03a8 1B78     	 ldrb r3,[r3]
 1222 03aa 002B     	 cmp r3,#0
 1223 03ac 0AD1     	 bne .L53
 245:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1224              	 .loc 5 245 0
 1225 03ae 0E4B     	 ldr r3,.L56+8
 1226 03b0 1B88     	 ldrh r3,[r3]
 1227 03b2 913B     	 sub r3,r3,#145
 1228 03b4 FF3B     	 sub r3,r3,#255
 1229 03b6 9AB2     	 uxth r2,r3
 1230 03b8 0B4B     	 ldr r3,.L56+8
 1231 03ba 1A80     	 strh r2,[r3]
 246:../main.c     **** 					led_pattern_state = 0;
 1232              	 .loc 5 246 0
 1233 03bc 0B4B     	 ldr r3,.L56+12
 1234 03be 0022     	 mov r2,#0
 1235 03c0 1A80     	 strh r2,[r3]
 1236 03c2 0AE0     	 b .L23
 1237              	.L53:
 247:../main.c     **** 				}
 248:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1238              	 .loc 5 248 0
 1239 03c4 0E4B     	 ldr r3,.L56+32
 1240 03c6 1B78     	 ldrb r3,[r3]
 1241 03c8 012B     	 cmp r3,#1
 1242 03ca 06D1     	 bne .L23
 249:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1243              	 .loc 5 249 0
 1244 03cc 0C4B     	 ldr r3,.L56+32
 1245 03ce 0022     	 mov r2,#0
 1246 03d0 1A70     	 strb r2,[r3]
 250:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1247              	 .loc 5 250 0
 1248 03d2 0C4B     	 ldr r3,.L56+36
 1249 03d4 1A78     	 ldrb r2,[r3]
 1250 03d6 024B     	 ldr r3,.L56
 1251 03d8 1A70     	 strb r2,[r3]
 1252              	.L23:
 251:../main.c     **** 				}
 252:../main.c     **** 			}
 253:../main.c     **** 		}
 254:../main.c     **** 	}
 255:../main.c     **** }
 1253              	 .loc 5 255 0
 1254 03da BD46     	 mov sp,r7
 1255 03dc 02B0     	 add sp,sp,#8
 1256              	 
 1257 03de 80BD     	 pop {r7,pc}
 1258              	.L57:
 1259              	 .align 2
 1260              	.L56:
 1261 03e0 00000000 	 .word led_status_pattern
 1262 03e4 00000000 	 .word led_pattern_state_timestamp.7187
 1263 03e8 00000000 	 .word led_pattern_state_length.7188
 1264 03ec 00000000 	 .word led_pattern_state.7186
 1265 03f0 00000000 	 .word fade_duty_step.7189
 1266 03f4 10270000 	 .word 10000
 1267 03f8 00000000 	 .word PWM_CCU4_LED_STATUS
 1268 03fc 00000000 	 .word led_fadesteps
 1269 0400 00000000 	 .word led_pattern_mode
 1270 0404 00000000 	 .word led_status_pattern_after_single
 1271              	 .cfi_endproc
 1272              	.LFE162:
 1274              	 .comm ReadBuffer_LTH,4,4
 1275              	 .comm ReadBuffer_UTH,4,4
 1276              	 .comm ReadBuffer_LT,4,4
 1277              	 .comm EEPROM_WriteBuffer,4,4
 1278              	 .section .text.read_eeprom_setup,"ax",%progbits
 1279              	 .align 2
 1280              	 .global read_eeprom_setup
 1281              	 .code 16
 1282              	 .thumb_func
 1284              	read_eeprom_setup:
 1285              	.LFB163:
 256:../main.c     **** 
 257:../main.c     **** //****************************************************************************
 258:../main.c     **** // read_eeprom_setup -
 259:../main.c     **** //****************************************************************************
 260:../main.c     **** uint8_t ReadBuffer_LTH[4];
 261:../main.c     **** uint8_t ReadBuffer_UTH[4];
 262:../main.c     **** uint8_t ReadBuffer_LT[4];
 263:../main.c     **** 
 264:../main.c     **** uint8_t EEPROM_WriteBuffer[4];
 265:../main.c     **** void read_eeprom_setup(void){
 1286              	 .loc 5 265 0
 1287              	 .cfi_startproc
 1288 0000 80B5     	 push {r7,lr}
 1289              	.LCFI33:
 1290              	 .cfi_def_cfa_offset 8
 1291              	 .cfi_offset 7,-8
 1292              	 .cfi_offset 14,-4
 1293 0002 00AF     	 add r7,sp,#0
 1294              	.LCFI34:
 1295              	 .cfi_def_cfa_register 7
 266:../main.c     **** 	// Read from EEPROM and interpret value
 267:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_LOWER_TH, 0, ReadBuffer_LTH, 4U);
 1296              	 .loc 5 267 0
 1297 0004 744B     	 ldr r3,.L68
 1298 0006 0120     	 mov r0,#1
 1299 0008 0021     	 mov r1,#0
 1300 000a 1A1C     	 mov r2,r3
 1301 000c 0423     	 mov r3,#4
 1302 000e FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 268:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_UPPER_TH, 0U, ReadBuffer_UTH, 4U);
 1303              	 .loc 5 268 0
 1304 0012 724B     	 ldr r3,.L68+4
 1305 0014 0220     	 mov r0,#2
 1306 0016 0021     	 mov r1,#0
 1307 0018 1A1C     	 mov r2,r3
 1308 001a 0423     	 mov r3,#4
 1309 001c FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 269:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_LATCHTIME, 0U, ReadBuffer_LT, 4U);
 1310              	 .loc 5 269 0
 1311 0020 6F4B     	 ldr r3,.L68+8
 1312 0022 0320     	 mov r0,#3
 1313 0024 0021     	 mov r1,#0
 1314 0026 1A1C     	 mov r2,r3
 1315 0028 0423     	 mov r3,#4
 1316 002a FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 270:../main.c     **** 	eeprom_lower = ReadBuffer_LTH[0] + (ReadBuffer_LTH[1] << 8) + (ReadBuffer_LTH[2] << 16) + (ReadBuf
 1317              	 .loc 5 270 0
 1318 002e 6A4B     	 ldr r3,.L68
 1319 0030 1B78     	 ldrb r3,[r3]
 1320 0032 1A1C     	 mov r2,r3
 1321 0034 684B     	 ldr r3,.L68
 1322 0036 5B78     	 ldrb r3,[r3,#1]
 1323 0038 1B02     	 lsl r3,r3,#8
 1324 003a D218     	 add r2,r2,r3
 1325 003c 664B     	 ldr r3,.L68
 1326 003e 9B78     	 ldrb r3,[r3,#2]
 1327 0040 1B04     	 lsl r3,r3,#16
 1328 0042 D218     	 add r2,r2,r3
 1329 0044 644B     	 ldr r3,.L68
 1330 0046 DB78     	 ldrb r3,[r3,#3]
 1331 0048 1B06     	 lsl r3,r3,#24
 1332 004a D218     	 add r2,r2,r3
 1333 004c 654B     	 ldr r3,.L68+12
 1334 004e 1A60     	 str r2,[r3]
 271:../main.c     **** 	eeprom_upper = ReadBuffer_UTH[0] + (ReadBuffer_UTH[1] << 8) + (ReadBuffer_UTH[2] << 16) + (ReadBuf
 1335              	 .loc 5 271 0
 1336 0050 624B     	 ldr r3,.L68+4
 1337 0052 1B78     	 ldrb r3,[r3]
 1338 0054 1A1C     	 mov r2,r3
 1339 0056 614B     	 ldr r3,.L68+4
 1340 0058 5B78     	 ldrb r3,[r3,#1]
 1341 005a 1B02     	 lsl r3,r3,#8
 1342 005c D218     	 add r2,r2,r3
 1343 005e 5F4B     	 ldr r3,.L68+4
 1344 0060 9B78     	 ldrb r3,[r3,#2]
 1345 0062 1B04     	 lsl r3,r3,#16
 1346 0064 D218     	 add r2,r2,r3
 1347 0066 5D4B     	 ldr r3,.L68+4
 1348 0068 DB78     	 ldrb r3,[r3,#3]
 1349 006a 1B06     	 lsl r3,r3,#24
 1350 006c D218     	 add r2,r2,r3
 1351 006e 5E4B     	 ldr r3,.L68+16
 1352 0070 1A60     	 str r2,[r3]
 272:../main.c     **** 	eeprom_latchtime = ReadBuffer_LT[0] + (ReadBuffer_LT[1] << 8) + (ReadBuffer_LT[2] << 16) + (ReadBu
 1353              	 .loc 5 272 0
 1354 0072 5B4B     	 ldr r3,.L68+8
 1355 0074 1B78     	 ldrb r3,[r3]
 1356 0076 1A1C     	 mov r2,r3
 1357 0078 594B     	 ldr r3,.L68+8
 1358 007a 5B78     	 ldrb r3,[r3,#1]
 1359 007c 1B02     	 lsl r3,r3,#8
 1360 007e D218     	 add r2,r2,r3
 1361 0080 574B     	 ldr r3,.L68+8
 1362 0082 9B78     	 ldrb r3,[r3,#2]
 1363 0084 1B04     	 lsl r3,r3,#16
 1364 0086 D218     	 add r2,r2,r3
 1365 0088 554B     	 ldr r3,.L68+8
 1366 008a DB78     	 ldrb r3,[r3,#3]
 1367 008c 1B06     	 lsl r3,r3,#24
 1368 008e D218     	 add r2,r2,r3
 1369 0090 564B     	 ldr r3,.L68+20
 1370 0092 1A60     	 str r2,[r3]
 273:../main.c     **** 
 274:../main.c     **** 	// Check if values make sense, else return to default
 275:../main.c     **** 	if(eeprom_upper < 0 || eeprom_upper > ADC_THRESHOLD_MAX){
 1371              	 .loc 5 275 0
 1372 0094 544B     	 ldr r3,.L68+16
 1373 0096 1B68     	 ldr r3,[r3]
 1374 0098 002B     	 cmp r3,#0
 1375 009a 04DB     	 blt .L59
 1376              	 .loc 5 275 0 is_stmt 0 discriminator 1
 1377 009c 524B     	 ldr r3,.L68+16
 1378 009e 1B68     	 ldr r3,[r3]
 1379 00a0 534A     	 ldr r2,.L68+24
 1380 00a2 9342     	 cmp r3,r2
 1381 00a4 27DD     	 ble .L60
 1382              	.L59:
 276:../main.c     **** 		ADC_upper_threshold = ADC_TH_UPPER_DEFAULT;
 1383              	 .loc 5 276 0 is_stmt 1
 1384 00a6 534B     	 ldr r3,.L68+28
 1385 00a8 534A     	 ldr r2,.L68+32
 1386 00aa 1A60     	 str r2,[r3]
 277:../main.c     **** 		// Blink LED for error indication
 278:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1387              	 .loc 5 278 0
 1388 00ac 534B     	 ldr r3,.L68+36
 1389 00ae 181C     	 mov r0,r3
 1390 00b0 0021     	 mov r1,#0
 1391 00b2 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 279:../main.c     **** 		delay_ms(200);
 1392              	 .loc 5 279 0
 1393 00b6 C820     	 mov r0,#200
 1394 00b8 FFF7FEFF 	 bl delay_ms
 280:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1395              	 .loc 5 280 0
 1396 00bc 4F4B     	 ldr r3,.L68+36
 1397 00be 504A     	 ldr r2,.L68+40
 1398 00c0 181C     	 mov r0,r3
 1399 00c2 111C     	 mov r1,r2
 1400 00c4 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 281:../main.c     **** 		delay_ms(200);
 1401              	 .loc 5 281 0
 1402 00c8 C820     	 mov r0,#200
 1403 00ca FFF7FEFF 	 bl delay_ms
 282:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1404              	 .loc 5 282 0
 1405 00ce 4B4B     	 ldr r3,.L68+36
 1406 00d0 181C     	 mov r0,r3
 1407 00d2 0021     	 mov r1,#0
 1408 00d4 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 283:../main.c     **** 		delay_ms(200);
 1409              	 .loc 5 283 0
 1410 00d8 C820     	 mov r0,#200
 1411 00da FFF7FEFF 	 bl delay_ms
 284:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1412              	 .loc 5 284 0
 1413 00de 474B     	 ldr r3,.L68+36
 1414 00e0 474A     	 ldr r2,.L68+40
 1415 00e2 181C     	 mov r0,r3
 1416 00e4 111C     	 mov r1,r2
 1417 00e6 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 285:../main.c     **** 		delay_ms(600);
 1418              	 .loc 5 285 0
 1419 00ea 9623     	 mov r3,#150
 1420 00ec 9B00     	 lsl r3,r3,#2
 1421 00ee 181C     	 mov r0,r3
 1422 00f0 FFF7FEFF 	 bl delay_ms
 1423 00f4 03E0     	 b .L61
 1424              	.L60:
 286:../main.c     **** 	}
 287:../main.c     **** 	else{
 288:../main.c     **** 		ADC_upper_threshold = eeprom_upper;
 1425              	 .loc 5 288 0
 1426 00f6 3C4B     	 ldr r3,.L68+16
 1427 00f8 1A68     	 ldr r2,[r3]
 1428 00fa 3E4B     	 ldr r3,.L68+28
 1429 00fc 1A60     	 str r2,[r3]
 1430              	.L61:
 289:../main.c     **** 	}
 290:../main.c     **** 	if(eeprom_lower < 0 || eeprom_lower > ADC_THRESHOLD_MAX){
 1431              	 .loc 5 290 0
 1432 00fe 394B     	 ldr r3,.L68+12
 1433 0100 1B68     	 ldr r3,[r3]
 1434 0102 002B     	 cmp r3,#0
 1435 0104 04DB     	 blt .L62
 1436              	 .loc 5 290 0 is_stmt 0 discriminator 1
 1437 0106 374B     	 ldr r3,.L68+12
 1438 0108 1B68     	 ldr r3,[r3]
 1439 010a 394A     	 ldr r2,.L68+24
 1440 010c 9342     	 cmp r3,r2
 1441 010e 27DD     	 ble .L63
 1442              	.L62:
 291:../main.c     **** 		ADC_lower_threshold = ADC_TH_LOWER_DEFAULT;
 1443              	 .loc 5 291 0 is_stmt 1
 1444 0110 3C4B     	 ldr r3,.L68+44
 1445 0112 3D4A     	 ldr r2,.L68+48
 1446 0114 1A60     	 str r2,[r3]
 292:../main.c     **** 		// Blink LED for error indication
 293:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1447              	 .loc 5 293 0
 1448 0116 394B     	 ldr r3,.L68+36
 1449 0118 181C     	 mov r0,r3
 1450 011a 0021     	 mov r1,#0
 1451 011c FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 294:../main.c     **** 		delay_ms(200);
 1452              	 .loc 5 294 0
 1453 0120 C820     	 mov r0,#200
 1454 0122 FFF7FEFF 	 bl delay_ms
 295:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1455              	 .loc 5 295 0
 1456 0126 354B     	 ldr r3,.L68+36
 1457 0128 354A     	 ldr r2,.L68+40
 1458 012a 181C     	 mov r0,r3
 1459 012c 111C     	 mov r1,r2
 1460 012e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 296:../main.c     **** 		delay_ms(200);
 1461              	 .loc 5 296 0
 1462 0132 C820     	 mov r0,#200
 1463 0134 FFF7FEFF 	 bl delay_ms
 297:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1464              	 .loc 5 297 0
 1465 0138 304B     	 ldr r3,.L68+36
 1466 013a 181C     	 mov r0,r3
 1467 013c 0021     	 mov r1,#0
 1468 013e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 298:../main.c     **** 		delay_ms(200);
 1469              	 .loc 5 298 0
 1470 0142 C820     	 mov r0,#200
 1471 0144 FFF7FEFF 	 bl delay_ms
 299:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1472              	 .loc 5 299 0
 1473 0148 2C4B     	 ldr r3,.L68+36
 1474 014a 2D4A     	 ldr r2,.L68+40
 1475 014c 181C     	 mov r0,r3
 1476 014e 111C     	 mov r1,r2
 1477 0150 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 300:../main.c     **** 		delay_ms(600);
 1478              	 .loc 5 300 0
 1479 0154 9623     	 mov r3,#150
 1480 0156 9B00     	 lsl r3,r3,#2
 1481 0158 181C     	 mov r0,r3
 1482 015a FFF7FEFF 	 bl delay_ms
 1483 015e 03E0     	 b .L64
 1484              	.L63:
 301:../main.c     **** 	}
 302:../main.c     **** 	else{
 303:../main.c     **** 		ADC_lower_threshold = eeprom_lower;
 1485              	 .loc 5 303 0
 1486 0160 204B     	 ldr r3,.L68+12
 1487 0162 1A68     	 ldr r2,[r3]
 1488 0164 274B     	 ldr r3,.L68+44
 1489 0166 1A60     	 str r2,[r3]
 1490              	.L64:
 304:../main.c     **** 	}
 305:../main.c     **** 	if(eeprom_latchtime < 0 || eeprom_latchtime > ADC_THRESHOLD_MAX){
 1491              	 .loc 5 305 0
 1492 0168 204B     	 ldr r3,.L68+20
 1493 016a 1B68     	 ldr r3,[r3]
 1494 016c 002B     	 cmp r3,#0
 1495 016e 04DB     	 blt .L65
 1496              	 .loc 5 305 0 is_stmt 0 discriminator 1
 1497 0170 1E4B     	 ldr r3,.L68+20
 1498 0172 1B68     	 ldr r3,[r3]
 1499 0174 1E4A     	 ldr r2,.L68+24
 1500 0176 9342     	 cmp r3,r2
 1501 0178 28DD     	 ble .L66
 1502              	.L65:
 306:../main.c     **** 		relay_threshold_latchtime = RELAY_LATCHTIME_DEFAULT;
 1503              	 .loc 5 306 0 is_stmt 1
 1504 017a 244B     	 ldr r3,.L68+52
 1505 017c FA22     	 mov r2,#250
 1506 017e 5200     	 lsl r2,r2,#1
 1507 0180 1A60     	 str r2,[r3]
 307:../main.c     **** 		// Blink LED for error indication
 308:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1508              	 .loc 5 308 0
 1509 0182 1E4B     	 ldr r3,.L68+36
 1510 0184 181C     	 mov r0,r3
 1511 0186 0021     	 mov r1,#0
 1512 0188 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 309:../main.c     **** 		delay_ms(200);
 1513              	 .loc 5 309 0
 1514 018c C820     	 mov r0,#200
 1515 018e FFF7FEFF 	 bl delay_ms
 310:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1516              	 .loc 5 310 0
 1517 0192 1A4B     	 ldr r3,.L68+36
 1518 0194 1A4A     	 ldr r2,.L68+40
 1519 0196 181C     	 mov r0,r3
 1520 0198 111C     	 mov r1,r2
 1521 019a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 311:../main.c     **** 		delay_ms(200);
 1522              	 .loc 5 311 0
 1523 019e C820     	 mov r0,#200
 1524 01a0 FFF7FEFF 	 bl delay_ms
 312:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1525              	 .loc 5 312 0
 1526 01a4 154B     	 ldr r3,.L68+36
 1527 01a6 181C     	 mov r0,r3
 1528 01a8 0021     	 mov r1,#0
 1529 01aa FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 313:../main.c     **** 		delay_ms(200);
 1530              	 .loc 5 313 0
 1531 01ae C820     	 mov r0,#200
 1532 01b0 FFF7FEFF 	 bl delay_ms
 314:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1533              	 .loc 5 314 0
 1534 01b4 114B     	 ldr r3,.L68+36
 1535 01b6 124A     	 ldr r2,.L68+40
 1536 01b8 181C     	 mov r0,r3
 1537 01ba 111C     	 mov r1,r2
 1538 01bc FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 315:../main.c     **** 		delay_ms(300);
 1539              	 .loc 5 315 0
 1540 01c0 9623     	 mov r3,#150
 1541 01c2 5B00     	 lsl r3,r3,#1
 1542 01c4 181C     	 mov r0,r3
 1543 01c6 FFF7FEFF 	 bl delay_ms
 1544 01ca 03E0     	 b .L58
 1545              	.L66:
 316:../main.c     **** 	}
 317:../main.c     **** 	else{
 318:../main.c     **** 		relay_threshold_latchtime = eeprom_latchtime;
 1546              	 .loc 5 318 0
 1547 01cc 074B     	 ldr r3,.L68+20
 1548 01ce 1A68     	 ldr r2,[r3]
 1549 01d0 0E4B     	 ldr r3,.L68+52
 1550 01d2 1A60     	 str r2,[r3]
 1551              	.L58:
 319:../main.c     **** 	}
 320:../main.c     **** 
 321:../main.c     **** 	//int32_t temp = 100001;
 322:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp;
 323:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp >> 8);
 324:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(temp >> 16);
 325:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(temp >> 24);
 326:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_LOWER_TH, EEPROM_WriteBuffer);
 327:../main.c     **** 	//
 328:../main.c     **** 	//temp = 100002;
 329:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp;
 330:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp >> 8);
 331:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(temp >> 16);
 332:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(temp >> 24);
 333:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_UPPER_TH, EEPROM_WriteBuffer);
 334:../main.c     **** 	//
 335:../main.c     **** 	//uint16_t temp16 = 1015;
 336:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp16;
 337:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp16 >> 8);
 338:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_LATCHTIME, EEPROM_WriteBuffer);
 339:../main.c     **** }
 1552              	 .loc 5 339 0
 1553 01d4 BD46     	 mov sp,r7
 1554              	 
 1555 01d6 80BD     	 pop {r7,pc}
 1556              	.L69:
 1557              	 .align 2
 1558              	.L68:
 1559 01d8 00000000 	 .word ReadBuffer_LTH
 1560 01dc 00000000 	 .word ReadBuffer_UTH
 1561 01e0 00000000 	 .word ReadBuffer_LT
 1562 01e4 00000000 	 .word eeprom_lower
 1563 01e8 00000000 	 .word eeprom_upper
 1564 01ec 00000000 	 .word eeprom_latchtime
 1565 01f0 FF0F0000 	 .word 4095
 1566 01f4 00000000 	 .word ADC_upper_threshold
 1567 01f8 B60D0000 	 .word 3510
 1568 01fc 00000000 	 .word PWM_CCU4_LED_STATUS
 1569 0200 10270000 	 .word 10000
 1570 0204 00000000 	 .word ADC_lower_threshold
 1571 0208 49020000 	 .word 585
 1572 020c 00000000 	 .word relay_threshold_latchtime
 1573              	 .cfi_endproc
 1574              	.LFE163:
 1576              	 .section .text.write_eeprom_setup,"ax",%progbits
 1577              	 .align 2
 1578              	 .global write_eeprom_setup
 1579              	 .code 16
 1580              	 .thumb_func
 1582              	write_eeprom_setup:
 1583              	.LFB164:
 340:../main.c     **** 
 341:../main.c     **** void write_eeprom_setup(uint8_t block_number, int32_t value){
 1584              	 .loc 5 341 0
 1585              	 .cfi_startproc
 1586 0000 80B5     	 push {r7,lr}
 1587              	.LCFI35:
 1588              	 .cfi_def_cfa_offset 8
 1589              	 .cfi_offset 7,-8
 1590              	 .cfi_offset 14,-4
 1591 0002 82B0     	 sub sp,sp,#8
 1592              	.LCFI36:
 1593              	 .cfi_def_cfa_offset 16
 1594 0004 00AF     	 add r7,sp,#0
 1595              	.LCFI37:
 1596              	 .cfi_def_cfa_register 7
 1597 0006 021C     	 mov r2,r0
 1598 0008 3960     	 str r1,[r7]
 1599 000a FB1D     	 add r3,r7,#7
 1600 000c 1A70     	 strb r2,[r3]
 342:../main.c     **** 	EEPROM_WriteBuffer[0] = (uint8_t)value;
 1601              	 .loc 5 342 0
 1602 000e 3B68     	 ldr r3,[r7]
 1603 0010 DAB2     	 uxtb r2,r3
 1604 0012 0D4B     	 ldr r3,.L71
 1605 0014 1A70     	 strb r2,[r3]
 343:../main.c     **** 	EEPROM_WriteBuffer[1] = (uint8_t)(value >> 8);
 1606              	 .loc 5 343 0
 1607 0016 3B68     	 ldr r3,[r7]
 1608 0018 1B12     	 asr r3,r3,#8
 1609 001a DAB2     	 uxtb r2,r3
 1610 001c 0A4B     	 ldr r3,.L71
 1611 001e 5A70     	 strb r2,[r3,#1]
 344:../main.c     **** 	EEPROM_WriteBuffer[2] = (uint8_t)(value >> 16);
 1612              	 .loc 5 344 0
 1613 0020 3B68     	 ldr r3,[r7]
 1614 0022 1B14     	 asr r3,r3,#16
 1615 0024 DAB2     	 uxtb r2,r3
 1616 0026 084B     	 ldr r3,.L71
 1617 0028 9A70     	 strb r2,[r3,#2]
 345:../main.c     **** 	EEPROM_WriteBuffer[3] = (uint8_t)(value >> 24);
 1618              	 .loc 5 345 0
 1619 002a 3B68     	 ldr r3,[r7]
 1620 002c 1B16     	 asr r3,r3,#24
 1621 002e DAB2     	 uxtb r2,r3
 1622 0030 054B     	 ldr r3,.L71
 1623 0032 DA70     	 strb r2,[r3,#3]
 346:../main.c     **** 	E_EEPROM_XMC1_Write(block_number, EEPROM_WriteBuffer);
 1624              	 .loc 5 346 0
 1625 0034 FB1D     	 add r3,r7,#7
 1626 0036 1A78     	 ldrb r2,[r3]
 1627 0038 034B     	 ldr r3,.L71
 1628 003a 101C     	 mov r0,r2
 1629 003c 191C     	 mov r1,r3
 1630 003e FFF7FEFF 	 bl E_EEPROM_XMC1_Write
 347:../main.c     **** 
 348:../main.c     **** }
 1631              	 .loc 5 348 0
 1632 0042 BD46     	 mov sp,r7
 1633 0044 02B0     	 add sp,sp,#8
 1634              	 
 1635 0046 80BD     	 pop {r7,pc}
 1636              	.L72:
 1637              	 .align 2
 1638              	.L71:
 1639 0048 00000000 	 .word EEPROM_WriteBuffer
 1640              	 .cfi_endproc
 1641              	.LFE164:
 1643              	 .section .text.manage_buttons,"ax",%progbits
 1644              	 .align 2
 1645              	 .global manage_buttons
 1646              	 .code 16
 1647              	 .thumb_func
 1649              	manage_buttons:
 1650              	.LFB165:
 349:../main.c     **** 
 350:../main.c     **** //****************************************************************************
 351:../main.c     **** // manage_buttons - function to manage, debounce and interpret button presses
 352:../main.c     **** //****************************************************************************
 353:../main.c     **** void manage_buttons(void)
 354:../main.c     **** {
 1651              	 .loc 5 354 0
 1652              	 .cfi_startproc
 1653 0000 80B5     	 push {r7,lr}
 1654              	.LCFI38:
 1655              	 .cfi_def_cfa_offset 8
 1656              	 .cfi_offset 7,-8
 1657              	 .cfi_offset 14,-4
 1658 0002 00AF     	 add r7,sp,#0
 1659              	.LCFI39:
 1660              	 .cfi_def_cfa_register 7
 355:../main.c     **** 	/// Detect start of press and save current system time
 356:../main.c     **** 	if(button_usb_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_ON)
 1661              	 .loc 5 356 0
 1662 0004 8F4B     	 ldr r3,.L92
 1663 0006 1B68     	 ldr r3,[r3]
 1664 0008 002B     	 cmp r3,#0
 1665 000a 0AD1     	 bne .L74
 1666              	 .loc 5 356 0 is_stmt 0 discriminator 1
 1667 000c 8E4B     	 ldr r3,.L92+4
 1668 000e 181C     	 mov r0,r3
 1669 0010 FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1670 0014 031E     	 sub r3,r0,#0
 1671 0016 04D1     	 bne .L74
 357:../main.c     **** 		button_usb_pressed_timestamp = SYSTIMER_GetTime();
 1672              	 .loc 5 357 0 is_stmt 1
 1673 0018 FFF7FEFF 	 bl SYSTIMER_GetTime
 1674 001c 021C     	 mov r2,r0
 1675 001e 894B     	 ldr r3,.L92
 1676 0020 1A60     	 str r2,[r3]
 1677              	.L74:
 358:../main.c     **** 	if(button_up_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_ON)
 1678              	 .loc 5 358 0
 1679 0022 8A4B     	 ldr r3,.L92+8
 1680 0024 1B68     	 ldr r3,[r3]
 1681 0026 002B     	 cmp r3,#0
 1682 0028 0AD1     	 bne .L75
 1683              	 .loc 5 358 0 is_stmt 0 discriminator 1
 1684 002a 894B     	 ldr r3,.L92+12
 1685 002c 181C     	 mov r0,r3
 1686 002e FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1687 0032 031E     	 sub r3,r0,#0
 1688 0034 04D1     	 bne .L75
 359:../main.c     **** 		button_up_pressed_timestamp = SYSTIMER_GetTime();
 1689              	 .loc 5 359 0 is_stmt 1
 1690 0036 FFF7FEFF 	 bl SYSTIMER_GetTime
 1691 003a 021C     	 mov r2,r0
 1692 003c 834B     	 ldr r3,.L92+8
 1693 003e 1A60     	 str r2,[r3]
 1694              	.L75:
 360:../main.c     **** 	if(button_down_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_ON)
 1695              	 .loc 5 360 0
 1696 0040 844B     	 ldr r3,.L92+16
 1697 0042 1B68     	 ldr r3,[r3]
 1698 0044 002B     	 cmp r3,#0
 1699 0046 0AD1     	 bne .L76
 1700              	 .loc 5 360 0 is_stmt 0 discriminator 1
 1701 0048 834B     	 ldr r3,.L92+20
 1702 004a 181C     	 mov r0,r3
 1703 004c FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1704 0050 031E     	 sub r3,r0,#0
 1705 0052 04D1     	 bne .L76
 361:../main.c     **** 		button_down_pressed_timestamp = SYSTIMER_GetTime();
 1706              	 .loc 5 361 0 is_stmt 1
 1707 0054 FFF7FEFF 	 bl SYSTIMER_GetTime
 1708 0058 021C     	 mov r2,r0
 1709 005a 7E4B     	 ldr r3,.L92+16
 1710 005c 1A60     	 str r2,[r3]
 1711              	.L76:
 362:../main.c     **** 
 363:../main.c     **** 	// USB BUTTON: If a press in ongoing and release is detected, calculate time difference
 364:../main.c     **** 	if(button_usb_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_OFF){
 1712              	 .loc 5 364 0
 1713 005e 794B     	 ldr r3,.L92
 1714 0060 1B68     	 ldr r3,[r3]
 1715 0062 002B     	 cmp r3,#0
 1716 0064 33D0     	 beq .L77
 1717              	 .loc 5 364 0 is_stmt 0 discriminator 1
 1718 0066 784B     	 ldr r3,.L92+4
 1719 0068 181C     	 mov r0,r3
 1720 006a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1721 006e 031E     	 sub r3,r0,#0
 1722 0070 012B     	 cmp r3,#1
 1723 0072 2CD1     	 bne .L77
 365:../main.c     **** 		button_usb_pressed_duration = (SYSTIMER_GetTime() - button_usb_pressed_timestamp) / 1000; // conv
 1724              	 .loc 5 365 0 is_stmt 1
 1725 0074 FFF7FEFF 	 bl SYSTIMER_GetTime
 1726 0078 021C     	 mov r2,r0
 1727 007a 724B     	 ldr r3,.L92
 1728 007c 1B68     	 ldr r3,[r3]
 1729 007e D31A     	 sub r3,r2,r3
 1730 0080 181C     	 mov r0,r3
 1731 0082 FA23     	 mov r3,#250
 1732 0084 9900     	 lsl r1,r3,#2
 1733 0086 FFF7FEFF 	 bl __aeabi_uidiv
 1734 008a 031C     	 mov r3,r0
 1735 008c 9AB2     	 uxth r2,r3
 1736 008e 734B     	 ldr r3,.L92+24
 1737 0090 1A80     	 strh r2,[r3]
 366:../main.c     **** 		button_usb_pressed_timestamp = 0;
 1738              	 .loc 5 366 0
 1739 0092 6C4B     	 ldr r3,.L92
 1740 0094 0022     	 mov r2,#0
 1741 0096 1A60     	 str r2,[r3]
 367:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 368:../main.c     **** 		if(button_usb_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1742              	 .loc 5 368 0
 1743 0098 704B     	 ldr r3,.L92+24
 1744 009a 1B88     	 ldrh r3,[r3]
 1745 009c 704A     	 ldr r2,.L92+28
 1746 009e 9342     	 cmp r3,r2
 1747 00a0 03D9     	 bls .L78
 369:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1748              	 .loc 5 369 0
 1749 00a2 704B     	 ldr r3,.L92+32
 1750 00a4 0022     	 mov r2,#0
 1751 00a6 1A70     	 strb r2,[r3]
 1752 00a8 10E0     	 b .L79
 1753              	.L78:
 370:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1754              	 .loc 5 370 0
 1755 00aa 6C4B     	 ldr r3,.L92+24
 1756 00ac 1B88     	 ldrh r3,[r3]
 1757 00ae 6E4A     	 ldr r2,.L92+36
 1758 00b0 9342     	 cmp r3,r2
 1759 00b2 03D9     	 bls .L80
 371:../main.c     **** 			buttonpress_usb = BTNPRESS_LONG;
 1760              	 .loc 5 371 0
 1761 00b4 6B4B     	 ldr r3,.L92+32
 1762 00b6 0222     	 mov r2,#2
 1763 00b8 1A70     	 strb r2,[r3]
 1764 00ba 07E0     	 b .L79
 1765              	.L80:
 372:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_STD_PRESS_DURATION)
 1766              	 .loc 5 372 0
 1767 00bc 674B     	 ldr r3,.L92+24
 1768 00be 1B88     	 ldrh r3,[r3]
 1769 00c0 3B2B     	 cmp r3,#59
 1770 00c2 03D9     	 bls .L79
 373:../main.c     **** 			buttonpress_usb = BTNPRESS_STD;
 1771              	 .loc 5 373 0
 1772 00c4 674B     	 ldr r3,.L92+32
 1773 00c6 0122     	 mov r2,#1
 1774 00c8 1A70     	 strb r2,[r3]
 368:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1775              	 .loc 5 368 0
 1776 00ca 18E0     	 b .L81
 1777              	.L79:
 1778 00cc 17E0     	 b .L81
 1779              	.L77:
 374:../main.c     **** 	}
 375:../main.c     **** 	// USB BUTTON: If press is to long reset (simulate that press ended)
 376:../main.c     **** 	else if(button_usb_pressed_timestamp != 0 && button_usb_pressed_timestamp != TIMESTAMP_DEACTIVATED
 1780              	 .loc 5 376 0
 1781 00ce 5D4B     	 ldr r3,.L92
 1782 00d0 1B68     	 ldr r3,[r3]
 1783 00d2 002B     	 cmp r3,#0
 1784 00d4 13D0     	 beq .L81
 1785              	 .loc 5 376 0 is_stmt 0 discriminator 1
 1786 00d6 5B4B     	 ldr r3,.L92
 1787 00d8 1B68     	 ldr r3,[r3]
 1788 00da 0133     	 add r3,r3,#1
 1789 00dc 0FD0     	 beq .L81
 1790              	 .loc 5 376 0 discriminator 2
 1791 00de FFF7FEFF 	 bl SYSTIMER_GetTime
 1792 00e2 021C     	 mov r2,r0
 1793 00e4 574B     	 ldr r3,.L92
 1794 00e6 1B68     	 ldr r3,[r3]
 1795 00e8 D31A     	 sub r3,r2,r3
 1796 00ea 604A     	 ldr r2,.L92+40
 1797 00ec 9342     	 cmp r3,r2
 1798 00ee 06D9     	 bls .L81
 377:../main.c     **** 		button_usb_pressed_timestamp = TIMESTAMP_DEACTIVATED; // deactivate timestamp till button is rele
 1799              	 .loc 5 377 0 is_stmt 1
 1800 00f0 544B     	 ldr r3,.L92
 1801 00f2 0122     	 mov r2,#1
 1802 00f4 5242     	 neg r2,r2
 1803 00f6 1A60     	 str r2,[r3]
 378:../main.c     **** 		buttonpress_usb = BTNPRESS_LONGEST;
 1804              	 .loc 5 378 0
 1805 00f8 5A4B     	 ldr r3,.L92+32
 1806 00fa 0322     	 mov r2,#3
 1807 00fc 1A70     	 strb r2,[r3]
 1808              	.L81:
 379:../main.c     **** 	}
 380:../main.c     **** 
 381:../main.c     **** 	// UP BUTTON: If a press in ongoing and release is detected, calculate time difference
 382:../main.c     **** 	if(button_up_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_OFF){
 1809              	 .loc 5 382 0
 1810 00fe 534B     	 ldr r3,.L92+8
 1811 0100 1B68     	 ldr r3,[r3]
 1812 0102 002B     	 cmp r3,#0
 1813 0104 33D0     	 beq .L82
 1814              	 .loc 5 382 0 is_stmt 0 discriminator 1
 1815 0106 524B     	 ldr r3,.L92+12
 1816 0108 181C     	 mov r0,r3
 1817 010a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1818 010e 031E     	 sub r3,r0,#0
 1819 0110 012B     	 cmp r3,#1
 1820 0112 2CD1     	 bne .L82
 383:../main.c     **** 		button_up_pressed_duration = (SYSTIMER_GetTime() - button_up_pressed_timestamp) / 1000; // conver
 1821              	 .loc 5 383 0 is_stmt 1
 1822 0114 FFF7FEFF 	 bl SYSTIMER_GetTime
 1823 0118 021C     	 mov r2,r0
 1824 011a 4C4B     	 ldr r3,.L92+8
 1825 011c 1B68     	 ldr r3,[r3]
 1826 011e D31A     	 sub r3,r2,r3
 1827 0120 181C     	 mov r0,r3
 1828 0122 FA23     	 mov r3,#250
 1829 0124 9900     	 lsl r1,r3,#2
 1830 0126 FFF7FEFF 	 bl __aeabi_uidiv
 1831 012a 031C     	 mov r3,r0
 1832 012c 9AB2     	 uxth r2,r3
 1833 012e 504B     	 ldr r3,.L92+44
 1834 0130 1A80     	 strh r2,[r3]
 384:../main.c     **** 		button_up_pressed_timestamp = 0;
 1835              	 .loc 5 384 0
 1836 0132 464B     	 ldr r3,.L92+8
 1837 0134 0022     	 mov r2,#0
 1838 0136 1A60     	 str r2,[r3]
 385:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 386:../main.c     **** 		if(button_up_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1839              	 .loc 5 386 0
 1840 0138 4D4B     	 ldr r3,.L92+44
 1841 013a 1B88     	 ldrh r3,[r3]
 1842 013c 484A     	 ldr r2,.L92+28
 1843 013e 9342     	 cmp r3,r2
 1844 0140 03D9     	 bls .L83
 387:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1845              	 .loc 5 387 0
 1846 0142 4C4B     	 ldr r3,.L92+48
 1847 0144 0022     	 mov r2,#0
 1848 0146 1A70     	 strb r2,[r3]
 1849 0148 10E0     	 b .L84
 1850              	.L83:
 388:../main.c     **** 		else if(button_up_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1851              	 .loc 5 388 0
 1852 014a 494B     	 ldr r3,.L92+44
 1853 014c 1B88     	 ldrh r3,[r3]
 1854 014e 464A     	 ldr r2,.L92+36
 1855 0150 9342     	 cmp r3,r2
 1856 0152 03D9     	 bls .L85
 389:../main.c     **** 			buttonpress_up = BTNPRESS_LONG;
 1857              	 .loc 5 389 0
 1858 0154 474B     	 ldr r3,.L92+48
 1859 0156 0222     	 mov r2,#2
 1860 0158 1A70     	 strb r2,[r3]
 1861 015a 07E0     	 b .L84
 1862              	.L85:
 390:../main.c     **** 		else if(button_up_pressed_duration >= BTN_STD_PRESS_DURATION)
 1863              	 .loc 5 390 0
 1864 015c 444B     	 ldr r3,.L92+44
 1865 015e 1B88     	 ldrh r3,[r3]
 1866 0160 3B2B     	 cmp r3,#59
 1867 0162 03D9     	 bls .L84
 391:../main.c     **** 			buttonpress_up = BTNPRESS_STD;
 1868              	 .loc 5 391 0
 1869 0164 434B     	 ldr r3,.L92+48
 1870 0166 0122     	 mov r2,#1
 1871 0168 1A70     	 strb r2,[r3]
 386:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1872              	 .loc 5 386 0
 1873 016a 18E0     	 b .L86
 1874              	.L84:
 1875 016c 17E0     	 b .L86
 1876              	.L82:
 392:../main.c     **** 
 393:../main.c     **** 	}
 394:../main.c     **** 	// UP BUTTON: If press is to long reset (simulate that press ended)
 395:../main.c     **** 	else if(button_up_pressed_timestamp != 0 && button_up_pressed_timestamp != TIMESTAMP_DEACTIVATED &
 1877              	 .loc 5 395 0
 1878 016e 374B     	 ldr r3,.L92+8
 1879 0170 1B68     	 ldr r3,[r3]
 1880 0172 002B     	 cmp r3,#0
 1881 0174 13D0     	 beq .L86
 1882              	 .loc 5 395 0 is_stmt 0 discriminator 1
 1883 0176 354B     	 ldr r3,.L92+8
 1884 0178 1B68     	 ldr r3,[r3]
 1885 017a 0133     	 add r3,r3,#1
 1886 017c 0FD0     	 beq .L86
 1887              	 .loc 5 395 0 discriminator 2
 1888 017e FFF7FEFF 	 bl SYSTIMER_GetTime
 1889 0182 021C     	 mov r2,r0
 1890 0184 314B     	 ldr r3,.L92+8
 1891 0186 1B68     	 ldr r3,[r3]
 1892 0188 D31A     	 sub r3,r2,r3
 1893 018a 384A     	 ldr r2,.L92+40
 1894 018c 9342     	 cmp r3,r2
 1895 018e 06D9     	 bls .L86
 396:../main.c     **** 		button_up_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 1896              	 .loc 5 396 0 is_stmt 1
 1897 0190 2E4B     	 ldr r3,.L92+8
 1898 0192 0122     	 mov r2,#1
 1899 0194 5242     	 neg r2,r2
 1900 0196 1A60     	 str r2,[r3]
 397:../main.c     **** 		buttonpress_up = BTNPRESS_LONGEST;
 1901              	 .loc 5 397 0
 1902 0198 364B     	 ldr r3,.L92+48
 1903 019a 0322     	 mov r2,#3
 1904 019c 1A70     	 strb r2,[r3]
 1905              	.L86:
 398:../main.c     **** 	}
 399:../main.c     **** 
 400:../main.c     **** 	// DOWN BUTTON: If a press in ongoing and release is detected, calculate time difference
 401:../main.c     **** 	if(button_down_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_OFF){
 1906              	 .loc 5 401 0
 1907 019e 2D4B     	 ldr r3,.L92+16
 1908 01a0 1B68     	 ldr r3,[r3]
 1909 01a2 002B     	 cmp r3,#0
 1910 01a4 33D0     	 beq .L87
 1911              	 .loc 5 401 0 is_stmt 0 discriminator 1
 1912 01a6 2C4B     	 ldr r3,.L92+20
 1913 01a8 181C     	 mov r0,r3
 1914 01aa FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1915 01ae 031E     	 sub r3,r0,#0
 1916 01b0 012B     	 cmp r3,#1
 1917 01b2 2CD1     	 bne .L87
 402:../main.c     **** 		button_down_pressed_duration = (SYSTIMER_GetTime() - button_down_pressed_timestamp) / 1000; // co
 1918              	 .loc 5 402 0 is_stmt 1
 1919 01b4 FFF7FEFF 	 bl SYSTIMER_GetTime
 1920 01b8 021C     	 mov r2,r0
 1921 01ba 264B     	 ldr r3,.L92+16
 1922 01bc 1B68     	 ldr r3,[r3]
 1923 01be D31A     	 sub r3,r2,r3
 1924 01c0 181C     	 mov r0,r3
 1925 01c2 FA23     	 mov r3,#250
 1926 01c4 9900     	 lsl r1,r3,#2
 1927 01c6 FFF7FEFF 	 bl __aeabi_uidiv
 1928 01ca 031C     	 mov r3,r0
 1929 01cc 9AB2     	 uxth r2,r3
 1930 01ce 2A4B     	 ldr r3,.L92+52
 1931 01d0 1A80     	 strh r2,[r3]
 403:../main.c     **** 		button_down_pressed_timestamp = 0;
 1932              	 .loc 5 403 0
 1933 01d2 204B     	 ldr r3,.L92+16
 1934 01d4 0022     	 mov r2,#0
 1935 01d6 1A60     	 str r2,[r3]
 404:../main.c     **** 		// Interpret button press and activate "button pressed" marker. The code that is reacting to it m
 405:../main.c     **** 		if(button_down_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1936              	 .loc 5 405 0
 1937 01d8 274B     	 ldr r3,.L92+52
 1938 01da 1B88     	 ldrh r3,[r3]
 1939 01dc 204A     	 ldr r2,.L92+28
 1940 01de 9342     	 cmp r3,r2
 1941 01e0 03D9     	 bls .L88
 406:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 1942              	 .loc 5 406 0
 1943 01e2 264B     	 ldr r3,.L92+56
 1944 01e4 0022     	 mov r2,#0
 1945 01e6 1A70     	 strb r2,[r3]
 1946 01e8 10E0     	 b .L89
 1947              	.L88:
 407:../main.c     **** 		else if(button_down_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1948              	 .loc 5 407 0
 1949 01ea 234B     	 ldr r3,.L92+52
 1950 01ec 1B88     	 ldrh r3,[r3]
 1951 01ee 1E4A     	 ldr r2,.L92+36
 1952 01f0 9342     	 cmp r3,r2
 1953 01f2 03D9     	 bls .L90
 408:../main.c     **** 			buttonpress_down = BTNPRESS_LONG;
 1954              	 .loc 5 408 0
 1955 01f4 214B     	 ldr r3,.L92+56
 1956 01f6 0222     	 mov r2,#2
 1957 01f8 1A70     	 strb r2,[r3]
 1958 01fa 07E0     	 b .L89
 1959              	.L90:
 409:../main.c     **** 		else if(button_down_pressed_duration >= BTN_STD_PRESS_DURATION)
 1960              	 .loc 5 409 0
 1961 01fc 1E4B     	 ldr r3,.L92+52
 1962 01fe 1B88     	 ldrh r3,[r3]
 1963 0200 3B2B     	 cmp r3,#59
 1964 0202 03D9     	 bls .L89
 410:../main.c     **** 			buttonpress_down = BTNPRESS_STD;
 1965              	 .loc 5 410 0
 1966 0204 1D4B     	 ldr r3,.L92+56
 1967 0206 0122     	 mov r2,#1
 1968 0208 1A70     	 strb r2,[r3]
 405:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 1969              	 .loc 5 405 0
 1970 020a 18E0     	 b .L73
 1971              	.L89:
 1972 020c 17E0     	 b .L73
 1973              	.L87:
 411:../main.c     **** 	}
 412:../main.c     **** 	// DOWN BUTTON: If press is to long reset (simulate that press ended)
 413:../main.c     **** 	else if(button_down_pressed_timestamp != 0 && button_down_pressed_timestamp != TIMESTAMP_DEACTIVAT
 1974              	 .loc 5 413 0
 1975 020e 114B     	 ldr r3,.L92+16
 1976 0210 1B68     	 ldr r3,[r3]
 1977 0212 002B     	 cmp r3,#0
 1978 0214 13D0     	 beq .L73
 1979              	 .loc 5 413 0 is_stmt 0 discriminator 1
 1980 0216 0F4B     	 ldr r3,.L92+16
 1981 0218 1B68     	 ldr r3,[r3]
 1982 021a 0133     	 add r3,r3,#1
 1983 021c 0FD0     	 beq .L73
 1984              	 .loc 5 413 0 discriminator 2
 1985 021e FFF7FEFF 	 bl SYSTIMER_GetTime
 1986 0222 021C     	 mov r2,r0
 1987 0224 0B4B     	 ldr r3,.L92+16
 1988 0226 1B68     	 ldr r3,[r3]
 1989 0228 D31A     	 sub r3,r2,r3
 1990 022a 104A     	 ldr r2,.L92+40
 1991 022c 9342     	 cmp r3,r2
 1992 022e 06D9     	 bls .L73
 414:../main.c     **** 		button_down_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 1993              	 .loc 5 414 0 is_stmt 1
 1994 0230 084B     	 ldr r3,.L92+16
 1995 0232 0122     	 mov r2,#1
 1996 0234 5242     	 neg r2,r2
 1997 0236 1A60     	 str r2,[r3]
 415:../main.c     **** 		buttonpress_down = BTNPRESS_LONGEST;
 1998              	 .loc 5 415 0
 1999 0238 104B     	 ldr r3,.L92+56
 2000 023a 0322     	 mov r2,#3
 2001 023c 1A70     	 strb r2,[r3]
 2002              	.L73:
 416:../main.c     **** 	}
 417:../main.c     **** }
 2003              	 .loc 5 417 0
 2004 023e BD46     	 mov sp,r7
 2005              	 
 2006 0240 80BD     	 pop {r7,pc}
 2007              	.L93:
 2008 0242 C046     	 .align 2
 2009              	.L92:
 2010 0244 00000000 	 .word button_usb_pressed_timestamp
 2011 0248 00000000 	 .word IO_SW_USB
 2012 024c 00000000 	 .word button_up_pressed_timestamp
 2013 0250 00000000 	 .word IO_SW_UP
 2014 0254 00000000 	 .word button_down_pressed_timestamp
 2015 0258 00000000 	 .word IO_SW_DOWN
 2016 025c 00000000 	 .word button_usb_pressed_duration
 2017 0260 9F0F0000 	 .word 3999
 2018 0264 00000000 	 .word buttonpress_usb
 2019 0268 E7030000 	 .word 999
 2020 026c E70C3D00 	 .word 4000999
 2021 0270 00000000 	 .word button_up_pressed_duration
 2022 0274 00000000 	 .word buttonpress_up
 2023 0278 00000000 	 .word button_down_pressed_duration
 2024 027c 00000000 	 .word buttonpress_down
 2025              	 .cfi_endproc
 2026              	.LFE165:
 2028              	 .section .text.main,"ax",%progbits
 2029              	 .align 2
 2030              	 .global main
 2031              	 .code 16
 2032              	 .thumb_func
 2034              	main:
 2035              	.LFB166:
 418:../main.c     **** 
 419:../main.c     **** 
 420:../main.c     **** //****************************************************************************
 421:../main.c     **** // main - primary loop function
 422:../main.c     **** //****************************************************************************
 423:../main.c     **** int main(void)
 424:../main.c     **** {
 2036              	 .loc 5 424 0
 2037              	 .cfi_startproc
 2038 0000 90B5     	 push {r4,r7,lr}
 2039              	.LCFI40:
 2040              	 .cfi_def_cfa_offset 12
 2041              	 .cfi_offset 4,-12
 2042              	 .cfi_offset 7,-8
 2043              	 .cfi_offset 14,-4
 2044 0002 85B0     	 sub sp,sp,#20
 2045              	.LCFI41:
 2046              	 .cfi_def_cfa_offset 32
 2047 0004 00AF     	 add r7,sp,#0
 2048              	.LCFI42:
 2049              	 .cfi_def_cfa_register 7
 425:../main.c     **** 	// Initialization of DAVE APPs
 426:../main.c     **** 	DAVE_STATUS_t status;
 427:../main.c     **** 	status = DAVE_Init();
 2050              	 .loc 5 427 0
 2051 0006 0B23     	 mov r3,#11
 2052 0008 FC18     	 add r4,r7,r3
 2053 000a FFF7FEFF 	 bl DAVE_Init
 2054 000e 031C     	 mov r3,r0
 2055 0010 2370     	 strb r3,[r4]
 428:../main.c     **** 
 429:../main.c     **** 	// Error routine
 430:../main.c     **** 	if (status != DAVE_STATUS_SUCCESS) {
 2056              	 .loc 5 430 0
 2057 0012 0B23     	 mov r3,#11
 2058 0014 FB18     	 add r3,r7,r3
 2059 0016 1B78     	 ldrb r3,[r3]
 2060 0018 002B     	 cmp r3,#0
 2061 001a 25D0     	 beq .L95
 2062              	.L96:
 431:../main.c     **** 		while(1U){
 432:../main.c     **** 			DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 2063              	 .loc 5 432 0 discriminator 1
 2064 001c C94B     	 ldr r3,.L145
 2065 001e 181C     	 mov r0,r3
 2066 0020 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 433:../main.c     **** 			DIGITAL_IO_SetOutputLow(&IO_LED_USB2);
 2067              	 .loc 5 433 0 discriminator 1
 2068 0024 C84B     	 ldr r3,.L145+4
 2069 0026 181C     	 mov r0,r3
 2070 0028 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 434:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 2071              	 .loc 5 434 0 discriminator 1
 2072 002c C74B     	 ldr r3,.L145+8
 2073 002e 181C     	 mov r0,r3
 2074 0030 0021     	 mov r1,#0
 2075 0032 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 435:../main.c     **** 			delay_ms(500);
 2076              	 .loc 5 435 0 discriminator 1
 2077 0036 FA23     	 mov r3,#250
 2078 0038 5B00     	 lsl r3,r3,#1
 2079 003a 181C     	 mov r0,r3
 2080 003c FFF7FEFF 	 bl delay_ms
 436:../main.c     **** 			DIGITAL_IO_SetOutputHigh(&IO_LED_USB1);
 2081              	 .loc 5 436 0 discriminator 1
 2082 0040 C04B     	 ldr r3,.L145
 2083 0042 181C     	 mov r0,r3
 2084 0044 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 437:../main.c     **** 			DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 2085              	 .loc 5 437 0 discriminator 1
 2086 0048 BF4B     	 ldr r3,.L145+4
 2087 004a 181C     	 mov r0,r3
 2088 004c FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 438:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 2089              	 .loc 5 438 0 discriminator 1
 2090 0050 BE4B     	 ldr r3,.L145+8
 2091 0052 BF4A     	 ldr r2,.L145+12
 2092 0054 181C     	 mov r0,r3
 2093 0056 111C     	 mov r1,r2
 2094 0058 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 439:../main.c     **** 			delay_ms(500);
 2095              	 .loc 5 439 0 discriminator 1
 2096 005c FA23     	 mov r3,#250
 2097 005e 5B00     	 lsl r3,r3,#1
 2098 0060 181C     	 mov r0,r3
 2099 0062 FFF7FEFF 	 bl delay_ms
 440:../main.c     **** 		}
 2100              	 .loc 5 440 0 discriminator 1
 2101 0066 D9E7     	 b .L96
 2102              	.L95:
 441:../main.c     **** 	}
 442:../main.c     **** 
 443:../main.c     **** 	/// - Set initial state -
 444:../main.c     **** 	// Enable USB chip and switch to USB1
 445:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USB_SI);
 2103              	 .loc 5 445 0
 2104 0068 BA4B     	 ldr r3,.L145+16
 2105 006a 181C     	 mov r0,r3
 2106 006c FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 446:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USB_OE);
 2107              	 .loc 5 446 0
 2108 0070 B94B     	 ldr r3,.L145+20
 2109 0072 181C     	 mov r0,r3
 2110 0074 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 447:../main.c     **** 	// Enable USB1
 448:../main.c     **** 	DIGITAL_IO_SetOutputHigh(&IO_USBPWR_1);
 2111              	 .loc 5 448 0
 2112 0078 B84B     	 ldr r3,.L145+24
 2113 007a 181C     	 mov r0,r3
 2114 007c FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 449:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 2115              	 .loc 5 449 0
 2116 0080 B04B     	 ldr r3,.L145
 2117 0082 181C     	 mov r0,r3
 2118 0084 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 450:../main.c     **** 	// Disable USB2
 451:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USBPWR_2);
 2119              	 .loc 5 451 0
 2120 0088 B54B     	 ldr r3,.L145+28
 2121 008a 181C     	 mov r0,r3
 2122 008c FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 452:../main.c     **** 	DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 2123              	 .loc 5 452 0
 2124 0090 AD4B     	 ldr r3,.L145+4
 2125 0092 181C     	 mov r0,r3
 2126 0094 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 453:../main.c     **** 	// Disable Relay and set LED off
 454:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_RELAY);
 2127              	 .loc 5 454 0
 2128 0098 B24B     	 ldr r3,.L145+32
 2129 009a 181C     	 mov r0,r3
 2130 009c FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 455:../main.c     **** 	PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 2131              	 .loc 5 455 0
 2132 00a0 AA4B     	 ldr r3,.L145+8
 2133 00a2 AB4A     	 ldr r2,.L145+12
 2134 00a4 181C     	 mov r0,r3
 2135 00a6 111C     	 mov r1,r2
 2136 00a8 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 456:../main.c     **** 	// Initialize next value conversion
 457:../main.c     **** 	ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 2137              	 .loc 5 457 0
 2138 00ac AE4B     	 ldr r3,.L145+36
 2139 00ae 181C     	 mov r0,r3
 2140 00b0 FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 458:../main.c     **** 
 459:../main.c     **** 	/// - Read setup from emulated EEPROM
 460:../main.c     **** 	read_eeprom_setup();
 2141              	 .loc 5 460 0
 2142 00b4 FFF7FEFF 	 bl read_eeprom_setup
 461:../main.c     **** 
 462:../main.c     **** 	int main_loop_count = 0;
 2143              	 .loc 5 462 0
 2144 00b8 0023     	 mov r3,#0
 2145 00ba FB60     	 str r3,[r7,#12]
 2146              	.L141:
 463:../main.c     **** 
 464:../main.c     **** 	// Main loop
 465:../main.c     **** 	while(1U)
 466:../main.c     **** 	{
 467:../main.c     **** 		// - Status LED handling -
 468:../main.c     **** 		manage_status_led();
 2147              	 .loc 5 468 0
 2148 00bc FFF7FEFF 	 bl manage_status_led
 469:../main.c     **** 		main_loop_count++;
 2149              	 .loc 5 469 0
 2150 00c0 FB68     	 ldr r3,[r7,#12]
 2151 00c2 0133     	 add r3,r3,#1
 2152 00c4 FB60     	 str r3,[r7,#12]
 470:../main.c     **** 		systime_debug = SYSTIMER_GetTime();
 2153              	 .loc 5 470 0
 2154 00c6 FFF7FEFF 	 bl SYSTIMER_GetTime
 2155 00ca 031C     	 mov r3,r0
 2156 00cc 1A1C     	 mov r2,r3
 2157 00ce A74B     	 ldr r3,.L145+40
 2158 00d0 1A60     	 str r2,[r3]
 471:../main.c     **** 
 472:../main.c     **** 		//// - Button handling -
 473:../main.c     **** 		manage_buttons();
 2159              	 .loc 5 473 0
 2160 00d2 FFF7FEFF 	 bl manage_buttons
 474:../main.c     **** 
 475:../main.c     **** 		/// - USB Channel handling -
 476:../main.c     **** 		switch (USB_state){
 2161              	 .loc 5 476 0
 2162 00d6 A64B     	 ldr r3,.L145+44
 2163 00d8 1B78     	 ldrb r3,[r3]
 2164 00da 012B     	 cmp r3,#1
 2165 00dc 23D0     	 beq .L98
 2166 00de 022B     	 cmp r3,#2
 2167 00e0 41D0     	 beq .L142
 2168 00e2 002B     	 cmp r3,#0
 2169 00e4 40D1     	 bne .L97
 477:../main.c     **** 			case USB_1_active:
 478:../main.c     **** 				// State code - none atm
 479:../main.c     **** 
 480:../main.c     **** 				// Transition statement
 481:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 2170              	 .loc 5 481 0
 2171 00e6 A34B     	 ldr r3,.L145+48
 2172 00e8 1B78     	 ldrb r3,[r3]
 2173 00ea 012B     	 cmp r3,#1
 2174 00ec 1AD1     	 bne .L101
 482:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USBPWR_1);
 2175              	 .loc 5 482 0
 2176 00ee 9B4B     	 ldr r3,.L145+24
 2177 00f0 181C     	 mov r0,r3
 2178 00f2 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 483:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USB_SI);
 2179              	 .loc 5 483 0
 2180 00f6 974B     	 ldr r3,.L145+16
 2181 00f8 181C     	 mov r0,r3
 2182 00fa FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 484:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_LED_USB2);
 2183              	 .loc 5 484 0
 2184 00fe 924B     	 ldr r3,.L145+4
 2185 0100 181C     	 mov r0,r3
 2186 0102 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 485:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_LED_USB1);
 2187              	 .loc 5 485 0
 2188 0106 8F4B     	 ldr r3,.L145
 2189 0108 181C     	 mov r0,r3
 2190 010a FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 486:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USBPWR_2);
 2191              	 .loc 5 486 0
 2192 010e 944B     	 ldr r3,.L145+28
 2193 0110 181C     	 mov r0,r3
 2194 0112 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 487:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 2195              	 .loc 5 487 0
 2196 0116 974B     	 ldr r3,.L145+48
 2197 0118 0022     	 mov r2,#0
 2198 011a 1A70     	 strb r2,[r3]
 488:../main.c     **** 
 489:../main.c     **** 					USB_state = USB_2_active;
 2199              	 .loc 5 489 0
 2200 011c 944B     	 ldr r3,.L145+44
 2201 011e 0122     	 mov r2,#1
 2202 0120 1A70     	 strb r2,[r3]
 490:../main.c     **** 				}
 491:../main.c     **** 				break;
 2203              	 .loc 5 491 0
 2204 0122 21E0     	 b .L97
 2205              	.L101:
 2206 0124 20E0     	 b .L97
 2207              	.L98:
 492:../main.c     **** 			case USB_2_active:
 493:../main.c     **** 				// State code - none atm
 494:../main.c     **** 
 495:../main.c     **** 				// Transition statement
 496:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 2208              	 .loc 5 496 0
 2209 0126 934B     	 ldr r3,.L145+48
 2210 0128 1B78     	 ldrb r3,[r3]
 2211 012a 012B     	 cmp r3,#1
 2212 012c 1AD1     	 bne .L102
 497:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USBPWR_2);
 2213              	 .loc 5 497 0
 2214 012e 8C4B     	 ldr r3,.L145+28
 2215 0130 181C     	 mov r0,r3
 2216 0132 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 498:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_USB_SI);
 2217              	 .loc 5 498 0
 2218 0136 874B     	 ldr r3,.L145+16
 2219 0138 181C     	 mov r0,r3
 2220 013a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 499:../main.c     **** 					DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 2221              	 .loc 5 499 0
 2222 013e 814B     	 ldr r3,.L145
 2223 0140 181C     	 mov r0,r3
 2224 0142 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 500:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 2225              	 .loc 5 500 0
 2226 0146 804B     	 ldr r3,.L145+4
 2227 0148 181C     	 mov r0,r3
 2228 014a FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 501:../main.c     **** 					DIGITAL_IO_SetOutputHigh(&IO_USBPWR_1);
 2229              	 .loc 5 501 0
 2230 014e 834B     	 ldr r3,.L145+24
 2231 0150 181C     	 mov r0,r3
 2232 0152 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 502:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 2233              	 .loc 5 502 0
 2234 0156 874B     	 ldr r3,.L145+48
 2235 0158 0022     	 mov r2,#0
 2236 015a 1A70     	 strb r2,[r3]
 503:../main.c     **** 
 504:../main.c     **** 					USB_state = USB_1_active;
 2237              	 .loc 5 504 0
 2238 015c 844B     	 ldr r3,.L145+44
 2239 015e 0022     	 mov r2,#0
 2240 0160 1A70     	 strb r2,[r3]
 505:../main.c     **** 				}
 506:../main.c     **** 				break;
 2241              	 .loc 5 506 0
 2242 0162 01E0     	 b .L97
 2243              	.L102:
 2244 0164 00E0     	 b .L97
 2245              	.L142:
 507:../main.c     **** 			case USB_inactive:
 508:../main.c     **** 				// Currently not implemented!
 509:../main.c     **** 				break;
 2246              	 .loc 5 509 0
 2247 0166 C046     	 mov r8,r8
 2248              	.L97:
 510:../main.c     **** 		}
 511:../main.c     **** 
 512:../main.c     **** 		/// - Relay handling -
 513:../main.c     **** 		// Check for state change triggers based on current state
 514:../main.c     **** 		switch (relay_state){
 2249              	 .loc 5 514 0
 2250 0168 834B     	 ldr r3,.L145+52
 2251 016a 1B78     	 ldrb r3,[r3]
 2252 016c 002B     	 cmp r3,#0
 2253 016e 4ED0     	 beq .L104
 2254 0170 012B     	 cmp r3,#1
 2255 0172 00D0     	 beq .LCB1810
 2256 0174 95E0     	 b .L103
 2257              	.LCB1810:
 515:../main.c     **** 			case RELAY_LOW:
 516:../main.c     **** 				// State code
 517:../main.c     **** 				// Check if upper threshold is exceeded. If it is and timestamp is not already set - save times
 518:../main.c     **** 				if     (ADC_val_upper_thres_exceed_timestamp == 0 && ADC_val_current > ADC_upper_threshold){
 2258              	 .loc 5 518 0
 2259 0176 814B     	 ldr r3,.L145+56
 2260 0178 1B68     	 ldr r3,[r3]
 2261 017a 002B     	 cmp r3,#0
 2262 017c 0CD1     	 bne .L106
 2263              	 .loc 5 518 0 is_stmt 0 discriminator 1
 2264 017e 804B     	 ldr r3,.L145+60
 2265 0180 1B68     	 ldr r3,[r3]
 2266 0182 1A1E     	 sub r2,r3,#0
 2267 0184 7F4B     	 ldr r3,.L145+64
 2268 0186 1B68     	 ldr r3,[r3]
 2269 0188 9A42     	 cmp r2,r3
 2270 018a 05D2     	 bcs .L106
 519:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = SYSTIMER_GetTime();
 2271              	 .loc 5 519 0 is_stmt 1
 2272 018c FFF7FEFF 	 bl SYSTIMER_GetTime
 2273 0190 021C     	 mov r2,r0
 2274 0192 7A4B     	 ldr r3,.L145+56
 2275 0194 1A60     	 str r2,[r3]
 2276 0196 0DE0     	 b .L107
 2277              	.L106:
 520:../main.c     **** 				}
 521:../main.c     **** 				else if(ADC_val_upper_thres_exceed_timestamp != 0 && ADC_val_current < ADC_upper_threshold){
 2278              	 .loc 5 521 0
 2279 0198 784B     	 ldr r3,.L145+56
 2280 019a 1B68     	 ldr r3,[r3]
 2281 019c 002B     	 cmp r3,#0
 2282 019e 09D0     	 beq .L107
 2283              	 .loc 5 521 0 is_stmt 0 discriminator 1
 2284 01a0 774B     	 ldr r3,.L145+60
 2285 01a2 1B68     	 ldr r3,[r3]
 2286 01a4 1A1E     	 sub r2,r3,#0
 2287 01a6 774B     	 ldr r3,.L145+64
 2288 01a8 1B68     	 ldr r3,[r3]
 2289 01aa 9A42     	 cmp r2,r3
 2290 01ac 02D9     	 bls .L107
 522:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = 0;
 2291              	 .loc 5 522 0 is_stmt 1
 2292 01ae 734B     	 ldr r3,.L145+56
 2293 01b0 0022     	 mov r2,#0
 2294 01b2 1A60     	 str r2,[r3]
 2295              	.L107:
 523:../main.c     **** 				}
 524:../main.c     **** 
 525:../main.c     **** 				// Transition statement
 526:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 527:../main.c     **** 				if(ADC_val_upper_thres_exceed_timestamp != 0){
 2296              	 .loc 5 527 0
 2297 01b4 714B     	 ldr r3,.L145+56
 2298 01b6 1B68     	 ldr r3,[r3]
 2299 01b8 002B     	 cmp r3,#0
 2300 01ba 27D0     	 beq .L108
 2301              	.LBB3:
 528:../main.c     **** 					uint16_t upperThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_upper_thres_exceed_times
 2302              	 .loc 5 528 0
 2303 01bc FFF7FEFF 	 bl SYSTIMER_GetTime
 2304 01c0 021C     	 mov r2,r0
 2305 01c2 6E4B     	 ldr r3,.L145+56
 2306 01c4 1B68     	 ldr r3,[r3]
 2307 01c6 D31A     	 sub r3,r2,r3
 2308 01c8 181C     	 mov r0,r3
 2309 01ca FA23     	 mov r3,#250
 2310 01cc 9900     	 lsl r1,r3,#2
 2311 01ce FFF7FEFF 	 bl __aeabi_uidiv
 2312 01d2 031C     	 mov r3,r0
 2313 01d4 1A1C     	 mov r2,r3
 2314 01d6 0823     	 mov r3,#8
 2315 01d8 FB18     	 add r3,r7,r3
 2316 01da 1A80     	 strh r2,[r3]
 529:../main.c     **** 					if(upperThresholdExceedDuration > relay_threshold_latchtime){
 2317              	 .loc 5 529 0
 2318 01dc 0823     	 mov r3,#8
 2319 01de FB18     	 add r3,r7,r3
 2320 01e0 1A88     	 ldrh r2,[r3]
 2321 01e2 694B     	 ldr r3,.L145+68
 2322 01e4 1B68     	 ldr r3,[r3]
 2323 01e6 9A42     	 cmp r2,r3
 2324 01e8 10DD     	 ble .L108
 530:../main.c     **** 						relay_state = RELAY_HIGH;
 2325              	 .loc 5 530 0
 2326 01ea 634B     	 ldr r3,.L145+52
 2327 01ec 0022     	 mov r2,#0
 2328 01ee 1A70     	 strb r2,[r3]
 531:../main.c     **** 						DIGITAL_IO_SetOutputHigh(&IO_RELAY);
 2329              	 .loc 5 531 0
 2330 01f0 5C4B     	 ldr r3,.L145+32
 2331 01f2 181C     	 mov r0,r3
 2332 01f4 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 532:../main.c     **** 						ADC_val_upper_thres_exceed_timestamp = 0;
 2333              	 .loc 5 532 0
 2334 01f8 604B     	 ldr r3,.L145+56
 2335 01fa 0022     	 mov r2,#0
 2336 01fc 1A60     	 str r2,[r3]
 533:../main.c     **** 						if(setup_state == SETUP_IDLE)
 2337              	 .loc 5 533 0
 2338 01fe 634B     	 ldr r3,.L145+72
 2339 0200 1B78     	 ldrb r3,[r3]
 2340 0202 002B     	 cmp r3,#0
 2341 0204 02D1     	 bne .L108
 534:../main.c     **** 							reset_status_led_to_relay_state();
 2342              	 .loc 5 534 0
 2343 0206 FFF7FEFF 	 bl reset_status_led_to_relay_state
 2344              	.LBE3:
 535:../main.c     **** 					}
 536:../main.c     **** 				}
 537:../main.c     **** 				break;
 2345              	 .loc 5 537 0
 2346 020a 4AE0     	 b .L103
 2347              	.L108:
 2348 020c 49E0     	 b .L103
 2349              	.L104:
 538:../main.c     **** 			case RELAY_HIGH:
 539:../main.c     **** 				// State code
 540:../main.c     **** 				// Check if lower threshold is exceeded. If it is and timestamp is not already set - save times
 541:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp == 0 && ADC_val_current < ADC_lower_threshold){
 2350              	 .loc 5 541 0
 2351 020e 604B     	 ldr r3,.L145+76
 2352 0210 1B68     	 ldr r3,[r3]
 2353 0212 002B     	 cmp r3,#0
 2354 0214 0CD1     	 bne .L109
 2355              	 .loc 5 541 0 is_stmt 0 discriminator 1
 2356 0216 5F4B     	 ldr r3,.L145+80
 2357 0218 1B68     	 ldr r3,[r3]
 2358 021a 1A1E     	 sub r2,r3,#0
 2359 021c 594B     	 ldr r3,.L145+64
 2360 021e 1B68     	 ldr r3,[r3]
 2361 0220 9A42     	 cmp r2,r3
 2362 0222 05D9     	 bls .L109
 542:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = SYSTIMER_GetTime();
 2363              	 .loc 5 542 0 is_stmt 1
 2364 0224 FFF7FEFF 	 bl SYSTIMER_GetTime
 2365 0228 021C     	 mov r2,r0
 2366 022a 594B     	 ldr r3,.L145+76
 2367 022c 1A60     	 str r2,[r3]
 2368 022e 0DE0     	 b .L110
 2369              	.L109:
 543:../main.c     **** 				}
 544:../main.c     **** 				else if(ADC_val_lower_thres_exceed_timestamp != 0 && ADC_val_current > ADC_lower_threshold){
 2370              	 .loc 5 544 0
 2371 0230 574B     	 ldr r3,.L145+76
 2372 0232 1B68     	 ldr r3,[r3]
 2373 0234 002B     	 cmp r3,#0
 2374 0236 09D0     	 beq .L110
 2375              	 .loc 5 544 0 is_stmt 0 discriminator 1
 2376 0238 564B     	 ldr r3,.L145+80
 2377 023a 1B68     	 ldr r3,[r3]
 2378 023c 1A1E     	 sub r2,r3,#0
 2379 023e 514B     	 ldr r3,.L145+64
 2380 0240 1B68     	 ldr r3,[r3]
 2381 0242 9A42     	 cmp r2,r3
 2382 0244 02D2     	 bcs .L110
 545:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = 0;
 2383              	 .loc 5 545 0 is_stmt 1
 2384 0246 524B     	 ldr r3,.L145+76
 2385 0248 0022     	 mov r2,#0
 2386 024a 1A60     	 str r2,[r3]
 2387              	.L110:
 546:../main.c     **** 				}
 547:../main.c     **** 
 548:../main.c     **** 				// Transition statement
 549:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 550:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp != 0){
 2388              	 .loc 5 550 0
 2389 024c 504B     	 ldr r3,.L145+76
 2390 024e 1B68     	 ldr r3,[r3]
 2391 0250 002B     	 cmp r3,#0
 2392 0252 25D0     	 beq .L111
 2393              	.LBB4:
 551:../main.c     **** 					uint16_t lowerThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_lower_thres_exceed_times
 2394              	 .loc 5 551 0
 2395 0254 FFF7FEFF 	 bl SYSTIMER_GetTime
 2396 0258 021C     	 mov r2,r0
 2397 025a 4D4B     	 ldr r3,.L145+76
 2398 025c 1B68     	 ldr r3,[r3]
 2399 025e D31A     	 sub r3,r2,r3
 2400 0260 181C     	 mov r0,r3
 2401 0262 FA23     	 mov r3,#250
 2402 0264 9900     	 lsl r1,r3,#2
 2403 0266 FFF7FEFF 	 bl __aeabi_uidiv
 2404 026a 031C     	 mov r3,r0
 2405 026c 1A1C     	 mov r2,r3
 2406 026e BB1D     	 add r3,r7,#6
 2407 0270 1A80     	 strh r2,[r3]
 552:../main.c     **** 					if(lowerThresholdExceedDuration > relay_threshold_latchtime){
 2408              	 .loc 5 552 0
 2409 0272 BB1D     	 add r3,r7,#6
 2410 0274 1A88     	 ldrh r2,[r3]
 2411 0276 444B     	 ldr r3,.L145+68
 2412 0278 1B68     	 ldr r3,[r3]
 2413 027a 9A42     	 cmp r2,r3
 2414 027c 10DD     	 ble .L111
 553:../main.c     **** 						relay_state = RELAY_LOW;
 2415              	 .loc 5 553 0
 2416 027e 3E4B     	 ldr r3,.L145+52
 2417 0280 0122     	 mov r2,#1
 2418 0282 1A70     	 strb r2,[r3]
 554:../main.c     **** 						DIGITAL_IO_SetOutputLow(&IO_RELAY);
 2419              	 .loc 5 554 0
 2420 0284 374B     	 ldr r3,.L145+32
 2421 0286 181C     	 mov r0,r3
 2422 0288 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 555:../main.c     **** 						ADC_val_lower_thres_exceed_timestamp = 0;
 2423              	 .loc 5 555 0
 2424 028c 404B     	 ldr r3,.L145+76
 2425 028e 0022     	 mov r2,#0
 2426 0290 1A60     	 str r2,[r3]
 556:../main.c     **** 						if(setup_state == SETUP_IDLE)
 2427              	 .loc 5 556 0
 2428 0292 3E4B     	 ldr r3,.L145+72
 2429 0294 1B78     	 ldrb r3,[r3]
 2430 0296 002B     	 cmp r3,#0
 2431 0298 02D1     	 bne .L111
 557:../main.c     **** 							reset_status_led_to_relay_state();
 2432              	 .loc 5 557 0
 2433 029a FFF7FEFF 	 bl reset_status_led_to_relay_state
 2434              	.LBE4:
 558:../main.c     **** 					}
 559:../main.c     **** 				}
 560:../main.c     **** 				break;
 2435              	 .loc 5 560 0
 2436 029e FFE7     	 b .L143
 2437              	.L111:
 2438              	.L143:
 2439 02a0 C046     	 mov r8,r8
 2440              	.L103:
 561:../main.c     **** 		}
 562:../main.c     **** 		// Init next value conversion
 563:../main.c     **** 		ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 2441              	 .loc 5 563 0
 2442 02a2 314B     	 ldr r3,.L145+36
 2443 02a4 181C     	 mov r0,r3
 2444 02a6 FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 564:../main.c     **** 
 565:../main.c     **** 		/// - Relay settings handling - Todo auto exit menus after time?, led signal when reaching max?, 
 566:../main.c     **** 		switch(setup_state){
 2445              	 .loc 5 566 0
 2446 02aa 384B     	 ldr r3,.L145+72
 2447 02ac 1B78     	 ldrb r3,[r3]
 2448 02ae 012B     	 cmp r3,#1
 2449 02b0 33D0     	 beq .L113
 2450 02b2 02DC     	 bgt .L114
 2451 02b4 002B     	 cmp r3,#0
 2452 02b6 07D0     	 beq .L115
 2453 02b8 9AE1     	 b .L112
 2454              	.L114:
 2455 02ba 022B     	 cmp r3,#2
 2456 02bc 00D1     	 bne .LCB1994
 2457 02be D0E0     	 b .L116
 2458              	.LCB1994:
 2459 02c0 032B     	 cmp r3,#3
 2460 02c2 00D1     	 bne .LCB1996
 2461 02c4 3FE1     	 b .L117
 2462              	.LCB1996:
 2463 02c6 93E1     	 b .L112
 2464              	.L115:
 567:../main.c     **** 			case SETUP_IDLE:
 568:../main.c     **** 				/// Interpret button press and change to according setup sub-menu (state)
 569:../main.c     **** 				// A long  press of up or down brings system in time setup menu
 570:../main.c     **** 				// A short press of up         brings system in upper threshold setup menu
 571:../main.c     **** 				// A short press of down       brings system in lower threshold setup menu
 572:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2465              	 .loc 5 572 0
 2466 02c8 334B     	 ldr r3,.L145+84
 2467 02ca 1B78     	 ldrb r3,[r3]
 2468 02cc 022B     	 cmp r3,#2
 2469 02ce 03D0     	 beq .L118
 2470              	 .loc 5 572 0 is_stmt 0 discriminator 1
 2471 02d0 324B     	 ldr r3,.L145+88
 2472 02d2 1B78     	 ldrb r3,[r3]
 2473 02d4 022B     	 cmp r3,#2
 2474 02d6 09D1     	 bne .L119
 2475              	.L118:
 573:../main.c     **** 					setup_state = SETUP_TIME_TH;
 2476              	 .loc 5 573 0 is_stmt 1
 2477 02d8 2C4B     	 ldr r3,.L145+72
 2478 02da 0322     	 mov r2,#3
 2479 02dc 1A70     	 strb r2,[r3]
 574:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2480              	 .loc 5 574 0
 2481 02de 304B     	 ldr r3,.L145+92
 2482 02e0 0222     	 mov r2,#2
 2483 02e2 1A70     	 strb r2,[r3]
 575:../main.c     **** 					led_number_continuous = 1;
 2484              	 .loc 5 575 0
 2485 02e4 2F4B     	 ldr r3,.L145+96
 2486 02e6 0122     	 mov r2,#1
 2487 02e8 1A80     	 strh r2,[r3]
 2488 02ea 15E0     	 b .L120
 2489              	.L119:
 576:../main.c     **** 				}
 577:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 2490              	 .loc 5 577 0
 2491 02ec 2A4B     	 ldr r3,.L145+84
 2492 02ee 1B78     	 ldrb r3,[r3]
 2493 02f0 012B     	 cmp r3,#1
 2494 02f2 06D1     	 bne .L121
 578:../main.c     **** 					setup_state = SETUP_UPPER_TH;
 2495              	 .loc 5 578 0
 2496 02f4 254B     	 ldr r3,.L145+72
 2497 02f6 0122     	 mov r2,#1
 2498 02f8 1A70     	 strb r2,[r3]
 579:../main.c     **** 					led_status_pattern = LED_FADE_UP;
 2499              	 .loc 5 579 0
 2500 02fa 294B     	 ldr r3,.L145+92
 2501 02fc 0422     	 mov r2,#4
 2502 02fe 1A70     	 strb r2,[r3]
 2503 0300 0AE0     	 b .L120
 2504              	.L121:
 580:../main.c     **** 					//led_status_pattern = LED_NUMBER;
 581:../main.c     **** 					//led_number_continuous = 5;
 582:../main.c     **** 				}
 583:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 2505              	 .loc 5 583 0
 2506 0302 264B     	 ldr r3,.L145+88
 2507 0304 1B78     	 ldrb r3,[r3]
 2508 0306 012B     	 cmp r3,#1
 2509 0308 06D1     	 bne .L120
 584:../main.c     **** 					setup_state = SETUP_LOWER_TH;
 2510              	 .loc 5 584 0
 2511 030a 204B     	 ldr r3,.L145+72
 2512 030c 0222     	 mov r2,#2
 2513 030e 1A70     	 strb r2,[r3]
 585:../main.c     **** 					led_status_pattern = LED_FADE_DOWN;
 2514              	 .loc 5 585 0
 2515 0310 234B     	 ldr r3,.L145+92
 2516 0312 0322     	 mov r2,#3
 2517 0314 1A70     	 strb r2,[r3]
 586:../main.c     **** 					//led_status_pattern = LED_NUMBER;
 587:../main.c     **** 					//led_number_continuous = 3;
 588:../main.c     **** 				}
 589:../main.c     **** 				break;
 2518              	 .loc 5 589 0
 2519 0316 6BE1     	 b .L112
 2520              	.L120:
 2521 0318 6AE1     	 b .L112
 2522              	.L113:
 590:../main.c     **** 			case SETUP_UPPER_TH:
 591:../main.c     **** 				// Blink relay LED
 592:../main.c     **** 
 593:../main.c     **** 				/// Interpret button press:
 594:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 595:../main.c     **** 				// A short press of up         increases the upper threshold value
 596:../main.c     **** 				// A short press of down       decreases the upper threshold value
 597:../main.c     **** 				// A longest press of up saves the current ADC value as threshold
 598:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2523              	 .loc 5 598 0
 2524 031a 1F4B     	 ldr r3,.L145+84
 2525 031c 1B78     	 ldrb r3,[r3]
 2526 031e 022B     	 cmp r3,#2
 2527 0320 03D0     	 beq .L122
 2528              	 .loc 5 598 0 is_stmt 0 discriminator 1
 2529 0322 1E4B     	 ldr r3,.L145+88
 2530 0324 1B78     	 ldrb r3,[r3]
 2531 0326 022B     	 cmp r3,#2
 2532 0328 3ED1     	 bne .L123
 2533              	.L122:
 599:../main.c     **** 					write_eeprom_setup(EEPROM_UPPER_TH, ADC_upper_threshold);
 2534              	 .loc 5 599 0 is_stmt 1
 2535 032a 154B     	 ldr r3,.L145+60
 2536 032c 1B68     	 ldr r3,[r3]
 2537 032e 0220     	 mov r0,#2
 2538 0330 191C     	 mov r1,r3
 2539 0332 FFF7FEFF 	 bl write_eeprom_setup
 600:../main.c     **** 					setup_state = SETUP_IDLE;
 2540              	 .loc 5 600 0
 2541 0336 154B     	 ldr r3,.L145+72
 2542 0338 0022     	 mov r2,#0
 2543 033a 1A70     	 strb r2,[r3]
 601:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2544              	 .loc 5 601 0
 2545 033c 184B     	 ldr r3,.L145+92
 2546 033e 0522     	 mov r2,#5
 2547 0340 1A70     	 strb r2,[r3]
 2548 0342 8DE0     	 b .L124
 2549              	.L146:
 2550              	 .align 2
 2551              	.L145:
 2552 0344 00000000 	 .word IO_LED_USB1
 2553 0348 00000000 	 .word IO_LED_USB2
 2554 034c 00000000 	 .word PWM_CCU4_LED_STATUS
 2555 0350 10270000 	 .word 10000
 2556 0354 00000000 	 .word IO_USB_SI
 2557 0358 00000000 	 .word IO_USB_OE
 2558 035c 00000000 	 .word IO_USBPWR_1
 2559 0360 00000000 	 .word IO_USBPWR_2
 2560 0364 00000000 	 .word IO_RELAY
 2561 0368 00000000 	 .word ADC_SENSOR
 2562 036c 00000000 	 .word systime_debug
 2563 0370 00000000 	 .word USB_state
 2564 0374 00000000 	 .word buttonpress_usb
 2565 0378 00000000 	 .word relay_state
 2566 037c 00000000 	 .word ADC_val_upper_thres_exceed_timestamp
 2567 0380 00000000 	 .word ADC_upper_threshold
 2568 0384 00000000 	 .word ADC_val_current
 2569 0388 00000000 	 .word relay_threshold_latchtime
 2570 038c 00000000 	 .word setup_state
 2571 0390 00000000 	 .word ADC_val_lower_thres_exceed_timestamp
 2572 0394 00000000 	 .word ADC_lower_threshold
 2573 0398 00000000 	 .word buttonpress_up
 2574 039c 00000000 	 .word buttonpress_down
 2575 03a0 00000000 	 .word led_status_pattern
 2576 03a4 00000000 	 .word led_number_continuous
 2577              	.L123:
 602:../main.c     **** 				}
 603:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2578              	 .loc 5 603 0
 2579 03a8 964B     	 ldr r3,.L147
 2580 03aa 1B78     	 ldrb r3,[r3]
 2581 03ac 012B     	 cmp r3,#1
 2582 03ae 1AD1     	 bne .L125
 604:../main.c     **** 					ADC_upper_threshold += ADC_THRESHOLD_INCREMENT;
 2583              	 .loc 5 604 0
 2584 03b0 954B     	 ldr r3,.L147+4
 2585 03b2 1B68     	 ldr r3,[r3]
 2586 03b4 7533     	 add r3,r3,#117
 2587 03b6 1A1C     	 mov r2,r3
 2588 03b8 934B     	 ldr r3,.L147+4
 2589 03ba 1A60     	 str r2,[r3]
 605:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 606:../main.c     **** 					if(ADC_upper_threshold > ADC_THRESHOLD_MAX){
 2590              	 .loc 5 606 0
 2591 03bc 924B     	 ldr r3,.L147+4
 2592 03be 1B68     	 ldr r3,[r3]
 2593 03c0 924A     	 ldr r2,.L147+8
 2594 03c2 9342     	 cmp r3,r2
 2595 03c4 4CDD     	 ble .L124
 607:../main.c     **** 						ADC_upper_threshold = ADC_THRESHOLD_MAX;
 2596              	 .loc 5 607 0
 2597 03c6 904B     	 ldr r3,.L147+4
 2598 03c8 904A     	 ldr r2,.L147+8
 2599 03ca 1A60     	 str r2,[r3]
 608:../main.c     **** 						led_number_single = 2;
 2600              	 .loc 5 608 0
 2601 03cc 904B     	 ldr r3,.L147+12
 2602 03ce 0222     	 mov r2,#2
 2603 03d0 1A80     	 strh r2,[r3]
 609:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2604              	 .loc 5 609 0
 2605 03d2 904B     	 ldr r3,.L147+16
 2606 03d4 0222     	 mov r2,#2
 2607 03d6 1A70     	 strb r2,[r3]
 610:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2608              	 .loc 5 610 0
 2609 03d8 8F4B     	 ldr r3,.L147+20
 2610 03da 0122     	 mov r2,#1
 2611 03dc 1A70     	 strb r2,[r3]
 611:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2612              	 .loc 5 611 0
 2613 03de 8F4B     	 ldr r3,.L147+24
 2614 03e0 0422     	 mov r2,#4
 2615 03e2 1A70     	 strb r2,[r3]
 612:../main.c     **** 					}
 613:../main.c     **** 				}
 614:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 615:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 616:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 617:../main.c     **** 					if(ADC_upper_threshold <= 0){
 618:../main.c     **** 						ADC_upper_threshold = 0;
 619:../main.c     **** 						led_number_single = 2;
 620:../main.c     **** 						led_status_pattern = LED_NUMBER;
 621:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 622:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 623:../main.c     **** 					}
 624:../main.c     **** 					//if(ADC_upper_threshold <= ADC_lower_threshold)
 625:../main.c     **** 						//ADC_upper_threshold = ADC_lower_threshold;
 626:../main.c     **** 				}
 627:../main.c     **** 				else if(buttonpress_up == BTNPRESS_LONGEST){
 628:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 629:../main.c     **** 					ADC_upper_threshold = ADC_val_current;
 630:../main.c     **** 					write_eeprom_setup(EEPROM_UPPER_TH, ADC_upper_threshold);
 631:../main.c     **** 					setup_state = SETUP_IDLE;
 632:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 633:../main.c     **** 					led_number_single = 3;
 634:../main.c     **** 					led_status_pattern = LED_NUMBER;
 635:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 636:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 637:../main.c     **** 				}
 638:../main.c     **** 				break;
 2616              	 .loc 5 638 0
 2617 03e4 04E1     	 b .L112
 2618              	.L125:
 614:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 2619              	 .loc 5 614 0
 2620 03e6 8E4B     	 ldr r3,.L147+28
 2621 03e8 1B78     	 ldrb r3,[r3]
 2622 03ea 012B     	 cmp r3,#1
 2623 03ec 19D1     	 bne .L127
 615:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2624              	 .loc 5 615 0
 2625 03ee 864B     	 ldr r3,.L147+4
 2626 03f0 1B68     	 ldr r3,[r3]
 2627 03f2 753B     	 sub r3,r3,#117
 2628 03f4 1A1C     	 mov r2,r3
 2629 03f6 844B     	 ldr r3,.L147+4
 2630 03f8 1A60     	 str r2,[r3]
 617:../main.c     **** 						ADC_upper_threshold = 0;
 2631              	 .loc 5 617 0
 2632 03fa 834B     	 ldr r3,.L147+4
 2633 03fc 1B68     	 ldr r3,[r3]
 2634 03fe 002B     	 cmp r3,#0
 2635 0400 2EDC     	 bgt .L124
 618:../main.c     **** 						led_number_single = 2;
 2636              	 .loc 5 618 0
 2637 0402 814B     	 ldr r3,.L147+4
 2638 0404 0022     	 mov r2,#0
 2639 0406 1A60     	 str r2,[r3]
 619:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2640              	 .loc 5 619 0
 2641 0408 814B     	 ldr r3,.L147+12
 2642 040a 0222     	 mov r2,#2
 2643 040c 1A80     	 strh r2,[r3]
 620:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2644              	 .loc 5 620 0
 2645 040e 814B     	 ldr r3,.L147+16
 2646 0410 0222     	 mov r2,#2
 2647 0412 1A70     	 strb r2,[r3]
 621:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2648              	 .loc 5 621 0
 2649 0414 804B     	 ldr r3,.L147+20
 2650 0416 0122     	 mov r2,#1
 2651 0418 1A70     	 strb r2,[r3]
 622:../main.c     **** 					}
 2652              	 .loc 5 622 0
 2653 041a 804B     	 ldr r3,.L147+24
 2654 041c 0422     	 mov r2,#4
 2655 041e 1A70     	 strb r2,[r3]
 2656              	 .loc 5 638 0
 2657 0420 E6E0     	 b .L112
 2658              	.L127:
 627:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 2659              	 .loc 5 627 0
 2660 0422 784B     	 ldr r3,.L147
 2661 0424 1B78     	 ldrb r3,[r3]
 2662 0426 032B     	 cmp r3,#3
 2663 0428 1AD1     	 bne .L124
 629:../main.c     **** 					write_eeprom_setup(EEPROM_UPPER_TH, ADC_upper_threshold);
 2664              	 .loc 5 629 0
 2665 042a 7E4B     	 ldr r3,.L147+32
 2666 042c 1B68     	 ldr r3,[r3]
 2667 042e 1A1C     	 mov r2,r3
 2668 0430 754B     	 ldr r3,.L147+4
 2669 0432 1A60     	 str r2,[r3]
 630:../main.c     **** 					setup_state = SETUP_IDLE;
 2670              	 .loc 5 630 0
 2671 0434 744B     	 ldr r3,.L147+4
 2672 0436 1B68     	 ldr r3,[r3]
 2673 0438 0220     	 mov r0,#2
 2674 043a 191C     	 mov r1,r3
 2675 043c FFF7FEFF 	 bl write_eeprom_setup
 631:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2676              	 .loc 5 631 0
 2677 0440 794B     	 ldr r3,.L147+36
 2678 0442 0022     	 mov r2,#0
 2679 0444 1A70     	 strb r2,[r3]
 633:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2680              	 .loc 5 633 0
 2681 0446 724B     	 ldr r3,.L147+12
 2682 0448 0322     	 mov r2,#3
 2683 044a 1A80     	 strh r2,[r3]
 634:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 2684              	 .loc 5 634 0
 2685 044c 714B     	 ldr r3,.L147+16
 2686 044e 0222     	 mov r2,#2
 2687 0450 1A70     	 strb r2,[r3]
 635:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 2688              	 .loc 5 635 0
 2689 0452 714B     	 ldr r3,.L147+20
 2690 0454 0122     	 mov r2,#1
 2691 0456 1A70     	 strb r2,[r3]
 636:../main.c     **** 				}
 2692              	 .loc 5 636 0
 2693 0458 704B     	 ldr r3,.L147+24
 2694 045a 0522     	 mov r2,#5
 2695 045c 1A70     	 strb r2,[r3]
 2696              	 .loc 5 638 0
 2697 045e C7E0     	 b .L112
 2698              	.L124:
 2699              	 .loc 5 638 0 is_stmt 0 discriminator 1
 2700 0460 C6E0     	 b .L112
 2701              	.L116:
 639:../main.c     **** 			case SETUP_LOWER_TH:
 640:../main.c     **** 				// Blink relay LED
 641:../main.c     **** 
 642:../main.c     **** 				/// Interpret button press:
 643:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 644:../main.c     **** 				// A short press of up         increases the lower threshold value
 645:../main.c     **** 				// A short press of down       decreases the lower threshold value
 646:../main.c     **** 				// A longest press of down saves the current ADC value as threshold
 647:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2702              	 .loc 5 647 0 is_stmt 1
 2703 0462 684B     	 ldr r3,.L147
 2704 0464 1B78     	 ldrb r3,[r3]
 2705 0466 022B     	 cmp r3,#2
 2706 0468 03D0     	 beq .L129
 2707              	 .loc 5 647 0 is_stmt 0 discriminator 1
 2708 046a 6D4B     	 ldr r3,.L147+28
 2709 046c 1B78     	 ldrb r3,[r3]
 2710 046e 022B     	 cmp r3,#2
 2711 0470 0CD1     	 bne .L130
 2712              	.L129:
 648:../main.c     **** 					write_eeprom_setup(EEPROM_LOWER_TH, ADC_lower_threshold);
 2713              	 .loc 5 648 0 is_stmt 1
 2714 0472 6E4B     	 ldr r3,.L147+40
 2715 0474 1B68     	 ldr r3,[r3]
 2716 0476 0120     	 mov r0,#1
 2717 0478 191C     	 mov r1,r3
 2718 047a FFF7FEFF 	 bl write_eeprom_setup
 649:../main.c     **** 					setup_state = SETUP_IDLE;
 2719              	 .loc 5 649 0
 2720 047e 6A4B     	 ldr r3,.L147+36
 2721 0480 0022     	 mov r2,#0
 2722 0482 1A70     	 strb r2,[r3]
 650:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2723              	 .loc 5 650 0
 2724 0484 634B     	 ldr r3,.L147+16
 2725 0486 0522     	 mov r2,#5
 2726 0488 1A70     	 strb r2,[r3]
 2727 048a 5BE0     	 b .L131
 2728              	.L130:
 651:../main.c     **** 				}
 652:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2729              	 .loc 5 652 0
 2730 048c 5D4B     	 ldr r3,.L147
 2731 048e 1B78     	 ldrb r3,[r3]
 2732 0490 012B     	 cmp r3,#1
 2733 0492 1AD1     	 bne .L132
 653:../main.c     **** 					ADC_lower_threshold += ADC_THRESHOLD_INCREMENT;
 2734              	 .loc 5 653 0
 2735 0494 654B     	 ldr r3,.L147+40
 2736 0496 1B68     	 ldr r3,[r3]
 2737 0498 7533     	 add r3,r3,#117
 2738 049a 1A1C     	 mov r2,r3
 2739 049c 634B     	 ldr r3,.L147+40
 2740 049e 1A60     	 str r2,[r3]
 654:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 655:../main.c     **** 					if(ADC_lower_threshold > ADC_THRESHOLD_MAX){
 2741              	 .loc 5 655 0
 2742 04a0 624B     	 ldr r3,.L147+40
 2743 04a2 1B68     	 ldr r3,[r3]
 2744 04a4 594A     	 ldr r2,.L147+8
 2745 04a6 9342     	 cmp r3,r2
 2746 04a8 4CDD     	 ble .L131
 656:../main.c     **** 						ADC_lower_threshold = ADC_THRESHOLD_MAX;
 2747              	 .loc 5 656 0
 2748 04aa 604B     	 ldr r3,.L147+40
 2749 04ac 574A     	 ldr r2,.L147+8
 2750 04ae 1A60     	 str r2,[r3]
 657:../main.c     **** 						led_number_single = 2;
 2751              	 .loc 5 657 0
 2752 04b0 574B     	 ldr r3,.L147+12
 2753 04b2 0222     	 mov r2,#2
 2754 04b4 1A80     	 strh r2,[r3]
 658:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2755              	 .loc 5 658 0
 2756 04b6 574B     	 ldr r3,.L147+16
 2757 04b8 0222     	 mov r2,#2
 2758 04ba 1A70     	 strb r2,[r3]
 659:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2759              	 .loc 5 659 0
 2760 04bc 564B     	 ldr r3,.L147+20
 2761 04be 0122     	 mov r2,#1
 2762 04c0 1A70     	 strb r2,[r3]
 660:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2763              	 .loc 5 660 0
 2764 04c2 564B     	 ldr r3,.L147+24
 2765 04c4 0322     	 mov r2,#3
 2766 04c6 1A70     	 strb r2,[r3]
 661:../main.c     **** 					}
 662:../main.c     **** 				}
 663:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 664:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 665:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 666:../main.c     **** 					if(ADC_lower_threshold <= 0){
 667:../main.c     **** 						ADC_lower_threshold = 0;
 668:../main.c     **** 						led_number_single = 2;
 669:../main.c     **** 						led_status_pattern = LED_NUMBER;
 670:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 671:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 672:../main.c     **** 					}
 673:../main.c     **** 				}
 674:../main.c     **** 				else if(buttonpress_down == BTNPRESS_LONGEST){
 675:../main.c     **** 					// Save current ADC value as threshold
 676:../main.c     **** 					ADC_lower_threshold = ADC_val_current;
 677:../main.c     **** 					write_eeprom_setup(EEPROM_LOWER_TH, ADC_lower_threshold);
 678:../main.c     **** 					setup_state = SETUP_IDLE;
 679:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 680:../main.c     **** 					led_number_single = 3;
 681:../main.c     **** 					led_status_pattern = LED_NUMBER;
 682:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 683:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 684:../main.c     **** 				}
 685:../main.c     **** 				break;
 2767              	 .loc 5 685 0
 2768 04c8 92E0     	 b .L112
 2769              	.L132:
 663:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 2770              	 .loc 5 663 0
 2771 04ca 554B     	 ldr r3,.L147+28
 2772 04cc 1B78     	 ldrb r3,[r3]
 2773 04ce 012B     	 cmp r3,#1
 2774 04d0 19D1     	 bne .L134
 664:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2775              	 .loc 5 664 0
 2776 04d2 564B     	 ldr r3,.L147+40
 2777 04d4 1B68     	 ldr r3,[r3]
 2778 04d6 753B     	 sub r3,r3,#117
 2779 04d8 1A1C     	 mov r2,r3
 2780 04da 544B     	 ldr r3,.L147+40
 2781 04dc 1A60     	 str r2,[r3]
 666:../main.c     **** 						ADC_lower_threshold = 0;
 2782              	 .loc 5 666 0
 2783 04de 534B     	 ldr r3,.L147+40
 2784 04e0 1B68     	 ldr r3,[r3]
 2785 04e2 002B     	 cmp r3,#0
 2786 04e4 2EDC     	 bgt .L131
 667:../main.c     **** 						led_number_single = 2;
 2787              	 .loc 5 667 0
 2788 04e6 514B     	 ldr r3,.L147+40
 2789 04e8 0022     	 mov r2,#0
 2790 04ea 1A60     	 str r2,[r3]
 668:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2791              	 .loc 5 668 0
 2792 04ec 484B     	 ldr r3,.L147+12
 2793 04ee 0222     	 mov r2,#2
 2794 04f0 1A80     	 strh r2,[r3]
 669:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2795              	 .loc 5 669 0
 2796 04f2 484B     	 ldr r3,.L147+16
 2797 04f4 0222     	 mov r2,#2
 2798 04f6 1A70     	 strb r2,[r3]
 670:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2799              	 .loc 5 670 0
 2800 04f8 474B     	 ldr r3,.L147+20
 2801 04fa 0122     	 mov r2,#1
 2802 04fc 1A70     	 strb r2,[r3]
 671:../main.c     **** 					}
 2803              	 .loc 5 671 0
 2804 04fe 474B     	 ldr r3,.L147+24
 2805 0500 0322     	 mov r2,#3
 2806 0502 1A70     	 strb r2,[r3]
 2807              	 .loc 5 685 0
 2808 0504 74E0     	 b .L112
 2809              	.L134:
 674:../main.c     **** 					// Save current ADC value as threshold
 2810              	 .loc 5 674 0
 2811 0506 464B     	 ldr r3,.L147+28
 2812 0508 1B78     	 ldrb r3,[r3]
 2813 050a 032B     	 cmp r3,#3
 2814 050c 1AD1     	 bne .L131
 676:../main.c     **** 					write_eeprom_setup(EEPROM_LOWER_TH, ADC_lower_threshold);
 2815              	 .loc 5 676 0
 2816 050e 454B     	 ldr r3,.L147+32
 2817 0510 1B68     	 ldr r3,[r3]
 2818 0512 1A1C     	 mov r2,r3
 2819 0514 454B     	 ldr r3,.L147+40
 2820 0516 1A60     	 str r2,[r3]
 677:../main.c     **** 					setup_state = SETUP_IDLE;
 2821              	 .loc 5 677 0
 2822 0518 444B     	 ldr r3,.L147+40
 2823 051a 1B68     	 ldr r3,[r3]
 2824 051c 0120     	 mov r0,#1
 2825 051e 191C     	 mov r1,r3
 2826 0520 FFF7FEFF 	 bl write_eeprom_setup
 678:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2827              	 .loc 5 678 0
 2828 0524 404B     	 ldr r3,.L147+36
 2829 0526 0022     	 mov r2,#0
 2830 0528 1A70     	 strb r2,[r3]
 680:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2831              	 .loc 5 680 0
 2832 052a 394B     	 ldr r3,.L147+12
 2833 052c 0322     	 mov r2,#3
 2834 052e 1A80     	 strh r2,[r3]
 681:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 2835              	 .loc 5 681 0
 2836 0530 384B     	 ldr r3,.L147+16
 2837 0532 0222     	 mov r2,#2
 2838 0534 1A70     	 strb r2,[r3]
 682:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 2839              	 .loc 5 682 0
 2840 0536 384B     	 ldr r3,.L147+20
 2841 0538 0122     	 mov r2,#1
 2842 053a 1A70     	 strb r2,[r3]
 683:../main.c     **** 				}
 2843              	 .loc 5 683 0
 2844 053c 374B     	 ldr r3,.L147+24
 2845 053e 0522     	 mov r2,#5
 2846 0540 1A70     	 strb r2,[r3]
 2847              	 .loc 5 685 0
 2848 0542 55E0     	 b .L112
 2849              	.L131:
 2850              	 .loc 5 685 0 is_stmt 0 discriminator 3
 2851 0544 54E0     	 b .L112
 2852              	.L117:
 686:../main.c     **** 			case SETUP_TIME_TH:
 687:../main.c     **** 				/// Interpret button press:
 688:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 689:../main.c     **** 				// A short press of up         increases the threshold exceed time
 690:../main.c     **** 				// A short press of down       decreases the threshold exceed time
 691:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2853              	 .loc 5 691 0 is_stmt 1
 2854 0546 2F4B     	 ldr r3,.L147
 2855 0548 1B78     	 ldrb r3,[r3]
 2856 054a 022B     	 cmp r3,#2
 2857 054c 03D0     	 beq .L136
 2858              	 .loc 5 691 0 is_stmt 0 discriminator 1
 2859 054e 344B     	 ldr r3,.L147+28
 2860 0550 1B78     	 ldrb r3,[r3]
 2861 0552 022B     	 cmp r3,#2
 2862 0554 0CD1     	 bne .L137
 2863              	.L136:
 692:../main.c     **** 					write_eeprom_setup(EEPROM_LATCHTIME, relay_threshold_latchtime);
 2864              	 .loc 5 692 0 is_stmt 1
 2865 0556 364B     	 ldr r3,.L147+44
 2866 0558 1B68     	 ldr r3,[r3]
 2867 055a 0320     	 mov r0,#3
 2868 055c 191C     	 mov r1,r3
 2869 055e FFF7FEFF 	 bl write_eeprom_setup
 693:../main.c     **** 					setup_state = SETUP_IDLE;
 2870              	 .loc 5 693 0
 2871 0562 314B     	 ldr r3,.L147+36
 2872 0564 0022     	 mov r2,#0
 2873 0566 1A70     	 strb r2,[r3]
 694:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2874              	 .loc 5 694 0
 2875 0568 2A4B     	 ldr r3,.L147+16
 2876 056a 0522     	 mov r2,#5
 2877 056c 1A70     	 strb r2,[r3]
 2878 056e 3EE0     	 b .L138
 2879              	.L137:
 695:../main.c     **** 				}
 696:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 2880              	 .loc 5 696 0
 2881 0570 244B     	 ldr r3,.L147
 2882 0572 1B78     	 ldrb r3,[r3]
 2883 0574 012B     	 cmp r3,#1
 2884 0576 1BD1     	 bne .L139
 697:../main.c     **** 					relay_threshold_latchtime += RELAY_LATCHTIME_INCREMENT;
 2885              	 .loc 5 697 0
 2886 0578 2D4B     	 ldr r3,.L147+44
 2887 057a 1B68     	 ldr r3,[r3]
 2888 057c F533     	 add r3,r3,#245
 2889 057e FF33     	 add r3,r3,#255
 2890 0580 1A1C     	 mov r2,r3
 2891 0582 2B4B     	 ldr r3,.L147+44
 2892 0584 1A60     	 str r2,[r3]
 698:../main.c     **** 					if(relay_threshold_latchtime > RELAY_LATCHTIME_MAX){
 2893              	 .loc 5 698 0
 2894 0586 2A4B     	 ldr r3,.L147+44
 2895 0588 1B68     	 ldr r3,[r3]
 2896 058a 2A4A     	 ldr r2,.L147+48
 2897 058c 9342     	 cmp r3,r2
 2898 058e 2EDD     	 ble .L138
 699:../main.c     **** 						relay_threshold_latchtime = RELAY_LATCHTIME_MAX;
 2899              	 .loc 5 699 0
 2900 0590 274B     	 ldr r3,.L147+44
 2901 0592 284A     	 ldr r2,.L147+48
 2902 0594 1A60     	 str r2,[r3]
 700:../main.c     **** 						led_number_single = 2;
 2903              	 .loc 5 700 0
 2904 0596 1E4B     	 ldr r3,.L147+12
 2905 0598 0222     	 mov r2,#2
 2906 059a 1A80     	 strh r2,[r3]
 701:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2907              	 .loc 5 701 0
 2908 059c 1D4B     	 ldr r3,.L147+16
 2909 059e 0222     	 mov r2,#2
 2910 05a0 1A70     	 strb r2,[r3]
 702:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2911              	 .loc 5 702 0
 2912 05a2 1D4B     	 ldr r3,.L147+20
 2913 05a4 0122     	 mov r2,#1
 2914 05a6 1A70     	 strb r2,[r3]
 703:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 2915              	 .loc 5 703 0
 2916 05a8 1C4B     	 ldr r3,.L147+24
 2917 05aa 0222     	 mov r2,#2
 2918 05ac 1A70     	 strb r2,[r3]
 704:../main.c     **** 					}
 705:../main.c     **** 				}
 706:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 707:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 708:../main.c     **** 					if(relay_threshold_latchtime <= 0){
 709:../main.c     **** 						relay_threshold_latchtime = 0;
 710:../main.c     **** 						led_number_single = 2;
 711:../main.c     **** 						led_status_pattern = LED_NUMBER;
 712:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 713:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 714:../main.c     **** 					}
 715:../main.c     **** 				}
 716:../main.c     **** 				break;
 2919              	 .loc 5 716 0
 2920 05ae 1EE0     	 b .L144
 2921              	.L139:
 706:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 2922              	 .loc 5 706 0
 2923 05b0 1B4B     	 ldr r3,.L147+28
 2924 05b2 1B78     	 ldrb r3,[r3]
 2925 05b4 012B     	 cmp r3,#1
 2926 05b6 1AD1     	 bne .L138
 707:../main.c     **** 					if(relay_threshold_latchtime <= 0){
 2927              	 .loc 5 707 0
 2928 05b8 1D4B     	 ldr r3,.L147+44
 2929 05ba 1B68     	 ldr r3,[r3]
 2930 05bc F53B     	 sub r3,r3,#245
 2931 05be FF3B     	 sub r3,r3,#255
 2932 05c0 1A1C     	 mov r2,r3
 2933 05c2 1B4B     	 ldr r3,.L147+44
 2934 05c4 1A60     	 str r2,[r3]
 708:../main.c     **** 						relay_threshold_latchtime = 0;
 2935              	 .loc 5 708 0
 2936 05c6 1A4B     	 ldr r3,.L147+44
 2937 05c8 1B68     	 ldr r3,[r3]
 2938 05ca 002B     	 cmp r3,#0
 2939 05cc 0FDC     	 bgt .L138
 709:../main.c     **** 						led_number_single = 2;
 2940              	 .loc 5 709 0
 2941 05ce 184B     	 ldr r3,.L147+44
 2942 05d0 0022     	 mov r2,#0
 2943 05d2 1A60     	 str r2,[r3]
 710:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2944              	 .loc 5 710 0
 2945 05d4 0E4B     	 ldr r3,.L147+12
 2946 05d6 0222     	 mov r2,#2
 2947 05d8 1A80     	 strh r2,[r3]
 711:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2948              	 .loc 5 711 0
 2949 05da 0E4B     	 ldr r3,.L147+16
 2950 05dc 0222     	 mov r2,#2
 2951 05de 1A70     	 strb r2,[r3]
 712:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 2952              	 .loc 5 712 0
 2953 05e0 0D4B     	 ldr r3,.L147+20
 2954 05e2 0122     	 mov r2,#1
 2955 05e4 1A70     	 strb r2,[r3]
 713:../main.c     **** 					}
 2956              	 .loc 5 713 0
 2957 05e6 0D4B     	 ldr r3,.L147+24
 2958 05e8 0222     	 mov r2,#2
 2959 05ea 1A70     	 strb r2,[r3]
 2960              	 .loc 5 716 0
 2961 05ec FFE7     	 b .L144
 2962              	.L138:
 2963              	.L144:
 2964 05ee C046     	 mov r8,r8
 2965              	.L112:
 717:../main.c     **** 		}
 718:../main.c     **** 
 719:../main.c     **** 		// Reset all button presses
 720:../main.c     **** 		buttonpress_usb = BTNPRESS_NOT;
 2966              	 .loc 5 720 0
 2967 05f0 114B     	 ldr r3,.L147+52
 2968 05f2 0022     	 mov r2,#0
 2969 05f4 1A70     	 strb r2,[r3]
 721:../main.c     **** 		buttonpress_up = BTNPRESS_NOT;
 2970              	 .loc 5 721 0
 2971 05f6 034B     	 ldr r3,.L147
 2972 05f8 0022     	 mov r2,#0
 2973 05fa 1A70     	 strb r2,[r3]
 722:../main.c     **** 		buttonpress_down = BTNPRESS_NOT;
 2974              	 .loc 5 722 0
 2975 05fc 084B     	 ldr r3,.L147+28
 2976 05fe 0022     	 mov r2,#0
 2977 0600 1A70     	 strb r2,[r3]
 723:../main.c     **** 	}
 2978              	 .loc 5 723 0
 2979 0602 5BE5     	 b .L141
 2980              	.L148:
 2981              	 .align 2
 2982              	.L147:
 2983 0604 00000000 	 .word buttonpress_up
 2984 0608 00000000 	 .word ADC_upper_threshold
 2985 060c FF0F0000 	 .word 4095
 2986 0610 00000000 	 .word led_number_single
 2987 0614 00000000 	 .word led_status_pattern
 2988 0618 00000000 	 .word led_pattern_mode
 2989 061c 00000000 	 .word led_status_pattern_after_single
 2990 0620 00000000 	 .word buttonpress_down
 2991 0624 00000000 	 .word ADC_val_current
 2992 0628 00000000 	 .word setup_state
 2993 062c 00000000 	 .word ADC_lower_threshold
 2994 0630 00000000 	 .word relay_threshold_latchtime
 2995 0634 60EA0000 	 .word 60000
 2996 0638 00000000 	 .word buttonpress_usb
 2997              	 .cfi_endproc
 2998              	.LFE166:
 3000              	 .global meas_invalid_count
 3001              	 .section .bss.meas_invalid_count,"aw",%nobits
 3002              	 .align 2
 3005              	meas_invalid_count:
 3006 0000 00000000 	 .space 4
 3007              	 .section .text.VADC0_C0_0_IRQHandler,"ax",%progbits
 3008              	 .align 2
 3009              	 .global VADC0_C0_0_IRQHandler
 3010              	 .code 16
 3011              	 .thumb_func
 3013              	VADC0_C0_0_IRQHandler:
 3014              	.LFB167:
 724:../main.c     **** }
 725:../main.c     **** 
 726:../main.c     **** int meas_invalid_count = 0;
 727:../main.c     **** 
 728:../main.c     **** void Adc_Measurement_Handler()
 729:../main.c     **** {
 3015              	 .loc 5 729 0
 3016              	 .cfi_startproc
 3017 0000 80B5     	 push {r7,lr}
 3018              	.LCFI43:
 3019              	 .cfi_def_cfa_offset 8
 3020              	 .cfi_offset 7,-8
 3021              	 .cfi_offset 14,-4
 3022 0002 82B0     	 sub sp,sp,#8
 3023              	.LCFI44:
 3024              	 .cfi_def_cfa_offset 16
 3025 0004 00AF     	 add r7,sp,#0
 3026              	.LCFI45:
 3027              	 .cfi_def_cfa_register 7
 730:../main.c     **** 	//uint8_t channel_num;
 731:../main.c     **** 	//uint8_t group_num;
 732:../main.c     **** 	uint32_t adc_register;
 733:../main.c     **** 
 734:../main.c     **** 	#if(UC_SERIES == XMC11)
 735:../main.c     **** 	adc_register = ADC_MEASUREMENT_GetGlobalDetailedResult();
 3028              	 .loc 5 735 0
 3029 0006 FFF7FEFF 	 bl ADC_MEASUREMENT_GetGlobalDetailedResult
 3030 000a 031C     	 mov r3,r0
 3031 000c 7B60     	 str r3,[r7,#4]
 736:../main.c     **** 	#endif
 737:../main.c     **** 
 738:../main.c     **** 	if((bool)(adc_register >> VADC_GLOBRES_VF_Pos))
 3032              	 .loc 5 738 0
 3033 000e 7B68     	 ldr r3,[r7,#4]
 3034 0010 002B     	 cmp r3,#0
 3035 0012 0DDA     	 bge .L150
 739:../main.c     **** 	{
 740:../main.c     **** 		//channel_num = (adc_register & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos;
 741:../main.c     **** 		//group_num = ADC_MEASUREMENT_Channel_A.group_index;
 742:../main.c     **** 		ADC_val_current = (adc_register & VADC_GLOBRES_RESULT_Msk) >> ((uint32_t)(ADC_SENSOR.iclass_confi
 3036              	 .loc 5 742 0
 3037 0014 7B68     	 ldr r3,[r7,#4]
 3038 0016 1B04     	 lsl r3,r3,#16
 3039 0018 1A0C     	 lsr r2,r3,#16
 3040 001a 094B     	 ldr r3,.L152
 3041 001c 9B68     	 ldr r3,[r3,#8]
 3042 001e 5B78     	 ldrb r3,[r3,#1]
 3043 0020 5B07     	 lsl r3,r3,#29
 3044 0022 5B0F     	 lsr r3,r3,#29
 3045 0024 DBB2     	 uxtb r3,r3
 3046 0026 5B00     	 lsl r3,r3,#1
 3047 0028 DA40     	 lsr r2,r2,r3
 3048 002a 064B     	 ldr r3,.L152+4
 3049 002c 1A60     	 str r2,[r3]
 3050 002e 04E0     	 b .L149
 3051              	.L150:
 743:../main.c     **** 	}
 744:../main.c     **** 	else{
 745:../main.c     **** 		meas_invalid_count++;
 3052              	 .loc 5 745 0
 3053 0030 054B     	 ldr r3,.L152+8
 3054 0032 1B68     	 ldr r3,[r3]
 3055 0034 5A1C     	 add r2,r3,#1
 3056 0036 044B     	 ldr r3,.L152+8
 3057 0038 1A60     	 str r2,[r3]
 3058              	.L149:
 746:../main.c     **** 	}
 747:../main.c     **** 
 748:../main.c     **** 	//	ADC_val_current = ADC_MEASUREMENT_GetGlobalResult();
 749:../main.c     **** 	//	ADC_val_current = ADC_val_current >> ((uint32_t)ADC_SENSOR.iclass_config_handle->conversion_mod
 750:../main.c     **** }
 3059              	 .loc 5 750 0
 3060 003a BD46     	 mov sp,r7
 3061 003c 02B0     	 add sp,sp,#8
 3062              	 
 3063 003e 80BD     	 pop {r7,pc}
 3064              	.L153:
 3065              	 .align 2
 3066              	.L152:
 3067 0040 00000000 	 .word ADC_SENSOR
 3068 0044 00000000 	 .word ADC_val_current
 3069 0048 00000000 	 .word meas_invalid_count
 3070              	 .cfi_endproc
 3071              	.LFE167:
 3073              	 .section .bss.led_pattern_state_timestamp.7187,"aw",%nobits
 3074              	 .align 2
 3077              	led_pattern_state_timestamp.7187:
 3078 0000 00000000 	 .space 4
 3079              	 .section .bss.led_pattern_state_length.7188,"aw",%nobits
 3080              	 .align 1
 3083              	led_pattern_state_length.7188:
 3084 0000 0000     	 .space 2
 3085              	 .section .bss.led_pattern_state.7186,"aw",%nobits
 3086              	 .align 1
 3089              	led_pattern_state.7186:
 3090 0000 0000     	 .space 2
 3091              	 .section .bss.fade_duty_step.7189,"aw",%nobits
 3092              	 .align 1
 3095              	fade_duty_step.7189:
 3096 0000 0000     	 .space 2
 3097              	 .text
 3098              	.Letext0:
 3099              	 .file 6 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3100              	 .file 7 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3101              	 .file 8 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 3102              	 .file 9 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_scu.h"
 3103              	 .file 10 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_ADC/global_adc.h"
 3104              	 .file 11 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_gpio.h"
 3105              	 .file 12 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_ccu4.h"
 3106              	 .file 13 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_CCU4/global_ccu4.h"
 3107              	 .file 14 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4.h"
 3108              	 .file 15 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DAVE.h"
 3109              	 .file 16 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Include/cmsis_gcc.h"
 3110              	 .file 17 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/system_XMC1100.h"
 3111              	 .file 18 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement_extern.h"
 3112              	 .file 19 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io_extern.h"
 3113              	 .file 20 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4_extern.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:18     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 $t
    {standard input}:22     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 XMC_VADC_GLOBAL_GetDetailedResult
    {standard input}:54     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 $t
    {standard input}:58     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 ADC_MEASUREMENT_GetGlobalDetailedResult
    {standard input}:91     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:0000001c $d
    {standard input}:96     .text.XMC_GPIO_SetOutputHigh:00000000 $t
    {standard input}:100    .text.XMC_GPIO_SetOutputHigh:00000000 XMC_GPIO_SetOutputHigh
    {standard input}:136    .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:140    .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:176    .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:180    .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
    {standard input}:218    .text.DIGITAL_IO_SetOutputHigh:00000000 $t
    {standard input}:222    .text.DIGITAL_IO_SetOutputHigh:00000000 DIGITAL_IO_SetOutputHigh
    {standard input}:256    .text.DIGITAL_IO_SetOutputLow:00000000 $t
    {standard input}:260    .text.DIGITAL_IO_SetOutputLow:00000000 DIGITAL_IO_SetOutputLow
    {standard input}:293    .text.DIGITAL_IO_GetInput:00000000 $t
    {standard input}:297    .text.DIGITAL_IO_GetInput:00000000 DIGITAL_IO_GetInput
    {standard input}:336    .data.relay_threshold_latchtime:00000000 relay_threshold_latchtime
    {standard input}:333    .data.relay_threshold_latchtime:00000000 $d
    {standard input}:343    .data.ADC_upper_threshold:00000000 ADC_upper_threshold
    {standard input}:340    .data.ADC_upper_threshold:00000000 $d
    {standard input}:350    .data.ADC_lower_threshold:00000000 ADC_lower_threshold
    {standard input}:347    .data.ADC_lower_threshold:00000000 $d
    {standard input}:356    .bss.USB_state:00000000 USB_state
    {standard input}:357    .bss.USB_state:00000000 $d
    {standard input}:362    .data.relay_state:00000000 relay_state
    {standard input}:368    .bss.setup_state:00000000 setup_state
    {standard input}:369    .bss.setup_state:00000000 $d
    {standard input}:374    .bss.led_status_pattern:00000000 led_status_pattern
    {standard input}:375    .bss.led_status_pattern:00000000 $d
    {standard input}:380    .bss.led_status_pattern_last:00000000 led_status_pattern_last
    {standard input}:381    .bss.led_status_pattern_last:00000000 $d
    {standard input}:386    .bss.led_pattern_mode:00000000 led_pattern_mode
    {standard input}:387    .bss.led_pattern_mode:00000000 $d
    {standard input}:392    .bss.led_status_pattern_after_single:00000000 led_status_pattern_after_single
    {standard input}:393    .bss.led_status_pattern_after_single:00000000 $d
    {standard input}:399    .bss.led_number_continuous:00000000 led_number_continuous
    {standard input}:396    .bss.led_number_continuous:00000000 $d
    {standard input}:406    .bss.led_number_single:00000000 led_number_single
    {standard input}:403    .bss.led_number_single:00000000 $d
    {standard input}:413    .data.led_fadetime:00000000 led_fadetime
    {standard input}:410    .data.led_fadetime:00000000 $d
    {standard input}:420    .data.led_fadesteps:00000000 led_fadesteps
    {standard input}:417    .data.led_fadesteps:00000000 $d
    {standard input}:426    .bss.buttonpress_usb:00000000 buttonpress_usb
    {standard input}:427    .bss.buttonpress_usb:00000000 $d
    {standard input}:432    .bss.buttonpress_up:00000000 buttonpress_up
    {standard input}:433    .bss.buttonpress_up:00000000 $d
    {standard input}:438    .bss.buttonpress_down:00000000 buttonpress_down
    {standard input}:439    .bss.buttonpress_down:00000000 $d
    {standard input}:445    .bss.button_usb_pressed_timestamp:00000000 button_usb_pressed_timestamp
    {standard input}:442    .bss.button_usb_pressed_timestamp:00000000 $d
    {standard input}:452    .bss.button_up_pressed_timestamp:00000000 button_up_pressed_timestamp
    {standard input}:449    .bss.button_up_pressed_timestamp:00000000 $d
    {standard input}:459    .bss.button_down_pressed_timestamp:00000000 button_down_pressed_timestamp
    {standard input}:456    .bss.button_down_pressed_timestamp:00000000 $d
    {standard input}:466    .bss.button_usb_pressed_duration:00000000 button_usb_pressed_duration
    {standard input}:463    .bss.button_usb_pressed_duration:00000000 $d
    {standard input}:473    .bss.button_up_pressed_duration:00000000 button_up_pressed_duration
    {standard input}:470    .bss.button_up_pressed_duration:00000000 $d
    {standard input}:480    .bss.button_down_pressed_duration:00000000 button_down_pressed_duration
    {standard input}:477    .bss.button_down_pressed_duration:00000000 $d
    {standard input}:487    .bss.ADC_val_current:00000000 ADC_val_current
    {standard input}:484    .bss.ADC_val_current:00000000 $d
    {standard input}:494    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 ADC_val_upper_thres_exceed_timestamp
    {standard input}:491    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 $d
    {standard input}:501    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 ADC_val_lower_thres_exceed_timestamp
    {standard input}:498    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 $d
    {standard input}:508    .bss.systime_debug:00000000 systime_debug
    {standard input}:505    .bss.systime_debug:00000000 $d
    {standard input}:515    .bss.eeprom_latchtime:00000000 eeprom_latchtime
    {standard input}:512    .bss.eeprom_latchtime:00000000 $d
    {standard input}:522    .bss.eeprom_upper:00000000 eeprom_upper
    {standard input}:519    .bss.eeprom_upper:00000000 $d
    {standard input}:529    .bss.eeprom_lower:00000000 eeprom_lower
    {standard input}:526    .bss.eeprom_lower:00000000 $d
    {standard input}:532    .text.delay_ms:00000000 $t
    {standard input}:537    .text.delay_ms:00000000 delay_ms
    {standard input}:587    .text.reset_status_led_to_relay_state:00000000 $t
    {standard input}:592    .text.reset_status_led_to_relay_state:00000000 reset_status_led_to_relay_state
    {standard input}:647    .text.reset_status_led_to_relay_state:00000044 $d
    {standard input}:656    .text.manage_status_led:00000000 $t
    {standard input}:661    .text.manage_status_led:00000000 manage_status_led
    {standard input}:698    .rodata.manage_status_led:00000000 $d
    {standard input}:1130   .text.manage_status_led:000002e0 $d
    {standard input}:3077   .bss.led_pattern_state_timestamp.7187:00000000 led_pattern_state_timestamp.7187
    {standard input}:3083   .bss.led_pattern_state_length.7188:00000000 led_pattern_state_length.7188
    {standard input}:3089   .bss.led_pattern_state.7186:00000000 led_pattern_state.7186
    {standard input}:3095   .bss.fade_duty_step.7189:00000000 fade_duty_step.7189
    {standard input}:1148   .text.manage_status_led:00000320 $t
    {standard input}:1261   .text.manage_status_led:000003e0 $d
                            *COM*:00000004 ReadBuffer_LTH
                            *COM*:00000004 ReadBuffer_UTH
                            *COM*:00000004 ReadBuffer_LT
                            *COM*:00000004 EEPROM_WriteBuffer
    {standard input}:1279   .text.read_eeprom_setup:00000000 $t
    {standard input}:1284   .text.read_eeprom_setup:00000000 read_eeprom_setup
    {standard input}:1559   .text.read_eeprom_setup:000001d8 $d
    {standard input}:1577   .text.write_eeprom_setup:00000000 $t
    {standard input}:1582   .text.write_eeprom_setup:00000000 write_eeprom_setup
    {standard input}:1639   .text.write_eeprom_setup:00000048 $d
    {standard input}:1644   .text.manage_buttons:00000000 $t
    {standard input}:1649   .text.manage_buttons:00000000 manage_buttons
    {standard input}:2010   .text.manage_buttons:00000244 $d
    {standard input}:2029   .text.main:00000000 $t
    {standard input}:2034   .text.main:00000000 main
    {standard input}:2552   .text.main:00000344 $d
    {standard input}:2579   .text.main:000003a8 $t
    {standard input}:2983   .text.main:00000604 $d
    {standard input}:3005   .bss.meas_invalid_count:00000000 meas_invalid_count
    {standard input}:3002   .bss.meas_invalid_count:00000000 $d
    {standard input}:3008   .text.VADC0_C0_0_IRQHandler:00000000 $t
    {standard input}:3013   .text.VADC0_C0_0_IRQHandler:00000000 VADC0_C0_0_IRQHandler
    {standard input}:3067   .text.VADC0_C0_0_IRQHandler:00000040 $d
    {standard input}:3074   .bss.led_pattern_state_timestamp.7187:00000000 $d
    {standard input}:3080   .bss.led_pattern_state_length.7188:00000000 $d
    {standard input}:3086   .bss.led_pattern_state.7186:00000000 $d
    {standard input}:3092   .bss.fade_duty_step.7189:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SYSTIMER_GetTime
PWM_CCU4_SetDutyCycle
IO_RELAY
PWM_CCU4_LED_STATUS
__aeabi_uidiv
E_EEPROM_XMC1_Read
E_EEPROM_XMC1_Write
IO_SW_USB
IO_SW_UP
IO_SW_DOWN
DAVE_Init
ADC_MEASUREMENT_StartConversion
IO_LED_USB1
IO_LED_USB2
IO_USB_SI
IO_USB_OE
IO_USBPWR_1
IO_USBPWR_2
ADC_SENSOR
