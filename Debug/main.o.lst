   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "main.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_VADC_GLOBAL_GetDetailedResult,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	XMC_VADC_GLOBAL_GetDetailedResult:
  23              	.LFB66:
  24              	 .file 1 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_vadc.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @file xmc_vadc.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @date 2019-12-02
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-15:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Initial <br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-02-20:
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised for XMC1201 device.<br>
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-04-27:
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for SHS.<br>
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added New APIs for trigger edge selection.<BR>
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new APIs for Queue flush entries, boundary selection, Boundary node pointer.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Revised GatingMode APIs and EMUX Control Init API.<BR>
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-20:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-06-25:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - BFL configuration in channel initialization fixed.
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-07-28:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - CLOCK_GATING_SUPPORTED and PERIPHERAL_RESET_SUPPORTED macros used
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC13 XMC12 and XMC14
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Clubbed the macro definitions for XMC44 XMC47 and XMC48
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GLOBAL_SetIndividualBoundary
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetIndividualBoundary
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAlias
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetInputClass
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelSetIclass
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetResultAlignment
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetInputClass
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultSubtractionValue
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC4300 device supported
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_TriggerEvent API updated. OR operation removed.
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - XMC_VADC_GLOBAL_ClearEvent API updated. Multiple events triggering on clearing the event i
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Wrong MACRO name defined in xmc_vadc_map.h file corrected for XMC4200/4100 devices.
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       XMC_VADC_G3_SAMPLE renamed to XMC_VADC_G1_SAMPLE
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2015-12-01:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs Created.
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the analog calibration voltage for XMC1100 to external reference upper supply range.
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed the XMC_VADC_GLOBAL_StartupCalibration() for XMC1100.
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-09:
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Optimization of write only registers
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-03-18:
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_IsConverterReady(): API checks the STEPCFG register for the read
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       SHSCFG SFR.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2016-06-17:
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New macros added XMC_VADC_SHS_FULL_SET_REG, XMC_VADC_RESULT_PRIORITY_AVAILABLE
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New Enum added XMC_VADC_SHS_GAIN_LEVEL_t and XMC_VADC_SYNCTR_EVAL_t
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - New APIs added are:
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncSlaveReadySignal
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_ChannelGetAssertedEvents
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetAssertedResultEvents
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetResultRegPriority
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_SetSyncReadySignal
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetSyncReadySignal
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *           - XMC_VADC_GROUP_GetResultRegPriority
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-02-06:
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new functions to remove channels from background request source, XMC_VADC_GLOBAL_Bac
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-06-24:
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added new function XMC_VADC_GLOBAL_SHS_SetAnalogReference() for XMC1 family
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2017-08-14:
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GLOBAL_DETAILED_RESULT_t
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *       You can cast the return of XMC_VADC_GLOBAL_GetDetailedResult() to a varible of type XMC_VA
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() to update AREF bitfield correctly
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-03-30:
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Changed XMC_VADC_GROUP_SetChannelAlias() to inline function
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetChannelAlias()
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2019-12-02:
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fix including files following the convention: angle brackets are used for standard include
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-09-03:
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Added XMC_VADC_GROUP_GetPowerMode()
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 2020-11-11:
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     - Fixed XMC_VADC_GLOBAL_SHS_SetAnalogReference() and XMC_VADC_GROUP_SetChannelAlias()
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * 
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @endcond
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifndef XMC_VADC_H
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_H
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * HEADER FILES
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_common.h"
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_scu.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #include "xmc_vadc_map.h"
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup XMClib XMC Peripheral Library
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @addtogroup VADC
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @brief Versatile Analog to Digital Converter (VADC) driver for XMC microcontroller family.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC microcontroller provides a series of analog input channels connected to a cluster of Ana
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Converters using the Successive Approximation Register (SAR) principle to convert analog input v
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * to discrete digital values.
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC1
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The XMC1x is based on Sample & Hold converters, where a cluster contains 2 Sample&Hold units whi
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * converter.
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter of the ADC cluster can operate independent of the others, controlled by a dedicat
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * registers and triggered by a dedicated group request source. The results of each channel can be 
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * dedicated channel-specific result register or in a group-specific result register.<BR>
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The Versatile Analog to Digital Converter module (VADC) of the XMC comprises a set of converter 
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can be operated either independently or via a common request source that emulates a background c
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Each converter block is equipped with a dedicated input multiplexer and dedicated request source
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * which together build separate groups.
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \if XMC4
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc4x.png"
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \else
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @image html "vadc_overview_xmc1x.png"
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \endif
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The VADC LLD is split into GLOBAL and GROUP related APIs.<BR>
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GLOBAL: </B><BR>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Global APIs act on the entire ADC module. Configures global configuration registers</LI>
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Allows configuration of the background request source of the VADC.</LI>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The clock related configurations for the VADC module are configured in the Global APIs/</LI>
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Global API names are prefixed by the \b XMC_VADC_GLOBAL_ and they accept ::XMC_VADC_GLOB
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the background request source of the VADC. The APIs which act on the background r
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_Background</LI>
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the sample and hold unit of the VADC. The APIs which act on the SHS related regis
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GLOBAL_SHS_</LI>
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <B>GROUP: </B><BR>
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <UL>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Group APIs act on a VADC group. Configures the group configuration registers</LI>
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the queue request source of the VADC. The APIs which act on the queue related reg
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Queue</LI>
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configures the scan request source of the VADC. The APIs which act on the scan related regis
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     are prefixed by \b XMC_VADC_GROUP_Scan</LI>
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>Configuration of the channels of each group are done by the API which have a prefix as
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     \b XMC_VADC_GROUP_Channel.</LI>
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * <LI>The Group API names are prefixed by the \b XMC_VADC_GROUP_ and they accept ::XMC_VADC_GROUP_
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *     one of its arguments.</LI>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * </UL><BR>
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @{
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * MACROS
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if ((UC_SERIES == XMC42)||(UC_SERIES == XMC41) || (UC_SERIES == XMC43))
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE           (1U) /*  Defines the availability of group resource in a
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE           (1U) /*  Defines the availability of scan request resour
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE           (1U) /*  Defines the availability of queue request resou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE            (1U) /*  Defines the availability of external multiplexe
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE        (1U) /*  Defines the availability of boundary check supp
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS      (1U) /*  Defines the availability of synchronous request
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS        (2U) /*  Defines the maximum number of groups available 
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT      (1U) /*  Defines the availability of boundary flags in a
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE         (1U) /*  Defines the external multiplexer channel select
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE             (0U) /* Defines the availability of sample and hold modu
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG          (0U) /* Defines the availability of sample and hold modu
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE    (1U) /* Define the availability of a source specific res
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC44 || UC_SERIES == XMC47 || UC_SERIES == XMC48)
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC45)
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (4U) /*  Defines the maximum number of groups available in
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (0U) /* Defines the availability of sample and hold module
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC14 || UC_SERIES == XMC13 || UC_SERIES == XMC12)
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (1U) /*  Defines the availability of group resource in a d
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (1U) /*  Defines the availability of scan request resource
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (1U) /*  Defines the availability of queue request resourc
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (1U) /*  Defines the availability of external multiplexer 
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (1U) /*  Defines the availability of boundary check suppor
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (1U) /*  Defines the availability of synchronous request s
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (1U) /*  Defines the availability of boundary flags in a d
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (1U) /*  Defines the external multiplexer channel selectio
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (1U) /* Defines the availability of sample and hold module
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (1U) /* Define the availability of a source specific resul
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (1U) /* Define the availability of a priority for result
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (UC_SERIES == XMC11)
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_AVAILABLE         (0U) /*  Defines the availability of group resource in a d
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GSCAN_AVAILABLE         (0U) /*  Defines the availability of scan request resource
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_QUEUE_AVAILABLE         (0U) /*  Defines the availability of queue request resourc
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_AVAILABLE          (0U) /*  Defines the availability of external multiplexer 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     device*/
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_AVAILABLE      (0U) /*  Defines the availability of boundary check suppor
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MULTIPLE_SLAVEGROUPS    (0U) /*  Defines the availability of synchronous request s
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_MAXIMUM_NUM_GROUPS      (2U) /*  Defines the maximum number of groups available in
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_BOUNDARY_FLAG_SELECT    (0U) /*  Defines the availability of boundary flags in a d
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_START_UP_CAL_ACTIVE (3U) /*  Defines the need for SHS startup calibration acti
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 devices */
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_CONV_ENABLE_FOR_XMC11   (*(uint32_t*) 0x40010500UL) /*  Defines the additional err
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     XMC1100 device for effective working*/
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_EMUX_CH_SEL_STYLE       (0U) /*  Defines the external multiplexer channel selectio
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     operation for a particular device*/
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_AVAILABLE           (1U) /* Defines the availability of sample and hold module
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_SHS_FULL_SET_REG        (0U) /* Defines the availability of sample and hold module
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_GROUP_SRCREG_AVAILABLE  (0U) /* Define the availability of a source specific resul
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_RESULT_PRIORITY_AVAILABLE (0U) /* Define the availability of a priority for result
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_PORTS               (16U) /* Defines the number of hardware ports that can be 
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     as triggers and gating signals */
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_RESULT_REGISTERS    (16U) /* Defines the number of result holding registers pe
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #define XMC_VADC_NUM_CHANNELS_PER_GROUP  (8U)  /**< Defines the number of ADC channels per group */
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * ENUMS
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef uint16_t XMC_VADC_RESULT_SIZE_t; /**< Type defined the converted result size to unsigned 16
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_GLOBAL_TypeDef XMC_VADC_GLOBAL_t; /**< Type defined the device header file vadc global
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC type*/
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef VADC_G_TypeDef XMC_VADC_GROUP_t; /**< Type defined the device header file vadc group regist
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                              type to VADC Group type*/
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef SHS_Type XMC_VADC_GLOBAL_SHS_t; /**< Type defined the sample and hold register structure*/
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the return status after execution of VADC specific API's. Use @ref XMC_VADC_STATUS_t fo
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STATUS
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_SUCCESS = 0,   /**< Returned when the API has been able to fulfill the callers re
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STATUS_ERROR          /**< Returned when the API cannot fulfill the request */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STATUS_t;
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various service requests lines. Each group can raise up to 4 service requests indep
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  all groups together have the possibility of raising 4 module wide service requests. Use @ref XM
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SR
 345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR0 = 0, /**< Group specific Service Request-0 */
 347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR1,     /**< Group specific Service Request-1 */
 348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR2,     /**< Group specific Service Request-2 */
 349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_GROUP_SR3,     /**< Group specific Service Request-3 */
 350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR0,    /**< Module Wide Common Service Request-0 */
 351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR1,    /**< Module Wide Common Service Request-1 */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR2,    /**< Module Wide Common Service Request-2 */
 353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SR_SHARED_SR3    /**< Module Wide Common Service Request-3 */
 354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SR_t;
 355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the mode of operation of a channel, when an ongoing conversion gets interrupted in betw
 358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_STARTMODE_t for this enumeration.
 359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_STARTMODE
 361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_WFS = 0, /**< An ongoing conversion completes without interruption */
 363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CIR,     /**< An ongoing conversion can be interrupted and resumed later*/
 364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_STARTMODE_CNR     /**< An ongoing conversion can be interrupted and never resumed */
 365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_STARTMODE_t;
 366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the edge sensitivity of the trigger signal which can assert a conversion.
 369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_EDGE_t for this enumeration.
 370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_EDGE
 372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_NONE = 0, /**< No external trigger. Conversion request can be asserted by s
 374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_FALLING,  /**< The falling edge of the external trigger can assert conversi
 375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_RISING,   /**< The rising edge of the external trigger can assert conversio
 376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_TRIGGER_EDGE_ANY       /**< Both the edges can assert conversion request */
 377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_EDGE_t;
 378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external trigger input selection possibilities, to assert a conversion. Refer the V
 381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  section of the reference manual for details of peripherals which can be used. Also refer xmc_va
 382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  detailed definitions of the peripherals which can take the control of these enumeration items.
 383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Use @ref XMC_VADC_TRIGGER_INPUT_SELECT_t for this enumeration.
 384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_TRIGGER_INPUT_SELECT
 386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_A = 0, /**< Trigger select signal A */
 388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_B,     /**< Trigger select signal B */
 389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_C,     /**< Trigger select signal C */
 390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_D,     /**< Trigger select signal D */
 391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_E,     /**< Trigger select signal E */
 392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_F,     /**< Trigger select signal F */
 393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_G,     /**< Trigger select signal G */
 394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_H,     /**< Trigger select signal H */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_I,     /**< Trigger select signal I */
 396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_J,     /**< Trigger select signal J */
 397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_K,     /**< Trigger select signal K */
 398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_L,     /**< Trigger select signal L */
 399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_M,     /**< Trigger select signal M */
 400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_N,     /**< Trigger select signal N */
 401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_O,     /**< Trigger select signal O */
 402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_TR_P      /**< Trigger select signal P */
 403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_TRIGGER_INPUT_SELECT_t;
 405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the external gating input selection possibilities, to gate the conversion requests. Ref
 408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  interconnects section of the reference manual for details of peripherals which can be used. Als
 409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of t
 410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  items. Use @ref XMC_VADC_GATE_INPUT_SELECT_t for this enumeration.
 411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATE_INPUT_SELECT
 413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_A = 0, /**< Gating select signal A */
 415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_B,     /**< Gating select signal B */
 416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_C,     /**< Gating select signal C */
 417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_D,     /**< Gating select signal D */
 418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_E,     /**< Gating select signal E */
 419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_F,     /**< Gating select signal F */
 420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_G,     /**< Gating select signal G */
 421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_H,     /**< Gating select signal H */
 422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_I,     /**< Gating select signal I */
 423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_J,     /**< Gating select signal J */
 424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_K,     /**< Gating select signal K */
 425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_L,     /**< Gating select signal L */
 426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_M,     /**< Gating select signal M */
 427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_N,     /**< Gating select signal N */
 428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_O,     /**< Gating select signal O */
 429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_REQ_GT_P      /**< Gating select signal P */
 430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATE_INPUT_SELECT_t;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the condition for gating the conversion requests. It can be used to set the ENGT field
 435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of ASMR/BSMR/QMR register respectively for auto_scan/background_scan/queue request sources.
 436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_GATEMODE_t for this enumeration.
 437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GATEMODE
 439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_BLOCK = 0,  /**< External triggers are permanently blocked */
 441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_IGNORE,     /**< External triggers are unconditionally passed */
 442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVEHIGH, /**< External trigger is passed only if the gate signal is high */
 443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GATEMODE_ACTIVELOW  /**< External trigger is passed only if the gate signal is low */
 444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GATEMODE_t;
 445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion result handling mode. Use @ref XMC_VADC_DMM_t for this enumeration.
 448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_DMM
 450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_REDUCTION_MODE = 0, /**< Standard Data reduction mode*/
 452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_FILTERING_MODE,     /**< Provide option to select Finite Impulse Response Filter (FI
 453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                         Infinite Impulse Response Filter (IIR)*/
 454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_DMM_DIFFERENCE_MODE,    /**< Difference mode is selected*/
 455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DMM_t;
 456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the conversion mode. It defines the resolution of conversion. Use XMC_VADC_CONVMODE_t f
 459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CONVMODE
 461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_12BIT       = 0,  /**< Results of conversion are 12bits wide */
 463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_10BIT       = 1,  /**< Results of conversion are 10bits wide */
 464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_8BIT        = 2,  /**< Results of conversion are 8bits wide */
 465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CONVMODE_FASTCOMPARE = 5  /**< Input signal compared with a preset range */
 466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CONVMODE_t;
 467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the output of a fast compare mode. Use @ref XMC_VADC_FAST_COMPARE_t for
 470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  this enumeration.
 471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_FAST_COMPARE
 473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_LOW = 0, /**< Input lower than than programmed reference */
 475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_HIGH,    /**< Input higher than than programmed reference */
 476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_FAST_COMPARE_UNKNOWN  /**< Unknown, Conversion probably still ongoing */
 477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_FAST_COMPARE_t;
 478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the type of scan request source to be used. It can choose between auto scan and backgrou
 481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * source methods. Use @ref XMC_VADC_SCAN_TYPE_t for this enumeration.
 482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_TYPE
 484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_GROUPSCAN = 0, /**< Auto scan mode of operation selected. Also called as Group
 486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_TYPE_BACKGROUND    /**< Background scan mode of operation selected. Also called as 
 487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_TYPE_t;
 488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the behavior of load event for the scan request source. Use @ref XMC_VADC_SCAN_LOAD_t fo
 491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SCAN_LOAD
 493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_OVERWRITE = 0, /**< The old set of channels is discarded in favor of the new s
 495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          awaiting conversion */
 496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SCAN_LOAD_COMBINE       /**< The new set of channels are combined with the pending chann
 497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          previous set */
 498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_LOAD_t;
 499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the conversion classes that can be selected for each channel. The enumeration members ho
 502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * global classes. The conversion classes decides the properties of conversion, like resolution, sa
 503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Use @ref XMC_VADC_CHANNEL_CONV_t for this enumeration.
 504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_CONV
 507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 = 0, /**< Conversion property set-0 specific to the group */
 509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GROUP_CLASS1,     /**< Conversion property set-1 specific to the group */
 510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,    /**< Conversion property set-0, Module wide */
 511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1    /**< Conversion property set-1, Module wide */
 512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONV_t;
 513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the references to boundary values used for limit checking feature. Each of these can be 
 516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * either an upper bound or a lower bound. Use @ref XMC_VADC_CHANNEL_BOUNDARY_t for this enumeratio
 517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY
 520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 = 0, /**< Group specific Boundary-0 value */
 522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1,     /**< Group specific Boundary-1 value */
 523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0,    /**< Module wide Boundary-0 value */
 524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1    /**< Module wide Boundary-1 value */
 525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_t;
 526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the voltage which the capacitor is charged to. Used in Broken wire detection feature. Us
 529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @ref XMC_VADC_CHANNEL_BWDCH_t for this enumeration.
 530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BWDCH
 532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAGND = 0, /**< Capacitor pre-charged to ground*/
 534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BWDCH_VAREF     /**< Capacitor pre-charged to reference voltage*/
 535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BWDCH_t;
 536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Defines the criteria for event generation by the channel. Use @ref XMC_VADC_CHANNEL_EVGEN_t fo
 539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_EVGEN
 541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_NEVER     = 0,  /**< No event generated */
 543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_INBOUND   = 1U, /**< Event generated when the result is within the normal 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPHIGH  = 1U, /**< Event generated when the result of fast compare opera
 545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_OUTBOUND  = 2U, /**< Event generated when the result is outside the normal
 546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_COMPLOW   = 2U, /**< Event generated when the result result of fast compar
 547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_EVGEN_ALWAYS    = 3U /**< Event generated always after conversion - unconditiona
 548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_EVGEN_t;
 549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the reference voltage selection for conversion. Use @ref XMC_VADC_CHANNEL_REF_t for this
 552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_REF
 554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_INTREF = 0, /**< Internal VARef */
 556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_REF_ALT_CH0    /**< External voltage available on Channel-0 of the perticular gr
 557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_REF_t;
 558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the criteria for boundary flag assertion. Use @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t
 561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_BOUNDARY_CONDITION
 564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND = 0, /**< Set Boundary condition criteria to asser
 566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND     /**< Set Boundary condition criteria to assert
 567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t;
 568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the event which can lead to a global service request assertion. Use @ref XMC_VADC_GLOBAL
 571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enumeration.
 572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_EVENT
 574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE = VADC_GLOBEFLAG_SEVGLB_Msk, /**< Background scan request sourc
 576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_EVENT_RESULT      = VADC_GLOBEFLAG_REVGLB_Msk  /**< Global result event */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_EVENT_t;
 578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the power modes of a VADC Group. Use @ref XMC_VADC_GROUP_POWERMODE_t for this enumeratio
 581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_POWERMODE
 583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_OFF       = 0, /**< Group is powered down */
 585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED1,     /**< Reserved */
 586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_RESERVED2,     /**< Reserved */
 587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_POWERMODE_NORMAL        /**< Group is powered up */
 588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_POWERMODE_t;
 589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the status of a VADC group (also known as kernel). Use @ref XMC_VADC_GROUP_STATE_t for 
 592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_STATE
 594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_IDLE = 0, /**< Idle and can convert if requested */
 596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_STATE_BUSY      /**< Busy with an ongoing conversion */
 597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_STATE_t;
 598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the reference to sample time and conversion mode settings. Use @ref XMC_VADC_GROUP_CONV
 601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  enumeration.
 602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_CONV
 604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_STD = 0, /**< Settings pertaining to channels directly attached to VADC modul
 606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CONV_EMUX    /**< Settings pertaining to channels connected to VADC via EMUX */
 607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONV_t;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbiter behavior. Use @ref XMC_VADC_GROUP_ARBMODE_t for this enumera
 611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_ARBMODE
 613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ALWAYS = 0, /**< Arbiter runs all the time */
 615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_ARBMODE_ONDEMAND    /**< Arbiter runs only if a conversion request is asserted by 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                           request sources */
 617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_ARBMODE_t;
 618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX mode of operation. Use @ref XMC_VADC_GROUP_EMUXMODE_t for this enumeration.
 621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXMODE
 623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SWCTRL = 0,     /**< Perform EMUX in Software control mode*/
 625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_STEADYMODE,     /**< Perform EMUX in Steady mode (Use EMUX set value)*/
 626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SINGLEMODE,     /**< Perform EMUX in Single step mode*/
 627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE,   /**< Perform EMUX in Sequence mode*/
 628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXMODE_t;
 629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the EMUX channel selection encoding scheme. Use @ref XMC_VADC_GROUP_EMUXCODE_t for this
 632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_EMUXCODE
 634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_BINARY = 0, /**< A linearly incrementing code serves are MUX-SEL */
 636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCODE_GRAY       /**< The MUX-SEL is gray encoded */
 637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCODE_t;
 638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the service request set used. Use @ref XMC_VADC_GROUP_IRQ_t for this enumeration.
 641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_IRQ
 643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_KERNEL = 0, /**< Refers to Group specific service request */
 645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_IRQ_SHARED     /**< Refers to Module wide service request */
 646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_IRQ_t;
 647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the alignment of the converted result. Use @ref XMC_VADC_RESULT_ALIGN_t for this enumer
 650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_ALIGN
 652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_LEFT = 0,  /**< Always align result to left */
 654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_ALIGN_RIGHT      /**< Always align result to right */
 655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_ALIGN_t;
 656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_RESULT_SUBTRATION
 658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_LEFT_ALIGN  = 0U,  /**< Always align result to left */
 660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_12BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_LEFT_ALIGN  = 2U,  /**< Always align result to left */
 662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_10BIT_RIGHT_ALIGN = 0U,  /**< Always align result to right */
 663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_LEFT_ALIGN   = 4U,  /**< Always align result to left */
 664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_RESULT_SUBTRATION_8BIT_RIGHT_ALIGN  = 0U,  /**< Always align result to right */
 665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_SUBTRATION_t;
 666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the request source arbitration priority. Use @ref XMC_VADC_GROUP_RS_PRIORITY_t for this
 669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_RS_PRIORITY
 671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_0 = 0, /**< Lowest priority for the request source*/
 673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_1,     /**< Second lowest priority for the request source*/
 674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_2,     /**< Second highest priority for the request source*/
 675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_RS_PRIORITY_3,     /**< Highest priority for the request source*/
 676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_RS_PRIORITY_t;
 677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the various modes for the boundary flag. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t f
 680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_BOUNDARY_FLAG_MODE
 682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED = 0,       /**< Disable boundary flag*/
 684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED,            /**< Always enable boundary*/
 685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW, /**< Enable boundary flag when gate level i
 686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH /**< Enable boundary flag when gate level i
 687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t;
 688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Defines the boundary select for Channel. Use @ref XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t for this 
 692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_SELECT
 694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_LOWER_BOUND = 0U,       /**< Select the lower boundary*/
 696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_SELECT_UPPER_BOUND = 2U        /**< Selects the upper boundary*/
 697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_SELECT_t;
 698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the group indices. Use @ref XMC_VADC_GROUP_INDEX_t for this enumeration.
 702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GROUP_INDEX
 704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_0   = 0,
 706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_1,
 707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_2,
 709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_INDEX_3
 710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_INDEX_t;
 712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * Defines channel alias.
 715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** * All enum items are available for channels 0 and 1. Other Channels can accept only XMC_VADC_CHANNE
 716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** */
 717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_CHANNEL_ALIAS
 718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_DISABLED = -1,
 720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH0 = 0,
 721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH1 = 1,
 722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH2 = 2,
 723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH3 = 3,
 724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH4 = 4,
 725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH5 = 5,
 726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH6 = 6,
 727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_CHANNEL_ALIAS_CH7 = 7
 728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_ALIAS_t;
 729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selection of the reference voltage that is required for conversions (VREF).
 734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_AREF
 736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_EXTERNAL_VDD_UPPER_RANGE = 0 << SHS_SHSCFG_AREF_Pos, /**< External refer
 738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_UPPER_RANGE = 2 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_AREF_INTERNAL_VDD_LOWER_RANGE = 3 << SHS_SHSCFG_AREF_Pos, /**< Internal refer
 740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_AREF_t;
 741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the gain calibration selection.
 745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_GAIN_LEVEL
 747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_0 = SHS_CALOC0_CALOFFVAL0_Pos, /**< Select the calibration value for gain
 749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_1 = SHS_CALOC0_CALOFFVAL1_Pos, /**< Select the calibration value for gain
 750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_2 = SHS_CALOC0_CALOFFVAL2_Pos, /**< Select the calibration value for gain
 751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_GAIN_LEVEL_3 = SHS_CALOC0_CALOFFVAL3_Pos  /**< Select the calibration value for gain
 752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_GAIN_LEVEL_t;
 753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the Delta sigma loop.
 757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SHS_LOOP_CH
 759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_0 = SHS_LOOP_LPCH0_Pos, /**< Select Delta-sigma loop 0*/
 761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SHS_LOOP_CH_1 = SHS_LOOP_LPCH1_Pos /**< Select Delta-sigma loop 1*/
 762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SHS_LOOP_CH_t;
 763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides the order in which the SHS should do the calibration
 766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER
 768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_POST_CONV = 0, /**< Calibration occur after conversion take
 770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_PRE_CONV   /**< Calibration occur before conversion takes p
 771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t;
 772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Provides possible routing values for the boundary flag.
 777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_BOUNDARY_NODE
 779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_0 = 0U, /**<Route the Group boundary flag to Common b
 781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_1,      /**<Route the Group boundary flag to Common b
 782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_2,      /**<Route the Group boundary flag to Common b
 783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_BOUNDARY_FLAG_3,      /**<Route the Group boundary flag to Common b
 784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_0,  /**<Route the Group boundary flag to Common Service Req
 785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_1,  /**<Route the Group boundary flag to Common Service Req
 786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_2,  /**<Route the Group boundary flag to Common Service Req
 787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_BOUNDARY_NODE_COMMON_SR_LINE_3   /**<Route the Group boundary flag to Common Service Req
 788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_BOUNDARY_NODE_t;
 789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 791:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 792:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 793:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Defines the ready signal selection
 794:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 795:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef enum XMC_VADC_SYNCTR_EVAL
 796:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 797:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_1 = VADC_G_SYNCTR_EVALR1_Msk, /**<Mask to set the EVAL1 bits of SYNCTR */
 798:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS > 2U)
 799:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_2 = VADC_G_SYNCTR_EVALR2_Msk, /**<Mask to set the EVAL2 bits of SYNCTR */
 800:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_SYNCTR_EVAL_3 = VADC_G_SYNCTR_EVALR3_Msk  /**<Mask to set the EVAL3 bits of SYNCTR */
 801:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 802:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SYNCTR_EVAL_t;
 803:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 804:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
 805:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * DATA STRUCTURES
 806:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
 807:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard start*/
 808:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
 809:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma push
 810:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma anon_unions
 811:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
 812:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning 586
 813:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 814:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 815:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 816:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC scan request source. Use type @ref XMC_VADC_SCAN_CONFIG_t for t
 817:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 818:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_SCAN_CONFIG
 819:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 820:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 821:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how scan request source would
 822:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 823:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter. If the Conversion s
 824:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          selected as Cancel inject repeat/Never mode then this fiel
 825:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          priority of scan request source. Uses @ref XMC_VADC_GROUP_
 826:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 827:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 828:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 829:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 830:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 831:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Use any one Group related result register as the 
 832:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
 833:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
 834:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 835:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 836:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 837:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
 838:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger. U
 839:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_INPUT_SELECT_t enumeration*/
 840:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 841:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal. Uses @ref
 842:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_TRIGGER_EDGE_t */
 843:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
 844:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating. Us
 845:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_GATE_INPUT_SELECT_t */
 846:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
 847:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Decides whether timer mode for equi-distant sampl
 848:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       activated or not.*/
 849:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
 850:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 851:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asctrl;
 852:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 853:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 854:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 855:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 856:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 857:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 2;
 858:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversions be initiated by external hardware trigger 
 859:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t req_src_interrupt  : 1;  /**< Request source event can be generated after a conversi
 860:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_auto_scan   : 1;  /**< Enables the continuous conversion mode. Conversion com
 861:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  of the last channel in a scan sequence will cause 
 862:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t load_mode          : 1;  /**< Selects load event mode. Uses @ref XMC_VADC_SCAN_LOAD_
 863:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 26;
 864:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 865:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t asmr;
 866:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 867:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_SCAN_CONFIG_t;
 868:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 869:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 870:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef XMC_VADC_SCAN_CONFIG_t XMC_VADC_BACKGROUND_CONFIG_t; /**< Type defined the scan configurati
 871:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                                  structure for background Request S
 872:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 873:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 874:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing the VADC channel. Use type XMC_VADC_CHANNEL_CONFIG_t for this enumeratio
 875:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 876:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_CHANNEL_CONFIG
 877:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 878:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 879:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 880:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 881:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 882:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t input_class                : 2;  /**< Input conversion class selection.
 883:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_CONV_t */
 884:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 2;
 885:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t lower_boundary_select      : 2;  /**< Which boundary register serves as lower bound?
 886:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 887:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t upper_boundary_select      : 2;  /**< Which boundary register serves as upper bound?
 888:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Accepts enum @ref XMC_VADC_CHANNEL_BOUNDAR
 889:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_criteria         : 2;  /**< When should an event be generated?
 890:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_EVGEN_t */
 891:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sync_conversion            : 1;  /**< Enables synchronous conversion for the configu
 892:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t alternate_reference        : 1;  /**< Input reference voltage selection either VARef
 893:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_REF_t*/
 894:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 4;
 895:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_reg_number          : 4;  /**< Group result register number */
 896:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t use_global_result          : 1;  /**< Use global result register for background requ
 897:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result_alignment           : 1;  /**< Alignment of the results read in the result re
 898:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_RESULT_ALIGN_t */
 899:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                            : 6;
 900:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect_channel : 2;  /**< Source to be used to charge the capacitor for 
 901:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BWDCH_t. */
 902:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t broken_wire_detect         : 1;  /**< Configures extra phase before the capacitor is
 903:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 904:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t chctr;
 905:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 906:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 907:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 908:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 909:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 910:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 8;
 911:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 912:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch0 : 1; /**< Condition for which the boundary flag should cha
 913:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                        Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDITIO
 914:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch1 : 1; /**< Condition for which the boundary flag should cha
 915:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 916:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch2 : 1; /**< Condition for which the boundary flag should cha
 917:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 918:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t flag_output_condition_ch3 : 1; /**< Condition for which the boundary flag should cha
 919:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                          Uses @ref XMC_VADC_CHANNEL_BOUNDARY_CONDIT
 920:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 921:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 922:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 923:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 4;
 924:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 925:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch0  : 1; /**< Inverts boundary flag output.*/
 926:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch1  : 1; /**< Inverts boundary flag output.*/
 927:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch2  : 1; /**< Inverts boundary flag output.*/
 928:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t invert_boundary_flag_ch3  : 1; /**< Inverts boundary flag output.*/
 929:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 930:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
 931:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch0  : 1; /**< Enable the boundary flag output on the specific 
 932:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch1  : 1; /**< Enable the boundary flag output on the specific 
 933:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch2  : 1; /**< Enable the boundary flag output on the specific 
 934:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_output_ch3  : 1; /**< Enable the boundary flag output on the specific 
 935:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 936:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 12;
 937:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 938:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bfl;
 939:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 940:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
 941:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 942:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 943:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 944:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 945:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch0    : 4; /**< Specify the basic operation of boundary flag 0
 946:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 947:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch1    : 4; /**< Specify the basic operation of boundary flag 1
 948:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 949:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch2    : 4; /**< Specify the basic operation of boundary flag 2
 950:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 951:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary_flag_mode_ch3    : 4; /**< Specify the basic operation of boundary flag 3
 952:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref  XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_
 953:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 16;
 954:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 955:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t bflc;
 956:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 957:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
 958:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   bool    channel_priority;  /**< Only non priority channels can be converted by Background Request
 959:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   int8_t  alias_channel;     /**< Specifies the channel which has to be aliased with CH0/CH1 (which
 960:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Force the value to \b(int8_t)-1 to bypass alias feature.
 961:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     Uses @ref XMC_VADC_CHANNEL_ALIAS_t  for configuration.*/
 962:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_CHANNEL_CONFIG_t;
 963:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 964:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 965:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize a queue entry. Use type @ref XMC_VADC_QUEUE_ENTRY_t.
 966:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 967:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_ENTRY
 968:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 969:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 970:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 971:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 972:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 973:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_num        : 5;  /**< Channel number associated with this queue entry.<BR>Ra
 974:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t refill_needed      : 1;  /**< Conversion completed channel gets inserted back into t
 975:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t generate_interrupt : 1;  /**< Generates a queue request source event */
 976:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger   : 1;  /**< Conversion requests are raised on an external trigger.
 977:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                    : 24;
 978:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 979:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
 980:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qinr0;
 981:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
 982:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_ENTRY_t;
 983:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
 984:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
 985:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure initializing a VADC queue request source. Use type @ref XMC_VADC_QUEUE_CONFIG_t.
 986:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
 987:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_QUEUE_CONFIG
 988:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
 989:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t conv_start_mode  : 2;  /**< One converter is shared between the queue and scan request s
 990:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          group. This field determines how queue request source woul
 991:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                          conversion. Uses @ref XMC_VADC_STARTMODE_t */
 992:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   uint32_t req_src_priority : 2;  /**< Request source priority for the arbiter.Uses @ref XMC_VADC_G
 993:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
 994:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
 995:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
 996:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
 997:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_GROUP_SRCREG_AVAILABLE == (1U))
 998:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t src_specific_result_reg : 4;  /**< Uses any one Group related result register as the
 999:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     for all conversions results. To use the  indivi
1000:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                     from each channel configuration, configure this
1001:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1002:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1003:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1004:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1005:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_signal          : 4;  /**< Select one of the 16 possibilities for trigger.
1006:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_INPUT_SELECT_t */
1007:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1008:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t trigger_edge            : 2;  /**< Edge selection for trigger signal.
1009:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_TRIGGER_EDGE_t */
1010:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 1;
1011:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t gate_signal             : 4;  /**< Select one of the 16 possibilities for gating.
1012:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GATE_INPUT_SELECT_t */
1013:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 8;
1014:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t timer_mode              : 1;  /**< Timer mode for equi-distant sampling shall be act
1015:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 3;
1016:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1017:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qctrl0;
1018:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1019:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1020:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1021:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1022:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1023:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 2;
1024:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t external_trigger  : 1;  /**< Are external triggers supported? */
1025:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                   : 29;
1026:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1027:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t qmr0;
1028:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1029:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_QUEUE_CONFIG_t;
1030:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1031:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1032:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1033:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the global input class configuration. Configured parameters are sample 
1034:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1035:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1036:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLASS
1037:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1038:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1039:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1040:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1041:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1042:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1043:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1044:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1045:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1046:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1047:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1048:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
1049:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1050:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1051:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1052:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1053:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1054:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1055:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1056:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 16;
1057:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1058:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1059:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globiclass;
1060:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1061:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLASS_t;
1062:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1063:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1064:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1065:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize converter and arbiter clock configuration
1066:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1067:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CLOCK
1068:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1069:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1070:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1071:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1072:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1073:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1074:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_clock_divider     : 5;  /**< Clock for the converter. <BR>Range: [0x0 to 0x1F
1075:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 2;
1076:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t msb_conversion_clock     : 1;  /**< Additional clock cycle for analog converter */
1077:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_clock_divider    : 2;  /**< Request source arbiter clock divider. <BR>Range:
1078:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 5;
1079:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 17;
1080:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1081:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globcfg;
1082:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1083:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CLOCK_t;
1084:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1085:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1086:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1087:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1088:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize the VADC Global functions
1089:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1090:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_CONFIG
1091:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1092:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1093:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1094:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1095:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1096:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1097:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1098:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1099:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globbound;
1102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE != 0U)
1104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLOCK_t clock_config; /**< ADC clock configurations*/
1105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class0;      /**< ADC input conversion configurations for GLOBICLASS[0]*
1107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_CLASS_t  class1;      /**< ADC input conversion configurations for GLOBICLASS[1]*
1108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Data reduction stages */
1114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Results of the next conversion will not be overwr
1116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       result register until the previous value is r
1117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 6;
1118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t globrcr;
1121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t module_disable              : 1;  /**< Disables the module clock.*/
1127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 2;
1128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t disable_sleep_mode_control  : 1;  /**< Set it to true in order to disable the Sleep 
1129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                             : 28;
1130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t clc;
1132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_CONFIG_t;
1134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  Structure to initialize the group input class configuration. Configured parameters are sample t
1138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  conversion Mode.
1139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CLASS
1141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sample_time_std_conv            : 5;  /**< Sample time for channels directly connect
1147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_standard        : 3;  /**< Conversion mode for channels directly con
1150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sampling_phase_emux_channel     : 5;  /**< Sample time for channels connected via EM
1153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               <BR>Range: [0x0 to 0x1F] */
1154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 3;
1155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t conversion_mode_emux            : 3;  /**< Conversion mode for channels connected vi
1156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                               Uses @ref XMC_VADC_CONVMODE_t */
1157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                                 : 5;
1158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_iclass0;
1160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CLASS_t;
1162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  EMUX related configuration structure.
1166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_EMUXCFG
1168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t starting_external_channel : 3;  /**< External channel number to which the VADC will
1174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         generate a control signal (needed to select
1175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         the analog multiplexer)*/
1176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 13;
1177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 10; /**< The Channel to which the EMUX is connected. */
1179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t connected_channel         : 5;  /**< The Channel to which the EMUX is connected. */
1181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 5;
1182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_mode                 : 2;  /**< Selects the external multiplexer modes: Steady,
1184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         Uses @ref XMC_VADC_GROUP_EMUXMODE_t*/
1185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_coding               : 1;  /**< Select Binary or Gray coding. Uses @ref XMC_VAD
1186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t stce_usage                : 1;  /**< Use STCE for each conversion of an external cha
1187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
1188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_select_style : 1;  /**< Selects the style of configuring the \b connect
1189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                         (Each bit represents the channel or entire 
1190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 1;
1191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                           : 2;
1193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_emuxctr;
1196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_EMUXCFG_t;
1198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Group Configuration Data Structures
1202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GROUP_CONFIG
1205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_EMUXCFG_t emux_config;    /**< External multiplexer related configurations */
1207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class0;           /**< ADC input conversion configurations for GxICLASS[0]
1208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GROUP_CLASS_t class1;           /**< ADC input conversion configurations for GxICLASS[1]
1209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary0  : 12;  /**< Boundary value for results comparison*/
1214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t boundary1  : 12;  /**< Boundary value for results comparison*/
1216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t            : 4;
1217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_bound;
1219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 4;
1225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbitration_round_length : 2;  /**< Number of arbiter slots to be considered */
1226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 1;
1227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t arbiter_mode             : 1;  /**< Arbiter mode - Select either Continuous mode or 
1228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_ARBMODE_t */
1229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 24;
1230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_arbcfg;
1232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GROUP_CONFIG_t;
1234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *   Structure to initialize VADC Group result register.
1237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_RESULT_CONFIG
1240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 16;
1246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_control  : 4;  /**< Configures the data reduction stages */
1247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t post_processing_mode    : 2;  /**< Result data processing mode. Uses @ref  XMC_VADC_
1248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       For normal operation select
1249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       XMC_VADC_DMM_t::XMC_VADC_DMM_REDUCTION_MODE
1250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       and data_reduction_control as 0*/
1251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 2;
1252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t wait_for_read_mode      : 1;  /**< Allow the conversion only after previous results 
1253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t part_of_fifo            : 2;  /**< Make the result register a part of Result FIFO? *
1254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                         : 4;
1255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t event_gen_enable        : 1;  /**< Generates an event on availability of new result.
1256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t g_rcr;
1258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_RESULT_CONFIG_t;
1260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
1262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Structure to initialize the Stepper configurations
1265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_STEP_CONFIG
1267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step0            : 3;  /**< Select a Sample and hold unit for the stepper's 
1273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step0             : 1; /**< Should the step be added to the sequence */
1275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step1            : 3;  /**< Select a Sample and hold unit for the stepper's 
1276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step1             : 1; /**< Should the step be added to the sequence */
1278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step2            : 3;  /**< Select a Sample and hold unit for the stepper's 
1279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step2             : 1; /**< Should the step be added to the sequence */
1281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step3            : 3;  /**< Select a Sample and hold unit for the stepper's 
1282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step3             : 1; /**< Should the step be added to the sequence */
1284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step4            : 3;  /**< Select a Sample and hold unit for the stepper's 
1285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step4             : 1; /**< Should the step be added to the sequence */
1287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step5            : 3;  /**< Select a Sample and hold unit for the stepper's 
1288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step5             : 1; /**< Should the step be added to the sequence */
1290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step6            : 3;  /**< Select a Sample and hold unit for the stepper's 
1291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step6             : 1; /**< Should the step be added to the sequence */
1293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t sh_unit_step7            : 3;  /**< Select a Sample and hold unit for the stepper's 
1294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                       Uses @ref XMC_VADC_GROUP_INDEX_t*/
1295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t enable_step7             : 1; /**< Should the step be added to the sequence */
1296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t stepcfg;
1299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_STEP_CONFIG_t;
1301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sample and hold Initialization structure
1304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_SHS_CONFIG
1306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t shs_clock_divider        : 4; /**< The divider value for the SHS clock. Range: [0x0 
1313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 6;
1314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 10;
1316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t analog_reference_select  : 2; /**< It is possible to different reference voltage for
1318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t                          : 20;
1319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t shscfg;
1321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
1323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_VADC_GLOBAL_SHS_CALIBRATION_ORDER_t calibration_order; /**< order in which the calibration sh
1324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_SHS_CONFIG_t;
1326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed global result structure
1331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_GLOBAL_DETAILED_RESULT
1333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t group_number             : 4;  /**< Indicates the group to which the channel_number 
1340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1344:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1345:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1346:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1347:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1348:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1349:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_GLOBAL_DETAILED_RESULT_t;
1350:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1351:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1352:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Detailed channel result structure
1353:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1354:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** typedef struct XMC_VADC_DETAILED_RESULT
1355:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1356:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   union
1357:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   {
1358:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     struct
1359:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     {
1360:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t result                   : 16; /**< Result of the Analog to digital conversion*/
1361:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t data_reduction_counter   : 4;  /**< Results reduction counter value*/
1362:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t channel_number           : 5;  /**< Converted channel number*/
1363:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t emux_channel_number      : 3;   /**< Converted external multiplexer channel number.
1364:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                                  Only applicable for GxRES[0] result register*/
1365:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t converted_request_source : 2;  /**< Converted request source*/
1366:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t fast_compare_result      : 1;  /**< Fast compare result if conversion mode is fast c
1367:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****       uint32_t vaild_result             : 1;  /**< Valid flag is set when a new result is available
1368:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     };
1369:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     uint32_t res;
1370:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   };
1371:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** } XMC_VADC_DETAILED_RESULT_t;
1372:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1373:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1374:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /*Anonymous structure/union guard end*/
1375:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if defined(__CC_ARM)
1376:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma pop
1377:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #elif defined(__TASKING__)
1378:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #pragma warning restore
1379:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1380:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1381:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * static inline functions
1382:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1383:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1384:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1385:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE bool XMC_VADC_CHECK_GROUP_PTR(XMC_VADC_GROUP_t *const group_ptr)
1386:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1387:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS == 4U)
1388:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1) || (group_ptr == VADC_G2) || (group_ptr 
1389:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #else
1390:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return ((group_ptr == VADC_G0) || (group_ptr == VADC_G1));
1391:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1392:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1393:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1394:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**************************************************************************************************
1395:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * API Prototypes
1396:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  **************************************************************************************************
1397:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1398:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #ifdef __cplusplus
1399:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** extern "C" {
1400:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1401:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1402:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1403:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1404:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1405:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1406:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1407:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1408:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module.<BR>\n
1409:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would ungate the clock to the VADC module (if applicable). Also this API would bring
1410:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module out of reset state(if applicable), by asserting the appropriate registers.
1411:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_UngatePeripheralClock() and XMC_SCU_RESET_DeassertPeripheral
1412:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * if needed. Directly accessed register is  COMPARATOR.ORCCTRL (Refer to the errata for XMC1100).
1413:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1414:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1415:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableModule().
1416:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1417:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_EnableModule(void);
1418:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1419:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1420:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param None
1421:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1422:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1423:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1424:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1425:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module.<BR>\n
1426:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would gate the clock to the VADC module (if applicable). Also this API would put
1427:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the VADC module into the reset state(if applicable) by asserting the appropriate registers.
1428:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * This API would invoke XMC_SCU_CLOCK_GatePeripheralClock() and XMC_SCU_RESET_AssertPeripheralRese
1429:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1430:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1431:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModule().
1432:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1433:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_DisableModule(void);
1434:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1435:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1436:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1437:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module.
1438:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config Pointer to initialization data structure
1439:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1440:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1441:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1442:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1443:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes the VADC global module with the associated configuration structure pointed by \a con
1444:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enables the global access to registers by configuring reset and clock un-gating for selected dev
1445:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * initializes global class, boundary , result resources by setting GLOBICLASS,GLOBBOUND,GLOBRCR re
1446:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * configures the global analog and digital clock dividers by setting GLOBCFG register. Refer relat
1447:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the configurations later in the program.
1448:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1449:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1450:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_ClockInit()<BR>
1451:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1452:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *conf
1453:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1454:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1455:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1456:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1457:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1458:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1459:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1460:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1461:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the VADC module clock.\n\n Call this API before any further configuration of VADC. It se
1462:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * register to enable.
1463:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1464:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1465:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1466:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1467:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1468:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1469:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1470:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Enable:Wrong Module Pointer", (global_ptr == VADC))
1471:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_DISR_Msk);
1472:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1473:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1474:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1475:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1476:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1477:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1478:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1479:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1480:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1481:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the VADC module clock.\n\n After this API call, no conversion will occur. Call
1482:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableModuleClock() to enable the VADC module later in the program.
1483:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1484:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1485:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *  XMC_VADC_GLOBAL_Init()
1486:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1487:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1488:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableModuleClock(XMC_VADC_GLOBAL_t *const global_ptr)
1489:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1490:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_Disable:Wrong Module Pointer", (global_ptr == VADC))
1491:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_DISR_Pos);
1492:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1493:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1494:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1495:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1496:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1497:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1498:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1499:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1500:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1501:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables VADC module to sleep if a sleep request comes.\n\n
1502:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * It resets the EDIS bit of CLC register for enabling the sleep mode.
1503:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1504:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1505:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableSleepMode().
1506:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1507:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1508:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1509:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1510:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC &= ~((uint32_t)VADC_CLC_EDIS_Msk);
1511:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1512:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1513:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1514:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1515:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr    Constant pointer to the VADC module.
1516:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1517:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1518:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1519:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1520:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Ignores the sleep mode request for the VADC.\n\n
1521:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * With the sleep feature enabled, the module will respond to sleep
1522:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * requests by going into a low power mode. It resets the EDIS bit of CLC register for enabling the
1523:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1524:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1525:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnableSleepMode().
1526:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1527:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableSleepMode(XMC_VADC_GLOBAL_t *const global_ptr)
1528:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1529:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableSleepMode:Wrong Module Pointer", (global_ptr == VADC))
1530:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->CLC |= (uint32_t) ((uint32_t)1 <<  VADC_CLC_EDIS_Pos);
1531:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1532:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1533:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1534:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1535:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1536:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1537:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to the data structure containing clock configuration data
1538:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1539:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1540:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1541:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1542:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the VADC clock.<BR>\n
1543:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the clock configuration of the VADC module using the config structure pointed by \a conf
1544:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * The clock to the analog converter and to the request source arbiter is configured by setting the
1545:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1546:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1547:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1548:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1549:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1550:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ClockInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_
1551:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1552:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ClockInit:Wrong Module Pointer", (global_ptr == VADC))
1553:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1554:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Write the Clock configuration into the GLOBCFG register */
1555:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG = (uint32_t)(config->globcfg | (VADC_GLOBCFG_DIVWC_Msk));
1556:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1557:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1558:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1559:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1560:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1561:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1562:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Conversion class parameter structure
1563:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param conv_type configure the input call for either standard conversion or EMUX related convers
1564:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param set_num Conversion class set<BR>
1565:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                Range: [0x0, 0x1]
1566:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1567:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1568:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Configures the ADC conversion settings like sample time and resolution.<BR>\n
1569:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Sets up the conversion settings for vadc global resource associated with \a config structure. It
1570:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * conversion class properties like sampling time and resolution for selected \a conv_type channels
1571:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the GLOBALICLASS register specified by \a set_num with the required settings.
1572:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1573:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1574:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1575:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1576:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1577:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1578:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1579:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLAS
1580:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****                                     const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num);
1581:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1582:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1583:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1584:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC global module
1585:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param config  Pointer to result configuration data structure
1586:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1587:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1588:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1589:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1590:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes global result register.<BR>\n
1591:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Initializes Global Result Register with specified settings configured in the \a config structure
1592:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * results in configuration of GLOBRCR register. This helps in configuring the Data reduction mode,
1593:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * , wait for read mode on the GLOBRES register.
1594:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1595:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1596:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1597:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1598:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1599:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1600:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1601:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_ResultInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC
1602:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1603:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_ResultInit:Wrong Module Pointer", (global_ptr == VADC))
1604:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1605:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   /* Configure GLOBRCR*/
1606:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBRCR = config->g_rcr;
1607:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1608:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1609:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1610:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1611:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1612:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1613:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1614:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1615:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1616:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of G
1617:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * enable the startup calibration feature. After turning it on, it loops until all active groups fi
1618:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Call XMC_VADC_GLOBAL_Enable() and XMC_VADC_GLOBAL_ClockInit() before calling this API in sequenc
1619:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisableStartupCalibration() can disable the calibration feature at runtime.
1620:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1621:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1622:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1623:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1624:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1625:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1626:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr);
1627:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1628:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1629:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1630:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1631:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr  Constant pointer to the VADC module.
1632:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1633:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1634:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1635:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1636:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the startup calibration feature of the VADC module.\n\n It configures the SUCAL bit of 
1637:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * disable the startup calibration feature. Calling the API XMC_VADC_GLOBAL_EnsableStartupCalibrati
1638:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * calibration feature at runtime.
1639:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1640:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1641:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1642:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1643:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1644:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisableStartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
1645:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1646:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisableStartupCalibration:Wrong Module Pointer", (global_ptr == VADC)
1647:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= ~((uint32_t)VADC_GLOBCFG_SUCAL_Msk);
1648:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1649:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1650:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
1651:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1652:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1653:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1654:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be disabled. <BR>
1655:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1656:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1657:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1658:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1659:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1660:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Disables the post calibration for a particular group specified as \a group_number.\n\n It config
1661:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to disable the post calibration feature. Call XMC_VADC_GLOBAL_Enable() and
1662:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit() before calling this API in sequence. Calling the API
1663:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_EnablePostCalibration() can enable back the calibration feature at runtime.
1664:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1665:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1666:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_Enable()<BR>
1667:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_ClockInit()<BR>
1668:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1669:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1670:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1671:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1672:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, ui
1673:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1674:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1675:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1676:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_numbe
1677:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1678:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1679:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1680:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1681:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module
1682:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group_number  group number whose post calibration feature is to be enabled. <BR>
1683:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *                      Range[0x0 to 0x3] Accepts the enum ::XMC_VADC_GROUP_INDEX_t
1684:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1685:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1686:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1687:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1688:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Enables the post calibration for a particular group specified as \a group_number.\n\n It configu
1689:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * of GLOBCFG register to enable the post calibration feature. Calling the API XMC_VADC_GLOBAL_Disa
1690:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * can disable the calibration feature at runtime.
1691:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1692:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1693:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_DisablePostCalibration()<BR>
1694:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1695:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1696:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE void XMC_VADC_GLOBAL_EnablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uin
1697:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
1698:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_EnablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))
1699:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1700:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   global_ptr->GLOBCFG &= (~ (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_nu
1701:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
1702:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1703:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1704:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
1705:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1706:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1707:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1708:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary0  Boundary-0 Value<BR>Range[0 - 4095]
1709:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary1  Boundary-1 Value<BR>Range[0 - 4095]
1710:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1711:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1712:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1713:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1714:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs the boundaries with \a boundary0 and boundary1 for result comparison.\n\n These two bou
1715:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * absolute boundaries. They define a range against which the result of a conversion can be compare
1716:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any c
1717:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * values entered here form a boundary pallete. There are dedicated upper and lower boundary regist
1718:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * GLOBBOUND1 who will derive their values from this palette.
1719:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1720:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1721:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1722:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1723:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1724:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetBoundaries(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t boundary0, c
1725:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1726:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1727:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1728:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1729:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param selection The boundary value selected for \b boundary_value.
1730:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param boundary_value  Boundary Value<BR>Range[0 - 4095]
1731:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1732:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1733:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1734:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1735:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Programs either the boundary 0 or boundary 1 for result comparison.\n\n This defines a range aga
1736:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result of a conversion can be compared. In the fast compare mode, the two boundaries provide
1737:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * capability to a compare value.
1738:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1739:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1740:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1741:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1742:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1743:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_SetIndividualBoundary(XMC_VADC_GLOBAL_t *const global_ptr,
1744:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const XMC_VADC_CHANNEL_BOUNDARY_t selection,
1745:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****     const uint16_t boundary_value);
1746:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1747:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1748:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #if (XMC_VADC_EMUX_AVAILABLE== 1U)
1749:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1750:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1751:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr   Constant pointer to the VADC module
1752:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param emuxif       The EMUX interface<BR>Range[0x0 - 0x1]
1753:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param group        The VADC group which must be bound to the desired emux
1754:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1755:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return None
1756:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1757:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1758:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Binds a VADC \a group to an EMUX interface specified in \a emuxif.<BR>\n
1759:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Selects which group's scan request source will control the EMUX interface (set of control select
1760:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * By passing \b group it would configure that group's scan request source to control the EMUX sele
1761:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \b emuxif.
1762:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1763:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1764:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * None
1765:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1766:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** void XMC_VADC_GLOBAL_BindGroupToEMux(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t emuxif, co
1767:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** #endif
1768:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1769:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** /**
1770:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1771:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @param global_ptr Constant pointer to the VADC module.
1772:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1773:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @return uint32_t Complete global result register value GLOBRES
1774:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1775:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Description:</b><br>
1776:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * Retrieves the complete result from the global result register associated with the \a global_ptr.
1777:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the result register GLOBRES for the validity of the data. If the validity is assured, data is fi
1778:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * the global result register, cached locally next and subsequently returned to the caller.
1779:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1780:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * @note You can cast the return to a varible of type XMC_VADC_GLOBAL_DETAILED_RESULT_t to easily a
1781:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  *
1782:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * \par<b>Related APIs:</b><BR>
1783:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  * XMC_VADC_GLOBAL_GetResult()
1784:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****  */
1785:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** __STATIC_INLINE uint32_t XMC_VADC_GLOBAL_GetDetailedResult(XMC_VADC_GLOBAL_t *const global_ptr)
1786:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** {
  25              	 .loc 1 1786 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 7860     	 str r0,[r7,#4]
1787:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetDetailedResult:Wrong Module Pointer", (global_ptr == VADC))
1788:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** 
1789:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h ****   return (global_ptr->GLOBRES);
  39              	 .loc 1 1789 0
  40 0008 7A68     	 ldr r2,[r7,#4]
  41 000a C023     	 mov r3,#192
  42 000c 9B00     	 lsl r3,r3,#2
  43 000e D358     	 ldr r3,[r2,r3]
1790:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_vadc.h **** }
  44              	 .loc 1 1790 0
  45 0010 181C     	 mov r0,r3
  46 0012 BD46     	 mov sp,r7
  47 0014 02B0     	 add sp,sp,#8
  48              	 
  49 0016 80BD     	 pop {r7,pc}
  50              	 .cfi_endproc
  51              	.LFE66:
  53              	 .section .text.ADC_MEASUREMENT_GetGlobalDetailedResult,"ax",%progbits
  54              	 .align 2
  55              	 .code 16
  56              	 .thumb_func
  58              	ADC_MEASUREMENT_GetGlobalDetailedResult:
  59              	.LFB92:
  60              	 .file 2 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @file adc_measurement.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @date 2021-01-08
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * NOTE:
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @cond
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT v4.1.24 - Incorporates analog to digital conversion for the required measurement
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * All rights reserved.
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * following conditions are met:
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   disclaimer.
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   products derived from this software without specific prior written permission.
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Change History
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * --------------
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-16:
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Initial version for DAVEv4.<BR>
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-02-19:
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added GetResult APIs for XMC1100 devices.
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-05-14:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Optimized the Manifest.<BR>
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified the structure ADC_MEASUREMENT_channel_t to ADC_MEASUREMENT_CHANNEL_t.<BR>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-06-26:
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added input class resource consumption.<BR>
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   * 2015-07-09:
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-07-31:
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support new devices.<BR>
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-01:
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP to support the interrupt control in XMC14.<BR>
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-08:
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4700/XMC4800 devices.<BR>
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-10-20:
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Documentation updated.<BR>
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2015-12-03:
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added support for XMC4300 device.<BR>
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-02-09:
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Updated the APP for the minimum required ANALOG_IO APP version.<BR>
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-03-18:
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Maximum number of channels for XMC41/42 increased to 9.<BR>
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Added Post calibration time for XMC1x series in Total conversion Time.<BR>
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Fixed the ADC_MEASUREMENT_Init() for ANALOG_IO initialization.<BR>
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Deprecated the API ADC_MEASUREMENT_GetResult() and
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetDetailedResult().<BR>
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - For XMC1100 series only: Added new API ADC_MEASUREMENT_GetGlobalResult() and
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *       ADC_MEASUREMENT_GetGlobalDetailedResult().<BR>
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2016-08-18:
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_A
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 2021-01-08:
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     - Modified check for minimum XMCLib version
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcond
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /*CODE_BLOCK_BEGIN*/
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifndef ADC_MEASUREMENT_H
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_H
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * HEADER FILES
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "GLOBAL_ADC/global_adc.h"
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #include "adc_measurement_conf.h"
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * MACROS
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION 2
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_MINOR_VERSION 0
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_XMC_LIB_PATCH_VERSION 0
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if !((XMC_LIB_MAJOR_VERSION > ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) ||\
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION >
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       ((XMC_LIB_MAJOR_VERSION == ADC_MEASUREMENT_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION =
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #error "ADC_MEASUREMENT requires XMC Peripheral Library v2.0.0 or higher"
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if defined (__GNUC__) || defined (__CC_ARM)
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED   __attribute__((deprecated))
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_DEPRECATED
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #define ADC_MEASUREMENT_MODULE_PTR ((XMC_VADC_GLOBAL_t *) (void *) VADC)
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  /*************************************************************************************************
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ENUMS
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_enumerations
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**@brief Return value of an API  */
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef enum ADC_MEASUREMENT_STATUS
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_SUCCESS = 0, /**< APP is Initialized */
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_FAILURE, /**< APP Initialization failed*/
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_UNINITIALIZED /**<  APP has not been Initialized */
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_STATUS_t;
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** * DATA STRUCTURES
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ***************************************************************************************************
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_datastructures
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef void (*ADC_MEASUREMENT_MUX_CONFIG_t)(void); /**< Function pointer to the mux configuration*
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  Structure to initialize  Request Source Interrupt's NVIC Node
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_ISR
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t node_id; 		/**< This holds the Node ID of the NVIC.*/
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t priority; 		/**< This holds the NVIC priority.*/
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(UC_FAMILY == XMC4)
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t sub_priority; 	/**< This holds the SubPriority of the NVIC. for Only XMC4x Devices*/
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_NON_DEFAULT_IRQ_SOURCE_SELECTED
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t irqctrl; 	     /**< This indicates the service request source selected for the consumed N
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_ISR_t;
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to initialize ADC channels.
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_CHANNEL_CONFIG_t *ch_handle; /**< This holds the VADC Channel LLD struct*/
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 1U)
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_GROUP_t *group_handle; 		/**< This holds the group to which the channel belongs*/
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef ADC_MEASUREMENT_ANALOG_IO_USED
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ANALOG_IO_t   *analog_io_config;    /**< This hold the address of the ANALOG_IO configuration str
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t group_index; 					/**< This holds the group index*/
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint8_t ch_num; 						/**< This Holds the Channel Number*/
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_t;
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to hold channels handles that are configured
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT_CHANNEL_ARRAY
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_t *const channel_array[ADC_MEASUREMENT_MAXCHANNELS]; /**< Array whi
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                                         of APPs Cha
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if( XMC_VADC_GROUP_AVAILABLE == 0U)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_CHANNEL_ARRAY_t;
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Structure to configure ADC_MEASUREMENT APP.
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** typedef struct ADC_MEASUREMENT
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_CHANNEL_ARRAY_t *const array; 		 /**< This holds ADC_MEASUREMENT_Channel_Ha
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_BACKGROUND_CONFIG_t *const backgnd_config_handle; /**< This holds the LLD Backgrou
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                                                                         Structure*/
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_GLOBAL_CLASS_t *const iclass_config_handle;  /**< This holds the adc global ICLASS
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   GLOBAL_ADC_t *const global_handle; 						 /**< This hold the ADC Global APP handle*/
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if (UC_SERIES != XMC11)
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const req_src_intr_handle; 	 /**< This has the NVIC configuration st
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const ADC_MEASUREMENT_ISR_t *const result_intr_handle; 	 /**< This has the NVIC configuration str
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_MUX_CONFIG_t mux_config; /**< This hold the pointer to the function that does mux
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   ADC_MEASUREMENT_STATUS_t init_state; 	  /**< Holds information regarding the APP initialization *
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const XMC_VADC_SR_t srv_req_node; 	  /**< Service Request Line selected*/
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   const bool start_conversion; 			  /**< This indicates whether to start at initialization of the A
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** } ADC_MEASUREMENT_t;
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @}
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #ifdef __cplusplus
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** extern "C" {
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #endif
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**************************************************************************************************
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * API Prototypes
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  **************************************************************************************************
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @ingroup ADC_MEASUREMENT_apidoc
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @{
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Get ADC_MEASUREMENT APP version
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * The function can be used to check application software compatibility with a
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specific version of the APP.
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Example Usage:
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void) 
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_STATUS_t init_status;
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   DAVE_APP_VERSION_t version;
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // Initialize ADC_MEASUREMENT APP:
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // ADC_MEASUREMENT_Init() is called from within DAVE_Init().
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   init_status = DAVE_Init();
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   version = ADC_MEASUREMENT_GetAppVersion();
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   if (version.major != 1U) {
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *     // Probably, not the right version.
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   // More code here
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   while(1) {
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   }
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *   return (0);
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @endcode
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** DAVE_APP_VERSION_t ADC_MEASUREMENT_GetAppVersion(void);
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Initializes the APP to measure a set of analog inputs. <BR>
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure<BR>
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return ADC_MEASUREMENT_STATUS_SUCCESS when initialization succeeds else, return ADC_MEASUREMENT
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Initializes the VADC background scan request source, group channels and result registers with th
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * specified in the handle structure. The API configures the conversion timing parameters of VADC, 
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GLOBICLASS] register. The API initializes the channel and result configurations by setting the 
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [GxRCRy] registers respectively. It adds all channels into the background request source channel
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * [BRSSEL]. For microcontrollers apart from XMC1100, the APP uses background request source event 
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * the interrupt. For XMC1100 devices, global result event is used to generate the interrupt. If "S
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * initialization" has been selected in the GUI, the ADC conversions starts immediately at the end 
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * #include "DAVE.h"
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * int main(void)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    DAVE_Init(); //ADC_MEASUREMENT_Init is called within DAVE_Init
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *    return 0;
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * }
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */ 
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr);
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Starts the conversion of the required measurements. <BR>
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the APP handle structure<BR>
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return None <BR>
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  If "Start conversion after initialization" option is not selected in the GUI, the conversions c
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  calling this API. A call to this API sets the register bit field BRSMR.LDEV to generate a load 
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  load event triggers the conversion of selected channels in a fixed sequence. A conversion reque
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  upon detection of a hardware trigger. Hence, if "Start conversion after initialization" option 
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *  "Trigger edge Selection" is configured to any edge, this API call is not mandatory to start the
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #else
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr);
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #if(XMC_VADC_GROUP_AVAILABLE == 1U)
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value for a specific channel. Not Applicable for XMC1100.<BR>
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr Constant pointer to the channel handle structure of type @ref ADC_MEASUREMENT_
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the result register [GxRESy.RESULT], assigned to the specif
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where separate result registers are available for storing ea
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * For these microcontrollers, each channel is configured to a particular group result register. Th
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is defined in the channel handle structure @ref ADC_MEASUREMENT_CHANNEL_t. Hence this API shall 
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * pointer to the channel handle of type  @ref ADC_MEASUREMENT_CHANNEL_t (Directly use the channel 
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * macros which are defined in adc_measurement_conf.h).
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) for XMC1
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Not Applicable for XMC1100. <BR>
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the channel handle structure.
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                   (Use the channel handle related macros which are defined in adc_measurement_co
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete result register.<BR>
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GxRES[y]) completely. The result of conversion as well as ot
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) 
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result;
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES != XMC11)
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_Channel_A);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_G_RES_VF_Pos))
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 437:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 438:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.channel_num = (result & VADC_G_RES_CHNR_Msk) >> VADC_G_RES_CHNR_Pos;
 439:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.group_num = ADC_MEASUREMENT_Channel_A.group_index;
 440:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result.conversion_result = result & VADC_G_RES_RESULT_Msk;
 441:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 442:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 443:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 444:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 445:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 446:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 447:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 448:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 449:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 450:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 451:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 452:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 453:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 454:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);
 455:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 456:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** #else /* Applicable for XMC1100 devices*/
 457:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 458:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 459:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 460:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 461:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 462:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 463:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 464:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 465:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 466:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 467:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 468:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 469:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetDetailedResult API.
 470:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 471:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 472:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 473:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 474:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 475:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 476:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 477:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 478:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 479:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 480:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 481:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 482:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 483:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 484:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 485:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 486:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 487:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 488:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 489:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_0);
 490:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 491:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 492:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 493:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 494:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 495:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 496:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 497:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 498:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 499:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 500:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 501:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 502:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 503:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREME
 504:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 505:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 506:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 507:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 508:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 509:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 510:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 511:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 512:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 513:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 514:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 515:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 516:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 517:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 518:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 519:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 520:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 521:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 522:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 523:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 524:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 525:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 526:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 527:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 528:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 529:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 530:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 531:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 532:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 533:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 534:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 535:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 536:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 537:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 538:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 539:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 540:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 541:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 542:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 543:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 544:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 545:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 546:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 547:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 548:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 549:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 550:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 551:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 552:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 553:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 554:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_0);
 555:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 556:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 557:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 558:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 559:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 560:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 561:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 562:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 563:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 564:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 565:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 566:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 567:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 568:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 569:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 570:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 571:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 572:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 573:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 574:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 575:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 576:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 577:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREMENT_DEP
 578:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 579:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 580:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.
 581:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 582:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 583:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off
 584:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 585:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 586:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Reads the converted result stored in the common result register [GLOBRES], assigned to all the c
 587:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * is only used in the microcotrollers where group result registers are not available. Hence for th
 588:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * devices, all the conversion results are stored in the global result register in shared mode. The
 589:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * hardware option will be enabled for the global result register to avoid overwriting of results. 
 590:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * conversion result, it is mandatory to read the previous result using the same API or @ref
 591:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetGlobalDetailedResult API.
 592:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 593:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 594:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 595:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a c
 596:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type 
 597:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_t.</li>
 598:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 599:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 600:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 601:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 602:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 603:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 604:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   // Ensure that end of measurements interrupt has been enabled
 605:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 606:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 607:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 608:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 609:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 610:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 611:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalResult();
 612:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 613:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard 
 614:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 615:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 616:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 617:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 618:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 619:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 620:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 621:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 622:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 623:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 624:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 625:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE XMC_VADC_RESULT_SIZE_t  ADC_MEASUREMENT_GetGlobalResult(void)
 626:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
 627:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   XMC_VADC_RESULT_SIZE_t result;
 628:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 629:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
 630:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 631:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
 632:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
 633:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 634:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** /**
 635:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 636:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @param handle_ptr constant pointer to the APP handle structure.<BR>
 637:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @return uint32_t The complete Result register.<BR>
 638:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 639:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Description: </b><br>
 640:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as oth
 641:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * returned from this API. The detailed result register contains result of the most recent conversi
 642:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * channel number requested the conversion, valid flag, converted request source and fast compare r
 643:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * mechanism the converted result can be read out after checking the valid flag bit. This API can b
 644:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * applications where, the channel number associated to the result register is also needed for veri
 645:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * This API is only used in the microcotrollers where group result registers are not available. Hen
 646:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microntroller  devices, all the conversion results are stored in the global result register in s
 647:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * for read mode hardware option will be enabled for the global result register to avoid overwritin
 648:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * a new channel conversion result, it is mandatory to read the previous result using the same API 
 649:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * ADC_MEASUREMENT_GetResult API.
 650:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 651:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * \par<b>Note: </b><br>
 652:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <ul>
 653:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a c
 654:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const hand
 655:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * microcontrollers.</li>
 656:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by eithe
 657:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a
 658:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * operation is needed.</li>
 659:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * </ul>
 660:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 661:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 662:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  *
 663:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  * @code
 664:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #include "DAVE.h"
 665:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 666:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   typedef struct detailed_result_struct
 667:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 668:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t channel_num;
 669:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint8_t group_num;
 670:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint16_t conversion_result;
 671:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   } detailed_result_struct_t;
 672:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 673:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 674:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   bool valid_result;
 675:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   detailed_result_struct_t detailed_result[10];
 676:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 677:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   void Adc_Measurement_Handler()
 678:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 679:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     static uint8_t index;
 680:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     uint32_t result;
 681:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     valid_result = (bool)false;
 682:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #if(UC_SERIES == XMC11)
 683:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     result = ADC_MEASUREMENT_GetGlobalDetailedResult();
 684:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   #endif
 685:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 686:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     if((bool)(result >> VADC_GLOBRES_VF_Pos))
 687:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     {
 688:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       valid_result = (bool)true;
 689:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Po
 690:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
 691:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
 692:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****                             ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_stan
 693:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     }
 694:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     index++;
 695:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 696:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 697:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   int main(void)
 698:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   {
 699:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     DAVE_Init();
 700:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 701:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     while(1);
 702:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****     return 0;
 703:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   }
 704:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  @endcode
 705:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****  */
 706:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** __STATIC_INLINE uint32_t ADC_MEASUREMENT_GetGlobalDetailedResult(void)
 707:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** {
  61              	 .loc 2 707 0
  62              	 .cfi_startproc
  63 0000 80B5     	 push {r7,lr}
  64              	.LCFI3:
  65              	 .cfi_def_cfa_offset 8
  66              	 .cfi_offset 7,-8
  67              	 .cfi_offset 14,-4
  68 0002 82B0     	 sub sp,sp,#8
  69              	.LCFI4:
  70              	 .cfi_def_cfa_offset 16
  71 0004 00AF     	 add r7,sp,#0
  72              	.LCFI5:
  73              	 .cfi_def_cfa_register 7
 708:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   uint32_t result;
 709:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);
  74              	 .loc 2 709 0
  75 0006 054B     	 ldr r3,.L5
  76 0008 181C     	 mov r0,r3
  77 000a FFF7FEFF 	 bl XMC_VADC_GLOBAL_GetDetailedResult
  78 000e 031C     	 mov r3,r0
  79 0010 7B60     	 str r3,[r7,#4]
 710:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** 
 711:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h ****   return (result);
  80              	 .loc 2 711 0
  81 0012 7B68     	 ldr r3,[r7,#4]
 712:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT\adc_measurement.h **** }
  82              	 .loc 2 712 0
  83 0014 181C     	 mov r0,r3
  84 0016 BD46     	 mov sp,r7
  85 0018 02B0     	 add sp,sp,#8
  86              	 
  87 001a 80BD     	 pop {r7,pc}
  88              	.L6:
  89              	 .align 2
  90              	.L5:
  91 001c 00000348 	 .word 1208156160
  92              	 .cfi_endproc
  93              	.LFE92:
  95              	 .section .text.XMC_GPIO_SetOutputHigh,"ax",%progbits
  96              	 .align 2
  97              	 .code 16
  98              	 .thumb_func
 100              	XMC_GPIO_SetOutputHigh:
 101              	.LFB95:
 102              	 .file 3 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
   7:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.
  11:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  12:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  14:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * do so, all subject to the following:
  20:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  21:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * a source language processor.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * at XMCSupport@infineon.com.
  39:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *****************************************************************************
  40:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  41:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  42:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  43:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  44:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  45:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  46:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  47:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  49:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  50:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  51:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  52:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  53:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  54:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  55:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  56:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  57:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  58:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  59:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  60:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  61:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  62:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  63:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  66:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  67:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  68:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  69:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  70:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  71:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  72:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  73:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  75:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics.
  76:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  77:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  78:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  79:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  80:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  81:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  82:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  83:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  84:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  85:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  86:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  87:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  88:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  89:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  90:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  91:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  92:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  93:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  94:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  95:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  96:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  97:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
  98:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  99:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 101:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 102:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
 103:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
 104:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 106:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 107:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 108:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 109:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 110:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 111:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 112:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 113:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))
 114:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 116:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 117:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 118:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 119:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 120:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 121:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 122:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 124:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 125:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 127:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 128:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 131:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 133:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 134:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 135:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 136:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 137:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 138:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 140:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 141:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 142:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #if UC_FAMILY == XMC1
 144:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 145:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 146:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 147:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 148:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 149:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 150:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 151:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 152:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 153:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 154:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 156:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 157:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 158:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 159:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 160:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 161:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 162:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 163:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 164:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 165:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 166:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 167:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 168:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 169:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 170:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 171:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 172:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 174:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 175:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 176:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 177:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 178:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 180:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 181:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 183:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 184:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 185:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 186:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 187:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 188:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 189:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 191:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 192:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 193:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 194:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 195:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 196:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 197:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 198:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 199:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 202:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 203:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 204:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 205:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 206:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 207:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 208:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 209:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 210:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 211:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 212:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 213:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 214:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 215:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 216:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 217:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 218:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 219:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 220:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 221:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 222:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 223:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 224:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 225:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 226:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 227:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 228:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 229:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 230:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 231:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 232:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 234:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 235:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 236:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 237:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 238:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 239:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 240:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 241:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 242:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 243:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 244:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 245:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 246:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 248:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 250:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 251:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 252:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 253:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 254:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 255:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 256:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 257:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 258:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 259:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 260:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 261:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 262:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 103              	 .loc 3 262 0
 104              	 .cfi_startproc
 105 0000 80B5     	 push {r7,lr}
 106              	.LCFI6:
 107              	 .cfi_def_cfa_offset 8
 108              	 .cfi_offset 7,-8
 109              	 .cfi_offset 14,-4
 110 0002 82B0     	 sub sp,sp,#8
 111              	.LCFI7:
 112              	 .cfi_def_cfa_offset 16
 113 0004 00AF     	 add r7,sp,#0
 114              	.LCFI8:
 115              	 .cfi_def_cfa_register 7
 116 0006 7860     	 str r0,[r7,#4]
 117 0008 0A1C     	 mov r2,r1
 118 000a FB1C     	 add r3,r7,#3
 119 000c 1A70     	 strb r2,[r3]
 263:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 264:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 265:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
 120              	 .loc 3 265 0
 121 000e FB1C     	 add r3,r7,#3
 122 0010 1B78     	 ldrb r3,[r3]
 123 0012 0122     	 mov r2,#1
 124 0014 9A40     	 lsl r2,r2,r3
 125 0016 7B68     	 ldr r3,[r7,#4]
 126 0018 5A60     	 str r2,[r3,#4]
 266:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 127              	 .loc 3 266 0
 128 001a BD46     	 mov sp,r7
 129 001c 02B0     	 add sp,sp,#8
 130              	 
 131 001e 80BD     	 pop {r7,pc}
 132              	 .cfi_endproc
 133              	.LFE95:
 135              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
 136              	 .align 2
 137              	 .code 16
 138              	 .thumb_func
 140              	XMC_GPIO_SetOutputLow:
 141              	.LFB96:
 267:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 268:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 269:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 271:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 272:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 274:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 275:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 276:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 277:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 278:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 279:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 280:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 281:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 282:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 283:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 284:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 285:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 286:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 287:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 288:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 142              	 .loc 3 288 0
 143              	 .cfi_startproc
 144 0000 80B5     	 push {r7,lr}
 145              	.LCFI9:
 146              	 .cfi_def_cfa_offset 8
 147              	 .cfi_offset 7,-8
 148              	 .cfi_offset 14,-4
 149 0002 82B0     	 sub sp,sp,#8
 150              	.LCFI10:
 151              	 .cfi_def_cfa_offset 16
 152 0004 00AF     	 add r7,sp,#0
 153              	.LCFI11:
 154              	 .cfi_def_cfa_register 7
 155 0006 7860     	 str r0,[r7,#4]
 156 0008 0A1C     	 mov r2,r1
 157 000a FB1C     	 add r3,r7,#3
 158 000c 1A70     	 strb r2,[r3]
 289:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 290:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 291:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
 159              	 .loc 3 291 0
 160 000e FB1C     	 add r3,r7,#3
 161 0010 1B78     	 ldrb r3,[r3]
 162 0012 8022     	 mov r2,#128
 163 0014 5202     	 lsl r2,r2,#9
 164 0016 9A40     	 lsl r2,r2,r3
 165 0018 7B68     	 ldr r3,[r7,#4]
 166 001a 5A60     	 str r2,[r3,#4]
 292:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 167              	 .loc 3 292 0
 168 001c BD46     	 mov sp,r7
 169 001e 02B0     	 add sp,sp,#8
 170              	 
 171 0020 80BD     	 pop {r7,pc}
 172              	 .cfi_endproc
 173              	.LFE96:
 175 0022 C046     	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
 176              	 .align 2
 177              	 .code 16
 178              	 .thumb_func
 180              	XMC_GPIO_GetInput:
 181              	.LFB98:
 293:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 294:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 295:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 296:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 297:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  port pin number.
 298:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 299:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 300:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 301:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 302:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 303:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 304:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 305:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 306:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 307:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 308:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 309:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 310:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 311:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 312:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 313:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 314:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 315:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 316:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 317:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
 318:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 319:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 320:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 321:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 322:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 323:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  Port pin number.
 324:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 325:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 326:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 327:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 328:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 329:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 330:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 331:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * None
 332:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 333:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 334:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 335:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 336:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 337:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 338:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 339:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** {
 182              	 .loc 3 339 0
 183              	 .cfi_startproc
 184 0000 80B5     	 push {r7,lr}
 185              	.LCFI12:
 186              	 .cfi_def_cfa_offset 8
 187              	 .cfi_offset 7,-8
 188              	 .cfi_offset 14,-4
 189 0002 82B0     	 sub sp,sp,#8
 190              	.LCFI13:
 191              	 .cfi_def_cfa_offset 16
 192 0004 00AF     	 add r7,sp,#0
 193              	.LCFI14:
 194              	 .cfi_def_cfa_register 7
 195 0006 7860     	 str r0,[r7,#4]
 196 0008 0A1C     	 mov r2,r1
 197 000a FB1C     	 add r3,r7,#3
 198 000c 1A70     	 strb r2,[r3]
 340:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 341:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** 
 342:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
 199              	 .loc 3 342 0
 200 000e 7B68     	 ldr r3,[r7,#4]
 201 0010 5A6A     	 ldr r2,[r3,#36]
 202 0012 FB1C     	 add r3,r7,#3
 203 0014 1B78     	 ldrb r3,[r3]
 204 0016 DA40     	 lsr r2,r2,r3
 205 0018 131C     	 mov r3,r2
 206 001a 0122     	 mov r2,#1
 207 001c 1340     	 and r3,r2
 343:C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc\xmc_gpio.h **** }
 208              	 .loc 3 343 0
 209 001e 181C     	 mov r0,r3
 210 0020 BD46     	 mov sp,r7
 211 0022 02B0     	 add sp,sp,#8
 212              	 
 213 0024 80BD     	 pop {r7,pc}
 214              	 .cfi_endproc
 215              	.LFE98:
 217 0026 C046     	 .section .text.DIGITAL_IO_SetOutputHigh,"ax",%progbits
 218              	 .align 2
 219              	 .code 16
 220              	 .thumb_func
 222              	DIGITAL_IO_SetOutputHigh:
 223              	.LFB103:
 224              	 .file 4 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io.h"
   1:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /*
   2:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   3:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @file digital_io.h
   4:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @date 2021-01-08
   5:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   6:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * NOTE:
   7:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   8:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
   9:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @cond
  10:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  11:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DIGITAL_IO v4.0.18 - The DIGITAL_IO APP is used to configure a port pin as digital Input/Output.
  12:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  13:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  14:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * All rights reserved.
  15:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  16:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * following conditions are met:
  18:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  19:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   disclaimer.
  21:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  22:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  25:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *   products derived from this software without specific prior written permission.
  27:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  28:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  36:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * with Infineon Technologies AG (dave@infineon.com).
  38:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  39:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  40:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * Change History
  41:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * --------------
  42:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  43:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-02-16
  44:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Initial version
  45:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  46:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-04-22
  47:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - XMC_ASSERT is added in static inline functions.<br>
  48:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  49:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-06-20
  50:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Version check added for XMCLib dependency.<br>
  51:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  52:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2015-12-22
  53:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Added hardware controlled IO feature.
  54:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2016-07-08:
  55:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Fixed incorrect case for an included header.<br>
  56:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * 2021-01-08:
  57:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *     - Modified check for minimum XMCLib version
  58:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  59:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * @endcond
  60:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  *
  61:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  */
  62:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  63:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  64:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * HEADER FILES
  65:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  66:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  67:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifndef DIGITAL_IO_H
  68:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_H
  69:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  70:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "xmc_gpio.h"
  71:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "DAVE_Common.h"
  72:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #include "digital_io_conf.h"
  73:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  74:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
  75:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * MACROS
  76:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  77:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MAJOR_VERSION 2
  78:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_MINOR_VERSION 0
  79:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #define DIGITAL_IO_XMC_LIB_PATCH_VERSION 0
  80:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  81:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #if !((XMC_LIB_MAJOR_VERSION > DIGITAL_IO_XMC_LIB_MAJOR_VERSION) ||\
  82:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > DIGI
  83:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****       ((XMC_LIB_MAJOR_VERSION == DIGITAL_IO_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == DIG
  84:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #error "DIGITAL_IO requires XMC Peripheral Library v2.0.0 or higher"
  85:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
  86:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  87:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  /*************************************************************************************************
  88:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * ENUMS
  89:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
  90:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  91:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  92:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_enumerations
  93:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
  94:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  95:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
  96:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
  97:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization status of DIGITAL_IO APP.
  98:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
  99:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef enum DIGITAL_IO_STATUS
 100:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 101:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_OK = 0U,/**< 0=Status OK */
 102:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   DIGITAL_IO_STATUS_FAILURE = 1U/**< 1=Status Failed */
 103:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_STATUS_t;
 104:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 105:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 106:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 107:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 108:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 109:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 110:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * DATA STRUCTURES
 111:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 112:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 113:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_datastructures
 114:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 115:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 116:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 117:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 118:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Initialization data structure of DIGITAL_IO APP
 119:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 120:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** typedef struct DIGITAL_IO
 121:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 122:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_PORT_t *const gpio_port;             /**< port number */
 123:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_CONFIG_t gpio_config;          /**< mode, initial output level and pad driver stre
 124:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const uint8_t gpio_pin;                       /**< pin number */
 125:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   const XMC_GPIO_HWCTRL_t hwctrl;               /**< Hardware port control */
 126:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** } DIGITAL_IO_t;
 127:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 128:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 129:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 130:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @}
 131:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 132:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 133:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 134:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**************************************************************************************************
 135:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  * API Prototypes
 136:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****  **************************************************************************************************
 137:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 138:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 139:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #ifdef __cplusplus
 140:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** extern "C" {
 141:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** #endif
 142:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 143:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 144:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @ingroup DIGITAL_IO_apidoc
 145:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @{
 146:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 147:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 148:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 149:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 150:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 151:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Get DIGITAL_IO APP version
 152:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 153:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 154:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description: </b><br>
 155:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * The function can be used to check application software compatibility with a
 156:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * specific version of the APP.
 157:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 158:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 159:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 160:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 161:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h"
 162:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 163:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 164:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 165:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t init_status;
 166:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_APP_VERSION_t version;
 167:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 168:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // Initialize DIGITAL_IO APP:
 169:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   // DIGITAL_IO_Init() is called from within DAVE_Init().
 170:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   init_status = DAVE_Init();
 171:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(init_status == DAVE_STATUS_SUCCESS)
 172:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 173:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     version = DIGITAL_IO_GetAppVersion();
 174:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if (version.major != 4U) {
 175:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Probably, not the right version.
 176:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 177:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 178:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 179:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // More code here
 180:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1) {
 181:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 182:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 183:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     return (1);
 184:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 185:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @endcode<BR>
 186:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 187:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 188:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DAVE_APP_VERSION_t DIGITAL_IO_GetAppVersion(void);
 189:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 190:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 191:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 192:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to initialize the port pin as per UI settings.
 193:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 194:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status. Refer @ref DIGITAL_IO_STATUS_t structure for d
 195:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 196:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 197:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function initializes GPIO port registers IOCR,PDISC,OMR,PDR/PHCR to configure pin direction,
 198:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * and pad driver strength/hysteresis.
 199:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 200:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 201:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * None
 202:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 203:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 204:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 205:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 206:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 207:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 208:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 209:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 210:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 211:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 212:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 213:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 214:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 215:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 216:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 217:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 218:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 219:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 220:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 221:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 222:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 223:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 224:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 225:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 226:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return 1U;
 227:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  }
 228:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 229:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 230:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 231:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler);
 232:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 233:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 234:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 235:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to set port pin high.
 236:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 237:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 238:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 239:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 240:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to high level
 241:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 242:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 243:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  DIGITAL_IO_SetOutputLow()
 244:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 245:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 246:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 247:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 248:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 249:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 250:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 251:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 252:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 253:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 254:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 255:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 256:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 257:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 258:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 259:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 260:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 261:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 262:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 263:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 264:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 265:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_0);
 266:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 267:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 268:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     // Add application code here
 269:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 270:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 271:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 272:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 273:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 274:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 275:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 276:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
 277:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 225              	 .loc 4 277 0
 226              	 .cfi_startproc
 227 0000 80B5     	 push {r7,lr}
 228              	.LCFI15:
 229              	 .cfi_def_cfa_offset 8
 230              	 .cfi_offset 7,-8
 231              	 .cfi_offset 14,-4
 232 0002 82B0     	 sub sp,sp,#8
 233              	.LCFI16:
 234              	 .cfi_def_cfa_offset 16
 235 0004 00AF     	 add r7,sp,#0
 236              	.LCFI17:
 237              	 .cfi_def_cfa_register 7
 238 0006 7860     	 str r0,[r7,#4]
 278:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
 279:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 239              	 .loc 4 279 0
 240 0008 7B68     	 ldr r3,[r7,#4]
 241 000a 1A68     	 ldr r2,[r3]
 242 000c 7B68     	 ldr r3,[r7,#4]
 243 000e 1B7B     	 ldrb r3,[r3,#12]
 244 0010 101C     	 mov r0,r2
 245 0012 191C     	 mov r1,r3
 246 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 280:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 247              	 .loc 4 280 0
 248 0018 BD46     	 mov sp,r7
 249 001a 02B0     	 add sp,sp,#8
 250              	 
 251 001c 80BD     	 pop {r7,pc}
 252              	 .cfi_endproc
 253              	.LFE103:
 255 001e C046     	 .section .text.DIGITAL_IO_SetOutputLow,"ax",%progbits
 256              	 .align 2
 257              	 .code 16
 258              	 .thumb_func
 260              	DIGITAL_IO_SetOutputLow:
 261              	.LFB104:
 281:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 282:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 283:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to reset port pin.
 284:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 285:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 286:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 287:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 288:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to make port pin to low level.
 289:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 290:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 291:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputHigh()
 292:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 293:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 294:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 295:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 296:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 297:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  int main(void)
 298:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  {
 299:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DAVE_STATUS_t status;
 300:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_I
 301:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    if(status == DAVE_STATUS_SUCCESS)
 302:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 303:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG("DAVE Apps initialization success\n");
 304:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 305:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    else
 306:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 307:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 308:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 309:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 310:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 311:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 312:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    //Placeholder for user application code. The while loop below can be replaced with user applic
 313:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    DIGITAL_IO_SetOutputLow(&DIGITAL_IO_0);
 314:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    while(1U)
 315:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    {
 316:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      // Add application code here
 317:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *    }
 318:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 319:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 320:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 321:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 322:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 323:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 324:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
 325:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 262              	 .loc 4 325 0
 263              	 .cfi_startproc
 264 0000 80B5     	 push {r7,lr}
 265              	.LCFI18:
 266              	 .cfi_def_cfa_offset 8
 267              	 .cfi_offset 7,-8
 268              	 .cfi_offset 14,-4
 269 0002 82B0     	 sub sp,sp,#8
 270              	.LCFI19:
 271              	 .cfi_def_cfa_offset 16
 272 0004 00AF     	 add r7,sp,#0
 273              	.LCFI20:
 274              	 .cfi_def_cfa_register 7
 275 0006 7860     	 str r0,[r7,#4]
 326:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
 327:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 276              	 .loc 4 327 0
 277 0008 7B68     	 ldr r3,[r7,#4]
 278 000a 1A68     	 ldr r2,[r3]
 279 000c 7B68     	 ldr r3,[r7,#4]
 280 000e 1B7B     	 ldrb r3,[r3,#12]
 281 0010 101C     	 mov r0,r2
 282 0012 191C     	 mov r1,r3
 283 0014 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 328:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 284              	 .loc 4 328 0
 285 0018 BD46     	 mov sp,r7
 286 001a 02B0     	 add sp,sp,#8
 287              	 
 288 001c 80BD     	 pop {r7,pc}
 289              	 .cfi_endproc
 290              	.LFE104:
 292 001e C046     	 .section .text.DIGITAL_IO_GetInput,"ax",%progbits
 293              	 .align 2
 294              	 .code 16
 295              	 .thumb_func
 297              	DIGITAL_IO_GetInput:
 298              	.LFB106:
 329:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 330:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 331:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to Toggle port pin.
 332:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 333:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return None
 334:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 335:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 336:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function configures port output modification register Pn_OMR, to toggle port pin.
 337:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 338:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 339:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * DIGITAL_IO_SetOutputLow(), DIGITAL_IO_SetOutputHigh()
 340:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 341:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 342:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 343:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 344:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 345:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 346:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 347:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 348:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 349:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t delay_count;;
 350:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();  //(DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_In
 351:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 352:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 353:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 354:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 355:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 356:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 357:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 358:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      while(1U)
 359:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      {
 360:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      }
 361:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 362:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 363:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 364:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 365:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 1 -> 0 (if initial output level is logic
 366:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 367:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 368:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0); //toggles : 0 -> 1
 369:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      //Add application code here
 370:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *      for(delay_count = 0;delay_count<0xfffff;delay_count++);
 371:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 372:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 373:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 374:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 375:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 376:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 377:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
 378:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 379:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
 380:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 381:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 382:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 383:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** /**
 384:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @brief Function to read input level of port pin.
 385:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @param handler Pointer pointing to APP data structure. Refer @ref DIGITAL_IO_t for details.
 386:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @return uint32_t input logic level. Range:0-1
 387:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 388:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Description:</b><br>
 389:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * This function reads the Pn_IN register and returns the current logical value at the GPIO pin.
 390:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 391:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * \par<b>Related APIs:</b><BR>
 392:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  None
 393:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 394:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * Example Usage:
 395:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * @code
 396:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
 397:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *
 398:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * int main(void)
 399:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * {
 400:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   DAVE_STATUS_t status;
 401:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   uint32_t pin_status;
 402:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   status = DAVE_Init();   // (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0) is called within DAVE_
 403:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   if(status == DAVE_STATUS_SUCCESS)
 404:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 405:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG("DAVE Apps initialization success\n");
 406:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 407:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   else
 408:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 409:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     XMC_DEBUG(("DAVE Apps initialization failed with status %d\n", status));
 410:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     while(1U)
 411:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 412:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 413:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 414:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   //Placeholder for user application code. The while loop below can be replaced with user applica
 415:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   while(1U)
 416:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   {
 417:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     pin_status = DIGITAL_IO_GetInput(&DIGITAL_IO_0);
 418:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     if(pin_status == 1)
 419:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 420:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 421:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 422:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     else
 423:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     {
 424:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *       // Add application code here
 425:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *     }
 426:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   }
 427:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *   return (1);
 428:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** * }
 429:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** *  @endcode
 430:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** */
 431:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** 
 432:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** __STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
 433:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** {
 299              	 .loc 4 433 0
 300              	 .cfi_startproc
 301 0000 80B5     	 push {r7,lr}
 302              	.LCFI21:
 303              	 .cfi_def_cfa_offset 8
 304              	 .cfi_offset 7,-8
 305              	 .cfi_offset 14,-4
 306 0002 82B0     	 sub sp,sp,#8
 307              	.LCFI22:
 308              	 .cfi_def_cfa_offset 16
 309 0004 00AF     	 add r7,sp,#0
 310              	.LCFI23:
 311              	 .cfi_def_cfa_register 7
 312 0006 7860     	 str r0,[r7,#4]
 434:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
 435:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h ****   return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
 313              	 .loc 4 435 0
 314 0008 7B68     	 ldr r3,[r7,#4]
 315 000a 1A68     	 ldr r2,[r3]
 316 000c 7B68     	 ldr r3,[r7,#4]
 317 000e 1B7B     	 ldrb r3,[r3,#12]
 318 0010 101C     	 mov r0,r2
 319 0012 191C     	 mov r1,r3
 320 0014 FFF7FEFF 	 bl XMC_GPIO_GetInput
 321 0018 031C     	 mov r3,r0
 436:C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO\digital_io.h **** }
 322              	 .loc 4 436 0
 323 001a 181C     	 mov r0,r3
 324 001c BD46     	 mov sp,r7
 325 001e 02B0     	 add sp,sp,#8
 326              	 
 327 0020 80BD     	 pop {r7,pc}
 328              	 .cfi_endproc
 329              	.LFE106:
 331              	 .global relay_threshold_latchtime
 332 0022 C046     	 .section .data.relay_threshold_latchtime,"aw",%progbits
 333              	 .align 2
 336              	relay_threshold_latchtime:
 337 0000 F4010000 	 .word 500
 338              	 .global ADC_upper_threshold
 339              	 .section .data.ADC_upper_threshold,"aw",%progbits
 340              	 .align 2
 343              	ADC_upper_threshold:
 344 0000 410D0000 	 .word 3393
 345              	 .global ADC_lower_threshold
 346              	 .section .data.ADC_lower_threshold,"aw",%progbits
 347              	 .align 2
 350              	ADC_lower_threshold:
 351 0000 BE020000 	 .word 702
 352              	 .global USB_state
 353              	 .section .bss.USB_state,"aw",%nobits
 356              	USB_state:
 357 0000 00       	 .space 1
 358              	 .global relay_state
 359              	 .section .data.relay_state,"aw",%progbits
 362              	relay_state:
 363 0000 01       	 .byte 1
 364              	 .global setup_state
 365              	 .section .bss.setup_state,"aw",%nobits
 368              	setup_state:
 369 0000 00       	 .space 1
 370              	 .global usb_changed_timestamp
 371              	 .section .bss.usb_changed_timestamp,"aw",%nobits
 372              	 .align 2
 375              	usb_changed_timestamp:
 376 0000 00000000 	 .space 4
 377              	 .global led_status_pattern
 378              	 .section .bss.led_status_pattern,"aw",%nobits
 381              	led_status_pattern:
 382 0000 00       	 .space 1
 383              	 .global led_status_pattern_last
 384              	 .section .bss.led_status_pattern_last,"aw",%nobits
 387              	led_status_pattern_last:
 388 0000 00       	 .space 1
 389              	 .global led_pattern_mode
 390              	 .section .bss.led_pattern_mode,"aw",%nobits
 393              	led_pattern_mode:
 394 0000 00       	 .space 1
 395              	 .global led_status_pattern_after_single
 396              	 .section .bss.led_status_pattern_after_single,"aw",%nobits
 399              	led_status_pattern_after_single:
 400 0000 00       	 .space 1
 401              	 .global led_number_continuous
 402              	 .section .bss.led_number_continuous,"aw",%nobits
 403              	 .align 1
 406              	led_number_continuous:
 407 0000 0000     	 .space 2
 408              	 .global led_number_single
 409              	 .section .bss.led_number_single,"aw",%nobits
 410              	 .align 1
 413              	led_number_single:
 414 0000 0000     	 .space 2
 415              	 .global led_fadetime
 416              	 .section .data.led_fadetime,"aw",%progbits
 417              	 .align 1
 420              	led_fadetime:
 421 0000 DC05     	 .short 1500
 422              	 .global led_fadesteps
 423              	 .section .data.led_fadesteps,"aw",%progbits
 424              	 .align 1
 427              	led_fadesteps:
 428 0000 E803     	 .short 1000
 429              	 .global buttonpress_usb
 430              	 .section .bss.buttonpress_usb,"aw",%nobits
 433              	buttonpress_usb:
 434 0000 00       	 .space 1
 435              	 .global buttonpress_up
 436              	 .section .bss.buttonpress_up,"aw",%nobits
 439              	buttonpress_up:
 440 0000 00       	 .space 1
 441              	 .global buttonpress_down
 442              	 .section .bss.buttonpress_down,"aw",%nobits
 445              	buttonpress_down:
 446 0000 00       	 .space 1
 447              	 .global button_usb_pressed_timestamp
 448              	 .section .bss.button_usb_pressed_timestamp,"aw",%nobits
 449              	 .align 2
 452              	button_usb_pressed_timestamp:
 453 0000 00000000 	 .space 4
 454              	 .global button_up_pressed_timestamp
 455              	 .section .bss.button_up_pressed_timestamp,"aw",%nobits
 456              	 .align 2
 459              	button_up_pressed_timestamp:
 460 0000 00000000 	 .space 4
 461              	 .global button_down_pressed_timestamp
 462              	 .section .bss.button_down_pressed_timestamp,"aw",%nobits
 463              	 .align 2
 466              	button_down_pressed_timestamp:
 467 0000 00000000 	 .space 4
 468              	 .global button_usb_pressed_duration
 469              	 .section .bss.button_usb_pressed_duration,"aw",%nobits
 470              	 .align 1
 473              	button_usb_pressed_duration:
 474 0000 0000     	 .space 2
 475              	 .global button_up_pressed_duration
 476              	 .section .bss.button_up_pressed_duration,"aw",%nobits
 477              	 .align 1
 480              	button_up_pressed_duration:
 481 0000 0000     	 .space 2
 482              	 .global button_down_pressed_duration
 483              	 .section .bss.button_down_pressed_duration,"aw",%nobits
 484              	 .align 1
 487              	button_down_pressed_duration:
 488 0000 0000     	 .space 2
 489              	 .global ADC_val_current
 490              	 .section .bss.ADC_val_current,"aw",%nobits
 491              	 .align 2
 494              	ADC_val_current:
 495 0000 00000000 	 .space 4
 496              	 .global ADC_val_upper_thres_exceed_timestamp
 497              	 .section .bss.ADC_val_upper_thres_exceed_timestamp,"aw",%nobits
 498              	 .align 2
 501              	ADC_val_upper_thres_exceed_timestamp:
 502 0000 00000000 	 .space 4
 503              	 .global ADC_val_lower_thres_exceed_timestamp
 504              	 .section .bss.ADC_val_lower_thres_exceed_timestamp,"aw",%nobits
 505              	 .align 2
 508              	ADC_val_lower_thres_exceed_timestamp:
 509 0000 00000000 	 .space 4
 510              	 .global systime_debug
 511              	 .section .bss.systime_debug,"aw",%nobits
 512              	 .align 2
 515              	systime_debug:
 516 0000 00000000 	 .space 4
 517              	 .global eeprom_latchtime
 518              	 .section .bss.eeprom_latchtime,"aw",%nobits
 519              	 .align 2
 522              	eeprom_latchtime:
 523 0000 00000000 	 .space 4
 524              	 .global eeprom_upper
 525              	 .section .bss.eeprom_upper,"aw",%nobits
 526              	 .align 2
 529              	eeprom_upper:
 530 0000 00000000 	 .space 4
 531              	 .global eeprom_lower
 532              	 .section .bss.eeprom_lower,"aw",%nobits
 533              	 .align 2
 536              	eeprom_lower:
 537 0000 00000000 	 .space 4
 538              	 .global eeprom_usb_state
 539              	 .section .bss.eeprom_usb_state,"aw",%nobits
 540              	 .align 2
 543              	eeprom_usb_state:
 544 0000 00000000 	 .space 4
 545              	 .section .text.delay_ms,"ax",%progbits
 546              	 .align 2
 547              	 .global delay_ms
 548              	 .code 16
 549              	 .thumb_func
 551              	delay_ms:
 552              	.LFB160:
 553              	 .file 5 "../main.c"
   1:../main.c     **** /*
   2:../main.c     ****  * USB-Changer main.c
   3:../main.c     ****  *
   4:../main.c     ****  * A Infineon XMC1100 powered system used to switch between 2 USB Devices and to control a relay ba
   5:../main.c     ****  *
   6:../main.c     ****  * Features: 	- Switching between 2 USB ports on button press
   7:../main.c     ****  * 				- Relay controlled by an ADC input with hysteresis and pulse filter
   8:../main.c     ****  * 				- Setup menu to configure Hysteresis (different threshold for off an on) and filter (thresho
   9:../main.c     ****  * 				- User interface with a status LED (blinking & fading patterns) and buttons (up, down, usb s
  10:../main.c     ****  * 				- Setup stored on emulated EEPROM
  11:../main.c     ****  * 					- USB state is stored after 10sec continuous state in order to prevent fast FLASH degenerat
  12:../main.c     ****  * 					- Thresholds and filter is stored immediately
  13:../main.c     ****  *  Created on: 2022 Mar 03 16:13:51
  14:../main.c     ****  *  Author: RNSANTELER
  15:../main.c     ****  */
  16:../main.c     **** 
  17:../main.c     **** #include "DAVE.h" //Declarations from DAVE Code Generation (includes SFR declaration)
  18:../main.c     **** 
  19:../main.c     **** 
  20:../main.c     **** // Constant settings (must be set hard-coded)
  21:../main.c     **** #define USB_STORE_STATE_EEPROM		 1						// Determines if USB state shall be written to EEPROM
  22:../main.c     **** #define USB_STORE_STATE_EEPROM_DELAY 5000						// After a change of USB state it will be saved to E
  23:../main.c     **** #define BTN_STD_PRESS_DURATION		 60							// The minimum duration of a button press that will be re
  24:../main.c     **** #define BTN_LONG_PRESS_DURATION		 1000						// The minimum duration of a long button press that wil
  25:../main.c     **** #define BTN_LONGEST_PRESS_DURATION	 4000						// The maximum duration of a button press
  26:../main.c     **** #define ADC_THRESHOLD_MAX			 4095						// Maximum ADC value. Note: 4095 can be divided by 1, 3, 5, 
  27:../main.c     **** #define ADC_THRESHOLD_INCREMENT		 (ADC_THRESHOLD_MAX / 35)	// Value added/subtracted when adjusting
  28:../main.c     **** #define ADC_TH_UPPER_DEFAULT		 3510						// Default upper threshold
  29:../main.c     **** #define ADC_TH_LOWER_DEFAULT		 585							// Default lower threshold
  30:../main.c     **** #define RELAY_LATCHTIME_MAX			 60000						// Maximum configurable time that the threshold must be e
  31:../main.c     **** #define RELAY_LATCHTIME_INCREMENT	 250							// Value added/subtracted when adjusting time
  32:../main.c     **** #define RELAY_LATCHTIME_DEFAULT		 500							// Default lower threshold exceed time
  33:../main.c     **** #define LED_PULSE_SHORT				 200							// In ms. Duration of a short led pulse used for led pattern 
  34:../main.c     **** #define LED_PULSE_LONG				 1100						// In ms. Duration of a long led pulse used for led pattern "n
  35:../main.c     **** #define PWM_FULL_ON					 PWM_CCU4_SYM_DUTY_MIN		// Integer that represents the lowest possible duty
  36:../main.c     **** #define PWM_FULL_OFF				 PWM_CCU4_SYM_DUTY_MAX		// Integer that represents the highest possible dut
  37:../main.c     **** #define TIMESTAMP_DEACTIVATED		 UINT32_MAX
  38:../main.c     **** 
  39:../main.c     **** // Dynamic settings (can be changed by user - the here defined values are reset/default values)
  40:../main.c     **** int32_t relay_threshold_latchtime = 500; // Time in ms that the threshold must stay exceeded in ord
  41:../main.c     **** int32_t ADC_upper_threshold = 3393;    // Upper threshold that the ADC value must be exceed to trig
  42:../main.c     **** int32_t ADC_lower_threshold = 702;    // Upper threshold that the ADC value must be exceed to trigg
  43:../main.c     **** 
  44:../main.c     **** 
  45:../main.c     **** // State machines
  46:../main.c     **** typedef enum {USB_1_active, USB_2_active, USB_inactive} USB_states;
  47:../main.c     **** typedef enum {RELAY_HIGH, RELAY_LOW} relay_states;
  48:../main.c     **** typedef enum {SETUP_IDLE, SETUP_UPPER_TH, SETUP_LOWER_TH, SETUP_TIME_TH} setup_states;
  49:../main.c     **** USB_states USB_state = USB_1_active;
  50:../main.c     **** relay_states relay_state = RELAY_LOW;
  51:../main.c     **** setup_states setup_state = SETUP_IDLE;
  52:../main.c     **** uint32_t usb_changed_timestamp = 0;
  53:../main.c     **** typedef enum {LED_OFF, LED_ON, LED_NUMBER, LED_FADE_DOWN, LED_FADE_UP, LED_MATCH_RELAY_STATE} LED_p
  54:../main.c     **** LED_patterns led_status_pattern = LED_OFF;
  55:../main.c     **** LED_patterns led_status_pattern_last = LED_OFF;
  56:../main.c     **** typedef enum {LED_PATTERN_CONTINUOUS, LED_PATTERN_SINGLE} LED_pattern_modes;
  57:../main.c     **** LED_pattern_modes led_pattern_mode = LED_PATTERN_CONTINUOUS;
  58:../main.c     **** LED_patterns led_status_pattern_after_single = LED_OFF; 	// Defines to what pattern will be switche
  59:../main.c     **** uint16_t led_number_continuous = 0;
  60:../main.c     **** uint16_t led_number_single = 0;
  61:../main.c     **** uint16_t led_fadetime = 1500; // Time of one fade from one extreme to the other
  62:../main.c     **** uint16_t led_fadesteps = 1000; // Number of steps used to fade led
  63:../main.c     **** 
  64:../main.c     **** // Buttons
  65:../main.c     **** typedef enum {BTNPRESS_NOT, BTNPRESS_STD, BTNPRESS_LONG, BTNPRESS_LONGEST} button_press_states;
  66:../main.c     **** button_press_states buttonpress_usb = BTNPRESS_NOT;
  67:../main.c     **** button_press_states buttonpress_up = BTNPRESS_NOT;
  68:../main.c     **** button_press_states buttonpress_down = BTNPRESS_NOT;
  69:../main.c     **** uint32_t button_usb_pressed_timestamp = 0; // If a button is pressed (or state = HIGH) the current 
  70:../main.c     **** uint32_t button_up_pressed_timestamp = 0;
  71:../main.c     **** uint32_t button_down_pressed_timestamp = 0;
  72:../main.c     **** uint16_t button_usb_pressed_duration = 0; // If a button is released (or state = LOW) duration is c
  73:../main.c     **** uint16_t button_up_pressed_duration = 0;
  74:../main.c     **** uint16_t button_down_pressed_duration = 0;
  75:../main.c     **** #define SW_ON 0
  76:../main.c     **** #define SW_OFF 1
  77:../main.c     **** 
  78:../main.c     **** // ADC
  79:../main.c     **** uint32_t ADC_val_current = 0;
  80:../main.c     **** uint32_t ADC_val_upper_thres_exceed_timestamp = 0; // If this is 0 the threshold is not exceeded. I
  81:../main.c     **** uint32_t ADC_val_lower_thres_exceed_timestamp = 0;
  82:../main.c     **** 
  83:../main.c     **** // Debug
  84:../main.c     **** int systime_debug = 0;
  85:../main.c     **** int32_t eeprom_latchtime = 0;
  86:../main.c     **** int32_t eeprom_upper = 0;
  87:../main.c     **** int32_t eeprom_lower = 0;
  88:../main.c     **** int32_t eeprom_usb_state = 0;
  89:../main.c     **** 
  90:../main.c     **** 
  91:../main.c     **** 
  92:../main.c     **** //****************************************************************************
  93:../main.c     **** // delay_ms - millisecond delay function
  94:../main.c     **** //****************************************************************************
  95:../main.c     **** void delay_ms(uint32_t ms){
 554              	 .loc 5 95 0
 555              	 .cfi_startproc
 556 0000 80B5     	 push {r7,lr}
 557              	.LCFI24:
 558              	 .cfi_def_cfa_offset 8
 559              	 .cfi_offset 7,-8
 560              	 .cfi_offset 14,-4
 561 0002 84B0     	 sub sp,sp,#16
 562              	.LCFI25:
 563              	 .cfi_def_cfa_offset 24
 564 0004 00AF     	 add r7,sp,#0
 565              	.LCFI26:
 566              	 .cfi_def_cfa_register 7
 567 0006 7860     	 str r0,[r7,#4]
  96:../main.c     **** 	uint32_t targetMicroSec = SYSTIMER_GetTime() + (ms*1000);
 568              	 .loc 5 96 0
 569 0008 FFF7FEFF 	 bl SYSTIMER_GetTime
 570 000c 011C     	 mov r1,r0
 571 000e 7B68     	 ldr r3,[r7,#4]
 572 0010 FA22     	 mov r2,#250
 573 0012 9200     	 lsl r2,r2,#2
 574 0014 5343     	 mul r3,r2
 575 0016 CB18     	 add r3,r1,r3
 576 0018 FB60     	 str r3,[r7,#12]
  97:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 577              	 .loc 5 97 0
 578 001a 00E0     	 b .L16
 579              	.L17:
  98:../main.c     **** 		__NOP(); // do nothing
 580              	 .loc 5 98 0
 581              	
 582 001c C046     	 nop
 583              	
 584              	 .code 16
 585              	.L16:
  97:../main.c     **** 	while(targetMicroSec > SYSTIMER_GetTime())
 586              	 .loc 5 97 0
 587 001e FFF7FEFF 	 bl SYSTIMER_GetTime
 588 0022 021E     	 sub r2,r0,#0
 589 0024 FB68     	 ldr r3,[r7,#12]
 590 0026 9A42     	 cmp r2,r3
 591 0028 F8D3     	 bcc .L17
  99:../main.c     **** }
 592              	 .loc 5 99 0
 593 002a BD46     	 mov sp,r7
 594 002c 04B0     	 add sp,sp,#16
 595              	 
 596 002e 80BD     	 pop {r7,pc}
 597              	 .cfi_endproc
 598              	.LFE160:
 600              	 .section .text.reset_status_led_to_relay_state,"ax",%progbits
 601              	 .align 2
 602              	 .global reset_status_led_to_relay_state
 603              	 .code 16
 604              	 .thumb_func
 606              	reset_status_led_to_relay_state:
 607              	.LFB161:
 100:../main.c     **** 
 101:../main.c     **** //****************************************************************************
 102:../main.c     **** // reset_status_led_to_relay_state - gets state of relay and sets relay led according
 103:../main.c     **** //****************************************************************************
 104:../main.c     **** void reset_status_led_to_relay_state(){
 608              	 .loc 5 104 0
 609              	 .cfi_startproc
 610 0000 80B5     	 push {r7,lr}
 611              	.LCFI27:
 612              	 .cfi_def_cfa_offset 8
 613              	 .cfi_offset 7,-8
 614              	 .cfi_offset 14,-4
 615 0002 82B0     	 sub sp,sp,#8
 616              	.LCFI28:
 617              	 .cfi_def_cfa_offset 16
 618 0004 00AF     	 add r7,sp,#0
 619              	.LCFI29:
 620              	 .cfi_def_cfa_register 7
 105:../main.c     **** 	uint32_t state = DIGITAL_IO_GetInput(&IO_RELAY);
 621              	 .loc 5 105 0
 622 0006 0F4B     	 ldr r3,.L21
 623 0008 181C     	 mov r0,r3
 624 000a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 625 000e 031C     	 mov r3,r0
 626 0010 7B60     	 str r3,[r7,#4]
 106:../main.c     **** 	if(state == 0){
 627              	 .loc 5 106 0
 628 0012 7B68     	 ldr r3,[r7,#4]
 629 0014 002B     	 cmp r3,#0
 630 0016 09D1     	 bne .L19
 107:../main.c     **** 		led_status_pattern = LED_OFF;
 631              	 .loc 5 107 0
 632 0018 0B4B     	 ldr r3,.L21+4
 633 001a 0022     	 mov r2,#0
 634 001c 1A70     	 strb r2,[r3]
 108:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 635              	 .loc 5 108 0
 636 001e 0B4B     	 ldr r3,.L21+8
 637 0020 0B4A     	 ldr r2,.L21+12
 638 0022 181C     	 mov r0,r3
 639 0024 111C     	 mov r1,r2
 640 0026 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 641 002a 07E0     	 b .L18
 642              	.L19:
 109:../main.c     **** 	}
 110:../main.c     **** 	else{
 111:../main.c     **** 		led_status_pattern = LED_ON;
 643              	 .loc 5 111 0
 644 002c 064B     	 ldr r3,.L21+4
 645 002e 0122     	 mov r2,#1
 646 0030 1A70     	 strb r2,[r3]
 112:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 647              	 .loc 5 112 0
 648 0032 064B     	 ldr r3,.L21+8
 649 0034 181C     	 mov r0,r3
 650 0036 0021     	 mov r1,#0
 651 0038 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 652              	.L18:
 113:../main.c     **** 	}
 114:../main.c     **** }
 653              	 .loc 5 114 0
 654 003c BD46     	 mov sp,r7
 655 003e 02B0     	 add sp,sp,#8
 656              	 
 657 0040 80BD     	 pop {r7,pc}
 658              	.L22:
 659 0042 C046     	 .align 2
 660              	.L21:
 661 0044 00000000 	 .word IO_RELAY
 662 0048 00000000 	 .word led_status_pattern
 663 004c 00000000 	 .word PWM_CCU4_LED_STATUS
 664 0050 10270000 	 .word 10000
 665              	 .cfi_endproc
 666              	.LFE161:
 668              	 .global __aeabi_uidiv
 669              	 .section .text.manage_status_led,"ax",%progbits
 670              	 .align 2
 671              	 .global manage_status_led
 672              	 .code 16
 673              	 .thumb_func
 675              	manage_status_led:
 676              	.LFB162:
 115:../main.c     **** 
 116:../main.c     **** //****************************************************************************
 117:../main.c     **** // manage_status_led - blink the status led according to the given pattern and (user interface)
 118:../main.c     **** //****************************************************************************
 119:../main.c     **** void manage_status_led(){
 677              	 .loc 5 119 0
 678              	 .cfi_startproc
 679 0000 80B5     	 push {r7,lr}
 680              	.LCFI30:
 681              	 .cfi_def_cfa_offset 8
 682              	 .cfi_offset 7,-8
 683              	 .cfi_offset 14,-4
 684 0002 82B0     	 sub sp,sp,#8
 685              	.LCFI31:
 686              	 .cfi_def_cfa_offset 16
 687 0004 00AF     	 add r7,sp,#0
 688              	.LCFI32:
 689              	 .cfi_def_cfa_register 7
 120:../main.c     **** 	static uint16_t led_pattern_state;
 121:../main.c     **** 	static uint32_t led_pattern_state_timestamp;
 122:../main.c     **** 	static uint16_t led_pattern_state_length;
 123:../main.c     **** 
 124:../main.c     **** 	static uint16_t fade_duty_step;
 125:../main.c     **** 
 126:../main.c     **** 	// Check target pattern an initiate
 127:../main.c     **** 	if(led_status_pattern != led_status_pattern_last){
 690              	 .loc 5 127 0
 691 0006 B64B     	 ldr r3,.L54
 692 0008 1A78     	 ldrb r2,[r3]
 693 000a B64B     	 ldr r3,.L54+4
 694 000c 1B78     	 ldrb r3,[r3]
 695 000e 9A42     	 cmp r2,r3
 696 0010 00D1     	 bne .LCB406
 697 0012 93E0     	 b .L24
 698              	.LCB406:
 128:../main.c     **** 		switch (led_status_pattern){
 699              	 .loc 5 128 0
 700 0014 B24B     	 ldr r3,.L54
 701 0016 1B78     	 ldrb r3,[r3]
 702 0018 052B     	 cmp r3,#5
 703 001a 00D9     	 bls .LCB410
 704 001c 8AE0     	 b .L25
 705              	.LCB410:
 706 001e 9A00     	 lsl r2,r3,#2
 707 0020 B14B     	 ldr r3,.L54+8
 708 0022 D318     	 add r3,r2,r3
 709 0024 1B68     	 ldr r3,[r3]
 710 0026 9F46     	 mov pc,r3
 711              	 .section .rodata.manage_status_led,"a",%progbits
 712              	 .align 2
 713              	.L27:
 714 0000 28000000 	 .word .L26
 715 0004 36000000 	 .word .L28
 716 0008 42000000 	 .word .L29
 717 000c 88000000 	 .word .L30
 718 0010 DA000000 	 .word .L31
 719 0014 2E010000 	 .word .L32
 720              	 .section .text.manage_status_led
 721              	.L26:
 129:../main.c     **** 			case LED_OFF:
 130:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 722              	 .loc 5 130 0
 723 0028 B04B     	 ldr r3,.L54+12
 724 002a B14A     	 ldr r2,.L54+16
 725 002c 181C     	 mov r0,r3
 726 002e 111C     	 mov r1,r2
 727 0030 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 131:../main.c     **** 				break;
 728              	 .loc 5 131 0
 729 0034 7EE0     	 b .L25
 730              	.L28:
 132:../main.c     **** 			case LED_ON:
 133:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 731              	 .loc 5 133 0
 732 0036 AD4B     	 ldr r3,.L54+12
 733 0038 181C     	 mov r0,r3
 734 003a 0021     	 mov r1,#0
 735 003c FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 134:../main.c     **** 				break;
 736              	 .loc 5 134 0
 737 0040 78E0     	 b .L25
 738              	.L29:
 135:../main.c     **** 			case LED_NUMBER:
 136:../main.c     **** 				if((led_number_continuous >= 1 && led_pattern_mode == LED_PATTERN_CONTINUOUS) || (led_number_si
 739              	 .loc 5 136 0
 740 0042 AC4B     	 ldr r3,.L54+20
 741 0044 1B88     	 ldrh r3,[r3]
 742 0046 002B     	 cmp r3,#0
 743 0048 03D0     	 beq .L33
 744              	 .loc 5 136 0 is_stmt 0 discriminator 1
 745 004a AB4B     	 ldr r3,.L54+24
 746 004c 1B78     	 ldrb r3,[r3]
 747 004e 002B     	 cmp r3,#0
 748 0050 07D0     	 beq .L34
 749              	.L33:
 750              	 .loc 5 136 0 discriminator 3
 751 0052 AA4B     	 ldr r3,.L54+28
 752 0054 1B88     	 ldrh r3,[r3]
 753 0056 002B     	 cmp r3,#0
 754 0058 15D0     	 beq .L35
 755              	 .loc 5 136 0 discriminator 4
 756 005a A74B     	 ldr r3,.L54+24
 757 005c 1B78     	 ldrb r3,[r3]
 758 005e 012B     	 cmp r3,#1
 759 0060 11D1     	 bne .L35
 760              	.L34:
 137:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 761              	 .loc 5 137 0 is_stmt 1
 762 0062 FFF7FEFF 	 bl SYSTIMER_GetTime
 763 0066 021C     	 mov r2,r0
 764 0068 A54B     	 ldr r3,.L54+32
 765 006a 1A60     	 str r2,[r3]
 138:../main.c     **** 					led_pattern_state_length = LED_PULSE_SHORT;
 766              	 .loc 5 138 0
 767 006c A54B     	 ldr r3,.L54+36
 768 006e C822     	 mov r2,#200
 769 0070 1A80     	 strh r2,[r3]
 139:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 770              	 .loc 5 139 0
 771 0072 9E4B     	 ldr r3,.L54+12
 772 0074 9E4A     	 ldr r2,.L54+16
 773 0076 181C     	 mov r0,r3
 774 0078 111C     	 mov r1,r2
 775 007a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 140:../main.c     **** 					led_pattern_state = 0;
 776              	 .loc 5 140 0
 777 007e A24B     	 ldr r3,.L54+40
 778 0080 0022     	 mov r2,#0
 779 0082 1A80     	 strh r2,[r3]
 141:../main.c     **** 				}
 142:../main.c     **** 				break;
 780              	 .loc 5 142 0
 781 0084 56E0     	 b .L25
 782              	.L35:
 783 0086 55E0     	 b .L25
 784              	.L30:
 143:../main.c     **** 			case LED_FADE_DOWN:
 144:../main.c     **** 				if(led_fadetime > 0){
 785              	 .loc 5 144 0
 786 0088 A04B     	 ldr r3,.L54+44
 787 008a 1B88     	 ldrh r3,[r3]
 788 008c 002B     	 cmp r3,#0
 789 008e 23D0     	 beq .L36
 145:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 790              	 .loc 5 145 0
 791 0090 FFF7FEFF 	 bl SYSTIMER_GetTime
 792 0094 021C     	 mov r2,r0
 793 0096 9A4B     	 ldr r3,.L54+32
 794 0098 1A60     	 str r2,[r3]
 146:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 795              	 .loc 5 146 0
 796 009a 9C4B     	 ldr r3,.L54+44
 797 009c 1A88     	 ldrh r2,[r3]
 798 009e 9C4B     	 ldr r3,.L54+48
 799 00a0 1B88     	 ldrh r3,[r3]
 800 00a2 101C     	 mov r0,r2
 801 00a4 191C     	 mov r1,r3
 802 00a6 FFF7FEFF 	 bl __aeabi_uidiv
 803 00aa 031C     	 mov r3,r0
 804 00ac 9AB2     	 uxth r2,r3
 805 00ae 954B     	 ldr r3,.L54+36
 806 00b0 1A80     	 strh r2,[r3]
 147:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 807              	 .loc 5 147 0
 808 00b2 974B     	 ldr r3,.L54+48
 809 00b4 1B88     	 ldrh r3,[r3]
 810 00b6 8E48     	 ldr r0,.L54+16
 811 00b8 191C     	 mov r1,r3
 812 00ba FFF7FEFF 	 bl __aeabi_uidiv
 813 00be 031C     	 mov r3,r0
 814 00c0 9AB2     	 uxth r2,r3
 815 00c2 944B     	 ldr r3,.L54+52
 816 00c4 1A80     	 strh r2,[r3]
 148:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 817              	 .loc 5 148 0
 818 00c6 894B     	 ldr r3,.L54+12
 819 00c8 181C     	 mov r0,r3
 820 00ca 0021     	 mov r1,#0
 821 00cc FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 149:../main.c     **** 					led_pattern_state = 0;
 822              	 .loc 5 149 0
 823 00d0 8D4B     	 ldr r3,.L54+40
 824 00d2 0022     	 mov r2,#0
 825 00d4 1A80     	 strh r2,[r3]
 150:../main.c     **** 				}
 151:../main.c     **** 				break;
 826              	 .loc 5 151 0
 827 00d6 2DE0     	 b .L25
 828              	.L36:
 829 00d8 2CE0     	 b .L25
 830              	.L31:
 152:../main.c     **** 			case LED_FADE_UP:
 153:../main.c     **** 				if(led_fadetime > 0){
 831              	 .loc 5 153 0
 832 00da 8C4B     	 ldr r3,.L54+44
 833 00dc 1B88     	 ldrh r3,[r3]
 834 00de 002B     	 cmp r3,#0
 835 00e0 24D0     	 beq .L37
 154:../main.c     **** 					led_pattern_state_timestamp = SYSTIMER_GetTime();
 836              	 .loc 5 154 0
 837 00e2 FFF7FEFF 	 bl SYSTIMER_GetTime
 838 00e6 021C     	 mov r2,r0
 839 00e8 854B     	 ldr r3,.L54+32
 840 00ea 1A60     	 str r2,[r3]
 155:../main.c     **** 					led_pattern_state_length = led_fadetime/led_fadesteps;
 841              	 .loc 5 155 0
 842 00ec 874B     	 ldr r3,.L54+44
 843 00ee 1A88     	 ldrh r2,[r3]
 844 00f0 874B     	 ldr r3,.L54+48
 845 00f2 1B88     	 ldrh r3,[r3]
 846 00f4 101C     	 mov r0,r2
 847 00f6 191C     	 mov r1,r3
 848 00f8 FFF7FEFF 	 bl __aeabi_uidiv
 849 00fc 031C     	 mov r3,r0
 850 00fe 9AB2     	 uxth r2,r3
 851 0100 804B     	 ldr r3,.L54+36
 852 0102 1A80     	 strh r2,[r3]
 156:../main.c     **** 					fade_duty_step = PWM_FULL_OFF/led_fadesteps;
 853              	 .loc 5 156 0
 854 0104 824B     	 ldr r3,.L54+48
 855 0106 1B88     	 ldrh r3,[r3]
 856 0108 7948     	 ldr r0,.L54+16
 857 010a 191C     	 mov r1,r3
 858 010c FFF7FEFF 	 bl __aeabi_uidiv
 859 0110 031C     	 mov r3,r0
 860 0112 9AB2     	 uxth r2,r3
 861 0114 7F4B     	 ldr r3,.L54+52
 862 0116 1A80     	 strh r2,[r3]
 157:../main.c     **** 					PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 863              	 .loc 5 157 0
 864 0118 744B     	 ldr r3,.L54+12
 865 011a 754A     	 ldr r2,.L54+16
 866 011c 181C     	 mov r0,r3
 867 011e 111C     	 mov r1,r2
 868 0120 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 158:../main.c     **** 					led_pattern_state = 0;
 869              	 .loc 5 158 0
 870 0124 784B     	 ldr r3,.L54+40
 871 0126 0022     	 mov r2,#0
 872 0128 1A80     	 strh r2,[r3]
 159:../main.c     **** 				}
 160:../main.c     **** 				break;
 873              	 .loc 5 160 0
 874 012a 03E0     	 b .L25
 875              	.L37:
 876 012c 02E0     	 b .L25
 877              	.L32:
 161:../main.c     **** 			case LED_MATCH_RELAY_STATE:
 162:../main.c     **** 				reset_status_led_to_relay_state();
 878              	 .loc 5 162 0
 879 012e FFF7FEFF 	 bl reset_status_led_to_relay_state
 163:../main.c     **** 				break;
 880              	 .loc 5 163 0
 881 0132 C046     	 mov r8,r8
 882              	.L25:
 164:../main.c     **** 		}
 165:../main.c     **** 		led_status_pattern_last = led_status_pattern;
 883              	 .loc 5 165 0
 884 0134 6A4B     	 ldr r3,.L54
 885 0136 1A78     	 ldrb r2,[r3]
 886 0138 6A4B     	 ldr r3,.L54+4
 887 013a 1A70     	 strb r2,[r3]
 888              	.L24:
 166:../main.c     **** 	}
 167:../main.c     **** 
 168:../main.c     **** 	// Handle LED_NUMBER pattern
 169:../main.c     **** 	if(led_status_pattern == LED_NUMBER){
 889              	 .loc 5 169 0
 890 013c 684B     	 ldr r3,.L54
 891 013e 1B78     	 ldrb r3,[r3]
 892 0140 022B     	 cmp r3,#2
 893 0142 00D0     	 beq .LCB580
 894 0144 6BE0     	 b .L38
 895              	.LCB580:
 170:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 896              	 .loc 5 170 0
 897 0146 FFF7FEFF 	 bl SYSTIMER_GetTime
 898 014a 021C     	 mov r2,r0
 899 014c 6C4B     	 ldr r3,.L54+32
 900 014e 1B68     	 ldr r3,[r3]
 901 0150 D31A     	 sub r3,r2,r3
 902 0152 181C     	 mov r0,r3
 903 0154 FA23     	 mov r3,#250
 904 0156 9900     	 lsl r1,r3,#2
 905 0158 FFF7FEFF 	 bl __aeabi_uidiv
 906 015c 031C     	 mov r3,r0
 907 015e 1A1C     	 mov r2,r3
 908 0160 684B     	 ldr r3,.L54+36
 909 0162 1B88     	 ldrh r3,[r3]
 910 0164 9A42     	 cmp r2,r3
 911 0166 59D3     	 bcc .L39
 912              	.LBB2:
 171:../main.c     **** 			// Next state
 172:../main.c     **** 			led_pattern_state++;
 913              	 .loc 5 172 0
 914 0168 674B     	 ldr r3,.L54+40
 915 016a 1B88     	 ldrh r3,[r3]
 916 016c 0133     	 add r3,r3,#1
 917 016e 9AB2     	 uxth r2,r3
 918 0170 654B     	 ldr r3,.L54+40
 919 0172 1A80     	 strh r2,[r3]
 173:../main.c     **** 
 174:../main.c     **** 			// Use right pulse number based on current pattern mode
 175:../main.c     **** 			uint16_t led_number;
 176:../main.c     **** 			if(led_pattern_mode == LED_PATTERN_CONTINUOUS)
 920              	 .loc 5 176 0
 921 0174 604B     	 ldr r3,.L54+24
 922 0176 1B78     	 ldrb r3,[r3]
 923 0178 002B     	 cmp r3,#0
 924 017a 04D1     	 bne .L40
 177:../main.c     **** 				led_number = led_number_continuous;
 925              	 .loc 5 177 0
 926 017c BB1D     	 add r3,r7,#6
 927 017e 5D4A     	 ldr r2,.L54+20
 928 0180 1288     	 ldrh r2,[r2]
 929 0182 1A80     	 strh r2,[r3]
 930 0184 03E0     	 b .L41
 931              	.L40:
 178:../main.c     **** 			else
 179:../main.c     **** 				led_number = led_number_single;
 932              	 .loc 5 179 0
 933 0186 BB1D     	 add r3,r7,#6
 934 0188 5C4A     	 ldr r2,.L54+28
 935 018a 1288     	 ldrh r2,[r2]
 936 018c 1A80     	 strh r2,[r3]
 937              	.L41:
 180:../main.c     **** 
 181:../main.c     **** 			// Check if LED must be powered on or off for this state
 182:../main.c     **** 			if(led_pattern_state % 2)
 938              	 .loc 5 182 0
 939 018e 5E4B     	 ldr r3,.L54+40
 940 0190 1B88     	 ldrh r3,[r3]
 941 0192 0122     	 mov r2,#1
 942 0194 1340     	 and r3,r2
 943 0196 9BB2     	 uxth r3,r3
 944 0198 002B     	 cmp r3,#0
 945 019a 05D0     	 beq .L42
 183:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 946              	 .loc 5 183 0
 947 019c 534B     	 ldr r3,.L54+12
 948 019e 181C     	 mov r0,r3
 949 01a0 0021     	 mov r1,#0
 950 01a2 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 951 01a6 05E0     	 b .L43
 952              	.L42:
 184:../main.c     **** 			else
 185:../main.c     **** 				PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 953              	 .loc 5 185 0
 954 01a8 504B     	 ldr r3,.L54+12
 955 01aa 514A     	 ldr r2,.L54+16
 956 01ac 181C     	 mov r0,r3
 957 01ae 111C     	 mov r1,r2
 958 01b0 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 959              	.L43:
 186:../main.c     **** 
 187:../main.c     **** 			// Detect last low phase and make it longer
 188:../main.c     **** 			if(led_pattern_state == (led_number*2) && led_pattern_mode == LED_PATTERN_CONTINUOUS)
 960              	 .loc 5 188 0
 961 01b4 544B     	 ldr r3,.L54+40
 962 01b6 1B88     	 ldrh r3,[r3]
 963 01b8 1A1C     	 mov r2,r3
 964 01ba BB1D     	 add r3,r7,#6
 965 01bc 1B88     	 ldrh r3,[r3]
 966 01be 5B00     	 lsl r3,r3,#1
 967 01c0 9A42     	 cmp r2,r3
 968 01c2 07D1     	 bne .L44
 969              	 .loc 5 188 0 is_stmt 0 discriminator 1
 970 01c4 4C4B     	 ldr r3,.L54+24
 971 01c6 1B78     	 ldrb r3,[r3]
 972 01c8 002B     	 cmp r3,#0
 973 01ca 03D1     	 bne .L44
 189:../main.c     **** 				led_pattern_state_length = LED_PULSE_LONG;
 974              	 .loc 5 189 0 is_stmt 1
 975 01cc 4D4B     	 ldr r3,.L54+36
 976 01ce 524A     	 ldr r2,.L54+56
 977 01d0 1A80     	 strh r2,[r3]
 978 01d2 02E0     	 b .L45
 979              	.L44:
 190:../main.c     **** 			else
 191:../main.c     **** 				led_pattern_state_length = LED_PULSE_SHORT;
 980              	 .loc 5 191 0
 981 01d4 4B4B     	 ldr r3,.L54+36
 982 01d6 C822     	 mov r2,#200
 983 01d8 1A80     	 strh r2,[r3]
 984              	.L45:
 192:../main.c     **** 
 193:../main.c     **** 			// Store current time
 194:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 985              	 .loc 5 194 0
 986 01da FFF7FEFF 	 bl SYSTIMER_GetTime
 987 01de 021C     	 mov r2,r0
 988 01e0 474B     	 ldr r3,.L54+32
 989 01e2 1A60     	 str r2,[r3]
 195:../main.c     **** 
 196:../main.c     **** 			// Check if LED pattern is finished
 197:../main.c     **** 			if(led_pattern_state > led_number*2){
 990              	 .loc 5 197 0
 991 01e4 484B     	 ldr r3,.L54+40
 992 01e6 1B88     	 ldrh r3,[r3]
 993 01e8 1A1C     	 mov r2,r3
 994 01ea BB1D     	 add r3,r7,#6
 995 01ec 1B88     	 ldrh r3,[r3]
 996 01ee 5B00     	 lsl r3,r3,#1
 997 01f0 9A42     	 cmp r2,r3
 998 01f2 13DD     	 ble .L39
 198:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS) // Repeat pattern
 999              	 .loc 5 198 0
 1000 01f4 404B     	 ldr r3,.L54+24
 1001 01f6 1B78     	 ldrb r3,[r3]
 1002 01f8 002B     	 cmp r3,#0
 1003 01fa 03D1     	 bne .L46
 199:../main.c     **** 					led_pattern_state = 1;
 1004              	 .loc 5 199 0
 1005 01fc 424B     	 ldr r3,.L54+40
 1006 01fe 0122     	 mov r2,#1
 1007 0200 1A80     	 strh r2,[r3]
 1008 0202 0BE0     	 b .L39
 1009              	.L46:
 200:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1010              	 .loc 5 200 0
 1011 0204 3C4B     	 ldr r3,.L54+24
 1012 0206 1B78     	 ldrb r3,[r3]
 1013 0208 012B     	 cmp r3,#1
 1014 020a 07D1     	 bne .L39
 201:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1015              	 .loc 5 201 0
 1016 020c 3A4B     	 ldr r3,.L54+24
 1017 020e 0022     	 mov r2,#0
 1018 0210 1A70     	 strb r2,[r3]
 202:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1019              	 .loc 5 202 0
 1020 0212 424B     	 ldr r3,.L54+60
 1021 0214 1A78     	 ldrb r2,[r3]
 1022 0216 324B     	 ldr r3,.L54
 1023 0218 1A70     	 strb r2,[r3]
 1024              	.LBE2:
 1025 021a DEE0     	 b .L23
 1026              	.L39:
 1027 021c DDE0     	 b .L23
 1028              	.L38:
 203:../main.c     **** 				}
 204:../main.c     **** 			}
 205:../main.c     **** 		}
 206:../main.c     **** 	}
 207:../main.c     **** 
 208:../main.c     **** 	// Handle LED_FADE_UP pattern
 209:../main.c     **** 	else if(led_status_pattern == LED_FADE_DOWN){
 1029              	 .loc 5 209 0
 1030 021e 304B     	 ldr r3,.L54
 1031 0220 1B78     	 ldrb r3,[r3]
 1032 0222 032B     	 cmp r3,#3
 1033 0224 00D0     	 beq .LCB713
 1034 0226 7BE0     	 b .L48
 1035              	.LCB713:
 210:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 1036              	 .loc 5 210 0
 1037 0228 FFF7FEFF 	 bl SYSTIMER_GetTime
 1038 022c 021C     	 mov r2,r0
 1039 022e 344B     	 ldr r3,.L54+32
 1040 0230 1B68     	 ldr r3,[r3]
 1041 0232 D31A     	 sub r3,r2,r3
 1042 0234 181C     	 mov r0,r3
 1043 0236 FA23     	 mov r3,#250
 1044 0238 9900     	 lsl r1,r3,#2
 1045 023a FFF7FEFF 	 bl __aeabi_uidiv
 1046 023e 031C     	 mov r3,r0
 1047 0240 1A1C     	 mov r2,r3
 1048 0242 304B     	 ldr r3,.L54+36
 1049 0244 1B88     	 ldrh r3,[r3]
 1050 0246 9A42     	 cmp r2,r3
 1051 0248 00D2     	 bcs .LCB728
 1052 024a C6E0     	 b .L23
 1053              	.LCB728:
 211:../main.c     **** 			// Set intensity of led to a level based on maximum value and current step
 212:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, (led_pattern_state*fade_duty_step) + PWM_FULL_ON);
 1054              	 .loc 5 212 0
 1055 024c 2E4B     	 ldr r3,.L54+40
 1056 024e 1B88     	 ldrh r3,[r3]
 1057 0250 1A1C     	 mov r2,r3
 1058 0252 304B     	 ldr r3,.L54+52
 1059 0254 1B88     	 ldrh r3,[r3]
 1060 0256 5343     	 mul r3,r2
 1061 0258 1A1C     	 mov r2,r3
 1062 025a 244B     	 ldr r3,.L54+12
 1063 025c 181C     	 mov r0,r3
 1064 025e 111C     	 mov r1,r2
 1065 0260 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 213:../main.c     **** 
 214:../main.c     **** 			// Store current time
 215:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 1066              	 .loc 5 215 0
 1067 0264 FFF7FEFF 	 bl SYSTIMER_GetTime
 1068 0268 021C     	 mov r2,r0
 1069 026a 254B     	 ldr r3,.L54+32
 1070 026c 1A60     	 str r2,[r3]
 216:../main.c     **** 
 217:../main.c     **** 			// Next state
 218:../main.c     **** 			led_pattern_state++;
 1071              	 .loc 5 218 0
 1072 026e 264B     	 ldr r3,.L54+40
 1073 0270 1B88     	 ldrh r3,[r3]
 1074 0272 0133     	 add r3,r3,#1
 1075 0274 9AB2     	 uxth r2,r3
 1076 0276 244B     	 ldr r3,.L54+40
 1077 0278 1A80     	 strh r2,[r3]
 219:../main.c     **** 
 220:../main.c     **** 			// Make last state longer
 221:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 1078              	 .loc 5 221 0
 1079 027a 234B     	 ldr r3,.L54+40
 1080 027c 1B88     	 ldrh r3,[r3]
 1081 027e 1A1C     	 mov r2,r3
 1082 0280 234B     	 ldr r3,.L54+48
 1083 0282 1B88     	 ldrh r3,[r3]
 1084 0284 013B     	 sub r3,r3,#1
 1085 0286 9A42     	 cmp r2,r3
 1086 0288 06D1     	 bne .L50
 222:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 1087              	 .loc 5 222 0
 1088 028a 1E4B     	 ldr r3,.L54+36
 1089 028c 1B88     	 ldrh r3,[r3]
 1090 028e 9133     	 add r3,r3,#145
 1091 0290 FF33     	 add r3,r3,#255
 1092 0292 9AB2     	 uxth r2,r3
 1093 0294 1B4B     	 ldr r3,.L54+36
 1094 0296 1A80     	 strh r2,[r3]
 1095              	.L50:
 223:../main.c     **** 
 224:../main.c     **** 			// Check if LED pattern is finished
 225:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1096              	 .loc 5 225 0
 1097 0298 1B4B     	 ldr r3,.L54+40
 1098 029a 1A88     	 ldrh r2,[r3]
 1099 029c 1C4B     	 ldr r3,.L54+48
 1100 029e 1B88     	 ldrh r3,[r3]
 1101 02a0 9A42     	 cmp r2,r3
 1102 02a2 00D2     	 bcs .LCB772
 1103 02a4 99E0     	 b .L23
 1104              	.LCB772:
 226:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1105              	 .loc 5 226 0
 1106 02a6 144B     	 ldr r3,.L54+24
 1107 02a8 1B78     	 ldrb r3,[r3]
 1108 02aa 002B     	 cmp r3,#0
 1109 02ac 0AD1     	 bne .L51
 227:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1110              	 .loc 5 227 0
 1111 02ae 154B     	 ldr r3,.L54+36
 1112 02b0 1B88     	 ldrh r3,[r3]
 1113 02b2 913B     	 sub r3,r3,#145
 1114 02b4 FF3B     	 sub r3,r3,#255
 1115 02b6 9AB2     	 uxth r2,r3
 1116 02b8 124B     	 ldr r3,.L54+36
 1117 02ba 1A80     	 strh r2,[r3]
 228:../main.c     **** 					led_pattern_state = 0;
 1118              	 .loc 5 228 0
 1119 02bc 124B     	 ldr r3,.L54+40
 1120 02be 0022     	 mov r2,#0
 1121 02c0 1A80     	 strh r2,[r3]
 1122 02c2 8AE0     	 b .L23
 1123              	.L51:
 229:../main.c     **** 				}
 230:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1124              	 .loc 5 230 0
 1125 02c4 0C4B     	 ldr r3,.L54+24
 1126 02c6 1B78     	 ldrb r3,[r3]
 1127 02c8 012B     	 cmp r3,#1
 1128 02ca 00D0     	 beq .LCB794
 1129 02cc 85E0     	 b .L23
 1130              	.LCB794:
 231:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1131              	 .loc 5 231 0
 1132 02ce 0A4B     	 ldr r3,.L54+24
 1133 02d0 0022     	 mov r2,#0
 1134 02d2 1A70     	 strb r2,[r3]
 232:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1135              	 .loc 5 232 0
 1136 02d4 114B     	 ldr r3,.L54+60
 1137 02d6 1A78     	 ldrb r2,[r3]
 1138 02d8 014B     	 ldr r3,.L54
 1139 02da 1A70     	 strb r2,[r3]
 1140 02dc 7DE0     	 b .L23
 1141              	.L55:
 1142 02de C046     	 .align 2
 1143              	.L54:
 1144 02e0 00000000 	 .word led_status_pattern
 1145 02e4 00000000 	 .word led_status_pattern_last
 1146 02e8 00000000 	 .word .L27
 1147 02ec 00000000 	 .word PWM_CCU4_LED_STATUS
 1148 02f0 10270000 	 .word 10000
 1149 02f4 00000000 	 .word led_number_continuous
 1150 02f8 00000000 	 .word led_pattern_mode
 1151 02fc 00000000 	 .word led_number_single
 1152 0300 00000000 	 .word led_pattern_state_timestamp.7189
 1153 0304 00000000 	 .word led_pattern_state_length.7190
 1154 0308 00000000 	 .word led_pattern_state.7188
 1155 030c 00000000 	 .word led_fadetime
 1156 0310 00000000 	 .word led_fadesteps
 1157 0314 00000000 	 .word fade_duty_step.7191
 1158 0318 4C040000 	 .word 1100
 1159 031c 00000000 	 .word led_status_pattern_after_single
 1160              	.L48:
 233:../main.c     **** 				}
 234:../main.c     **** 			}
 235:../main.c     **** 		}
 236:../main.c     **** 	}
 237:../main.c     **** 
 238:../main.c     **** 	// Handle LED_FADE_DOWN pattern
 239:../main.c     **** 	else if(led_status_pattern == LED_FADE_UP){
 1161              	 .loc 5 239 0
 1162 0320 2F4B     	 ldr r3,.L56
 1163 0322 1B78     	 ldrb r3,[r3]
 1164 0324 042B     	 cmp r3,#4
 1165 0326 58D1     	 bne .L23
 240:../main.c     **** 		if((SYSTIMER_GetTime() - led_pattern_state_timestamp) / 1000 >= led_pattern_state_length){
 1166              	 .loc 5 240 0
 1167 0328 FFF7FEFF 	 bl SYSTIMER_GetTime
 1168 032c 021C     	 mov r2,r0
 1169 032e 2D4B     	 ldr r3,.L56+4
 1170 0330 1B68     	 ldr r3,[r3]
 1171 0332 D31A     	 sub r3,r2,r3
 1172 0334 181C     	 mov r0,r3
 1173 0336 FA23     	 mov r3,#250
 1174 0338 9900     	 lsl r1,r3,#2
 1175 033a FFF7FEFF 	 bl __aeabi_uidiv
 1176 033e 031C     	 mov r3,r0
 1177 0340 1A1C     	 mov r2,r3
 1178 0342 294B     	 ldr r3,.L56+8
 1179 0344 1B88     	 ldrh r3,[r3]
 1180 0346 9A42     	 cmp r2,r3
 1181 0348 47D3     	 bcc .L23
 241:../main.c     **** 			// Set intensity of led to a level based on maximum value and current step
 242:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF - (led_pattern_state*fade_duty_step) );
 1182              	 .loc 5 242 0
 1183 034a 284B     	 ldr r3,.L56+12
 1184 034c 1B88     	 ldrh r3,[r3]
 1185 034e 1A1C     	 mov r2,r3
 1186 0350 274B     	 ldr r3,.L56+16
 1187 0352 1B88     	 ldrh r3,[r3]
 1188 0354 5343     	 mul r3,r2
 1189 0356 1A1C     	 mov r2,r3
 1190 0358 264B     	 ldr r3,.L56+20
 1191 035a 9B1A     	 sub r3,r3,r2
 1192 035c 264A     	 ldr r2,.L56+24
 1193 035e 101C     	 mov r0,r2
 1194 0360 191C     	 mov r1,r3
 1195 0362 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 243:../main.c     **** 
 244:../main.c     **** 			// Store current time
 245:../main.c     **** 			led_pattern_state_timestamp = SYSTIMER_GetTime();
 1196              	 .loc 5 245 0
 1197 0366 FFF7FEFF 	 bl SYSTIMER_GetTime
 1198 036a 021C     	 mov r2,r0
 1199 036c 1D4B     	 ldr r3,.L56+4
 1200 036e 1A60     	 str r2,[r3]
 246:../main.c     **** 
 247:../main.c     **** 			// Next state
 248:../main.c     **** 			led_pattern_state++;
 1201              	 .loc 5 248 0
 1202 0370 1E4B     	 ldr r3,.L56+12
 1203 0372 1B88     	 ldrh r3,[r3]
 1204 0374 0133     	 add r3,r3,#1
 1205 0376 9AB2     	 uxth r2,r3
 1206 0378 1C4B     	 ldr r3,.L56+12
 1207 037a 1A80     	 strh r2,[r3]
 249:../main.c     **** 
 250:../main.c     **** 			// Make last state longer
 251:../main.c     **** 			if(led_pattern_state == led_fadesteps-1)
 1208              	 .loc 5 251 0
 1209 037c 1B4B     	 ldr r3,.L56+12
 1210 037e 1B88     	 ldrh r3,[r3]
 1211 0380 1A1C     	 mov r2,r3
 1212 0382 1E4B     	 ldr r3,.L56+28
 1213 0384 1B88     	 ldrh r3,[r3]
 1214 0386 013B     	 sub r3,r3,#1
 1215 0388 9A42     	 cmp r2,r3
 1216 038a 06D1     	 bne .L52
 252:../main.c     **** 				led_pattern_state_length = led_pattern_state_length + 400;
 1217              	 .loc 5 252 0
 1218 038c 164B     	 ldr r3,.L56+8
 1219 038e 1B88     	 ldrh r3,[r3]
 1220 0390 9133     	 add r3,r3,#145
 1221 0392 FF33     	 add r3,r3,#255
 1222 0394 9AB2     	 uxth r2,r3
 1223 0396 144B     	 ldr r3,.L56+8
 1224 0398 1A80     	 strh r2,[r3]
 1225              	.L52:
 253:../main.c     **** 
 254:../main.c     **** 			// Check if LED pattern is finished
 255:../main.c     **** 			if(led_pattern_state >= led_fadesteps){
 1226              	 .loc 5 255 0
 1227 039a 144B     	 ldr r3,.L56+12
 1228 039c 1A88     	 ldrh r2,[r3]
 1229 039e 174B     	 ldr r3,.L56+28
 1230 03a0 1B88     	 ldrh r3,[r3]
 1231 03a2 9A42     	 cmp r2,r3
 1232 03a4 19D3     	 bcc .L23
 256:../main.c     **** 				if(led_pattern_mode == LED_PATTERN_CONTINUOUS){ // Repeat pattern
 1233              	 .loc 5 256 0
 1234 03a6 164B     	 ldr r3,.L56+32
 1235 03a8 1B78     	 ldrb r3,[r3]
 1236 03aa 002B     	 cmp r3,#0
 1237 03ac 0AD1     	 bne .L53
 257:../main.c     **** 					led_pattern_state_length = led_pattern_state_length - 400;
 1238              	 .loc 5 257 0
 1239 03ae 0E4B     	 ldr r3,.L56+8
 1240 03b0 1B88     	 ldrh r3,[r3]
 1241 03b2 913B     	 sub r3,r3,#145
 1242 03b4 FF3B     	 sub r3,r3,#255
 1243 03b6 9AB2     	 uxth r2,r3
 1244 03b8 0B4B     	 ldr r3,.L56+8
 1245 03ba 1A80     	 strh r2,[r3]
 258:../main.c     **** 					led_pattern_state = 0;
 1246              	 .loc 5 258 0
 1247 03bc 0B4B     	 ldr r3,.L56+12
 1248 03be 0022     	 mov r2,#0
 1249 03c0 1A80     	 strh r2,[r3]
 1250 03c2 0AE0     	 b .L23
 1251              	.L53:
 259:../main.c     **** 				}
 260:../main.c     **** 				else if(led_pattern_mode == LED_PATTERN_SINGLE){ // Reset led and pattern mode
 1252              	 .loc 5 260 0
 1253 03c4 0E4B     	 ldr r3,.L56+32
 1254 03c6 1B78     	 ldrb r3,[r3]
 1255 03c8 012B     	 cmp r3,#1
 1256 03ca 06D1     	 bne .L23
 261:../main.c     **** 					led_pattern_mode = LED_PATTERN_CONTINUOUS;
 1257              	 .loc 5 261 0
 1258 03cc 0C4B     	 ldr r3,.L56+32
 1259 03ce 0022     	 mov r2,#0
 1260 03d0 1A70     	 strb r2,[r3]
 262:../main.c     **** 					led_status_pattern = led_status_pattern_after_single;
 1261              	 .loc 5 262 0
 1262 03d2 0C4B     	 ldr r3,.L56+36
 1263 03d4 1A78     	 ldrb r2,[r3]
 1264 03d6 024B     	 ldr r3,.L56
 1265 03d8 1A70     	 strb r2,[r3]
 1266              	.L23:
 263:../main.c     **** 				}
 264:../main.c     **** 			}
 265:../main.c     **** 		}
 266:../main.c     **** 	}
 267:../main.c     **** }
 1267              	 .loc 5 267 0
 1268 03da BD46     	 mov sp,r7
 1269 03dc 02B0     	 add sp,sp,#8
 1270              	 
 1271 03de 80BD     	 pop {r7,pc}
 1272              	.L57:
 1273              	 .align 2
 1274              	.L56:
 1275 03e0 00000000 	 .word led_status_pattern
 1276 03e4 00000000 	 .word led_pattern_state_timestamp.7189
 1277 03e8 00000000 	 .word led_pattern_state_length.7190
 1278 03ec 00000000 	 .word led_pattern_state.7188
 1279 03f0 00000000 	 .word fade_duty_step.7191
 1280 03f4 10270000 	 .word 10000
 1281 03f8 00000000 	 .word PWM_CCU4_LED_STATUS
 1282 03fc 00000000 	 .word led_fadesteps
 1283 0400 00000000 	 .word led_pattern_mode
 1284 0404 00000000 	 .word led_status_pattern_after_single
 1285              	 .cfi_endproc
 1286              	.LFE162:
 1288              	 .section .text.read_eeprom_setup,"ax",%progbits
 1289              	 .align 2
 1290              	 .global read_eeprom_setup
 1291              	 .code 16
 1292              	 .thumb_func
 1294              	read_eeprom_setup:
 1295              	.LFB163:
 268:../main.c     **** 
 269:../main.c     **** //****************************************************************************
 270:../main.c     **** // read_eeprom_setup -
 271:../main.c     **** //****************************************************************************
 272:../main.c     **** void read_eeprom_setup(void){
 1296              	 .loc 5 272 0
 1297              	 .cfi_startproc
 1298 0000 80B5     	 push {r7,lr}
 1299              	.LCFI33:
 1300              	 .cfi_def_cfa_offset 8
 1301              	 .cfi_offset 7,-8
 1302              	 .cfi_offset 14,-4
 1303 0002 84B0     	 sub sp,sp,#16
 1304              	.LCFI34:
 1305              	 .cfi_def_cfa_offset 24
 1306 0004 00AF     	 add r7,sp,#0
 1307              	.LCFI35:
 1308              	 .cfi_def_cfa_register 7
 273:../main.c     **** 	uint8_t ReadBuffer_LTH[4];
 274:../main.c     **** 	uint8_t ReadBuffer_UTH[4];
 275:../main.c     **** 	uint8_t ReadBuffer_LT[4];
 276:../main.c     **** 	uint8_t ReadBuffer_USB[4];
 277:../main.c     **** 
 278:../main.c     **** 	// Read from EEPROM and interpret value
 279:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_LOWER_TH, 0, ReadBuffer_LTH, 4U);
 1309              	 .loc 5 279 0
 1310 0006 0C23     	 mov r3,#12
 1311 0008 FB18     	 add r3,r7,r3
 1312 000a 0120     	 mov r0,#1
 1313 000c 0021     	 mov r1,#0
 1314 000e 1A1C     	 mov r2,r3
 1315 0010 0423     	 mov r3,#4
 1316 0012 FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 280:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_UPPER_TH, 0U, ReadBuffer_UTH, 4U);
 1317              	 .loc 5 280 0
 1318 0016 0823     	 mov r3,#8
 1319 0018 FB18     	 add r3,r7,r3
 1320 001a 0220     	 mov r0,#2
 1321 001c 0021     	 mov r1,#0
 1322 001e 1A1C     	 mov r2,r3
 1323 0020 0423     	 mov r3,#4
 1324 0022 FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 281:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_LATCHTIME, 0U, ReadBuffer_LT, 4U);
 1325              	 .loc 5 281 0
 1326 0026 3B1D     	 add r3,r7,#4
 1327 0028 0320     	 mov r0,#3
 1328 002a 0021     	 mov r1,#0
 1329 002c 1A1C     	 mov r2,r3
 1330 002e 0423     	 mov r3,#4
 1331 0030 FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 282:../main.c     **** 	E_EEPROM_XMC1_Read(EEPROM_USB_STATE, 0U, ReadBuffer_USB, 4U);
 1332              	 .loc 5 282 0
 1333 0034 3B1C     	 mov r3,r7
 1334 0036 0420     	 mov r0,#4
 1335 0038 0021     	 mov r1,#0
 1336 003a 1A1C     	 mov r2,r3
 1337 003c 0423     	 mov r3,#4
 1338 003e FFF7FEFF 	 bl E_EEPROM_XMC1_Read
 283:../main.c     **** 	eeprom_lower = ReadBuffer_LTH[0] + (ReadBuffer_LTH[1] << 8) + (ReadBuffer_LTH[2] << 16) + (ReadBuf
 1339              	 .loc 5 283 0
 1340 0042 0C23     	 mov r3,#12
 1341 0044 FB18     	 add r3,r7,r3
 1342 0046 1B78     	 ldrb r3,[r3]
 1343 0048 1A1C     	 mov r2,r3
 1344 004a 0C23     	 mov r3,#12
 1345 004c FB18     	 add r3,r7,r3
 1346 004e 5B78     	 ldrb r3,[r3,#1]
 1347 0050 1B02     	 lsl r3,r3,#8
 1348 0052 D218     	 add r2,r2,r3
 1349 0054 0C23     	 mov r3,#12
 1350 0056 FB18     	 add r3,r7,r3
 1351 0058 9B78     	 ldrb r3,[r3,#2]
 1352 005a 1B04     	 lsl r3,r3,#16
 1353 005c D218     	 add r2,r2,r3
 1354 005e 0C23     	 mov r3,#12
 1355 0060 FB18     	 add r3,r7,r3
 1356 0062 DB78     	 ldrb r3,[r3,#3]
 1357 0064 1B06     	 lsl r3,r3,#24
 1358 0066 D218     	 add r2,r2,r3
 1359 0068 734B     	 ldr r3,.L71
 1360 006a 1A60     	 str r2,[r3]
 284:../main.c     **** 	eeprom_upper = ReadBuffer_UTH[0] + (ReadBuffer_UTH[1] << 8) + (ReadBuffer_UTH[2] << 16) + (ReadBuf
 1361              	 .loc 5 284 0
 1362 006c 0823     	 mov r3,#8
 1363 006e FB18     	 add r3,r7,r3
 1364 0070 1B78     	 ldrb r3,[r3]
 1365 0072 1A1C     	 mov r2,r3
 1366 0074 0823     	 mov r3,#8
 1367 0076 FB18     	 add r3,r7,r3
 1368 0078 5B78     	 ldrb r3,[r3,#1]
 1369 007a 1B02     	 lsl r3,r3,#8
 1370 007c D218     	 add r2,r2,r3
 1371 007e 0823     	 mov r3,#8
 1372 0080 FB18     	 add r3,r7,r3
 1373 0082 9B78     	 ldrb r3,[r3,#2]
 1374 0084 1B04     	 lsl r3,r3,#16
 1375 0086 D218     	 add r2,r2,r3
 1376 0088 0823     	 mov r3,#8
 1377 008a FB18     	 add r3,r7,r3
 1378 008c DB78     	 ldrb r3,[r3,#3]
 1379 008e 1B06     	 lsl r3,r3,#24
 1380 0090 D218     	 add r2,r2,r3
 1381 0092 6A4B     	 ldr r3,.L71+4
 1382 0094 1A60     	 str r2,[r3]
 285:../main.c     **** 	eeprom_latchtime = ReadBuffer_LT[0] + (ReadBuffer_LT[1] << 8) + (ReadBuffer_LT[2] << 16) + (ReadBu
 1383              	 .loc 5 285 0
 1384 0096 3B1D     	 add r3,r7,#4
 1385 0098 1B78     	 ldrb r3,[r3]
 1386 009a 1A1C     	 mov r2,r3
 1387 009c 3B1D     	 add r3,r7,#4
 1388 009e 5B78     	 ldrb r3,[r3,#1]
 1389 00a0 1B02     	 lsl r3,r3,#8
 1390 00a2 D218     	 add r2,r2,r3
 1391 00a4 3B1D     	 add r3,r7,#4
 1392 00a6 9B78     	 ldrb r3,[r3,#2]
 1393 00a8 1B04     	 lsl r3,r3,#16
 1394 00aa D218     	 add r2,r2,r3
 1395 00ac 3B1D     	 add r3,r7,#4
 1396 00ae DB78     	 ldrb r3,[r3,#3]
 1397 00b0 1B06     	 lsl r3,r3,#24
 1398 00b2 D218     	 add r2,r2,r3
 1399 00b4 624B     	 ldr r3,.L71+8
 1400 00b6 1A60     	 str r2,[r3]
 286:../main.c     **** 	eeprom_usb_state = ReadBuffer_USB[0] + (ReadBuffer_USB[1] << 8) + (ReadBuffer_USB[2] << 16) + (Rea
 1401              	 .loc 5 286 0
 1402 00b8 3B1C     	 mov r3,r7
 1403 00ba 1B78     	 ldrb r3,[r3]
 1404 00bc 1A1C     	 mov r2,r3
 1405 00be 3B1C     	 mov r3,r7
 1406 00c0 5B78     	 ldrb r3,[r3,#1]
 1407 00c2 1B02     	 lsl r3,r3,#8
 1408 00c4 D218     	 add r2,r2,r3
 1409 00c6 3B1C     	 mov r3,r7
 1410 00c8 9B78     	 ldrb r3,[r3,#2]
 1411 00ca 1B04     	 lsl r3,r3,#16
 1412 00cc D218     	 add r2,r2,r3
 1413 00ce 3B1C     	 mov r3,r7
 1414 00d0 DB78     	 ldrb r3,[r3,#3]
 1415 00d2 1B06     	 lsl r3,r3,#24
 1416 00d4 D218     	 add r2,r2,r3
 1417 00d6 5B4B     	 ldr r3,.L71+12
 1418 00d8 1A60     	 str r2,[r3]
 287:../main.c     **** 
 288:../main.c     **** 	/// Check if values make sense, else return to default
 289:../main.c     **** 	// Restore upper threshold from EEPROM or blink on error
 290:../main.c     **** 	if(eeprom_upper < 0 || eeprom_upper > ADC_THRESHOLD_MAX){
 1419              	 .loc 5 290 0
 1420 00da 584B     	 ldr r3,.L71+4
 1421 00dc 1B68     	 ldr r3,[r3]
 1422 00de 002B     	 cmp r3,#0
 1423 00e0 04DB     	 blt .L59
 1424              	 .loc 5 290 0 is_stmt 0 discriminator 1
 1425 00e2 564B     	 ldr r3,.L71+4
 1426 00e4 1B68     	 ldr r3,[r3]
 1427 00e6 584A     	 ldr r2,.L71+16
 1428 00e8 9342     	 cmp r3,r2
 1429 00ea 27DD     	 ble .L60
 1430              	.L59:
 291:../main.c     **** 		ADC_upper_threshold = ADC_TH_UPPER_DEFAULT;
 1431              	 .loc 5 291 0 is_stmt 1
 1432 00ec 574B     	 ldr r3,.L71+20
 1433 00ee 584A     	 ldr r2,.L71+24
 1434 00f0 1A60     	 str r2,[r3]
 292:../main.c     **** 		// Blink LED for error indication
 293:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1435              	 .loc 5 293 0
 1436 00f2 584B     	 ldr r3,.L71+28
 1437 00f4 181C     	 mov r0,r3
 1438 00f6 0021     	 mov r1,#0
 1439 00f8 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 294:../main.c     **** 		delay_ms(150);
 1440              	 .loc 5 294 0
 1441 00fc 9620     	 mov r0,#150
 1442 00fe FFF7FEFF 	 bl delay_ms
 295:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1443              	 .loc 5 295 0
 1444 0102 544B     	 ldr r3,.L71+28
 1445 0104 544A     	 ldr r2,.L71+32
 1446 0106 181C     	 mov r0,r3
 1447 0108 111C     	 mov r1,r2
 1448 010a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 296:../main.c     **** 		delay_ms(200);
 1449              	 .loc 5 296 0
 1450 010e C820     	 mov r0,#200
 1451 0110 FFF7FEFF 	 bl delay_ms
 297:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1452              	 .loc 5 297 0
 1453 0114 4F4B     	 ldr r3,.L71+28
 1454 0116 181C     	 mov r0,r3
 1455 0118 0021     	 mov r1,#0
 1456 011a FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 298:../main.c     **** 		delay_ms(150);
 1457              	 .loc 5 298 0
 1458 011e 9620     	 mov r0,#150
 1459 0120 FFF7FEFF 	 bl delay_ms
 299:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1460              	 .loc 5 299 0
 1461 0124 4B4B     	 ldr r3,.L71+28
 1462 0126 4C4A     	 ldr r2,.L71+32
 1463 0128 181C     	 mov r0,r3
 1464 012a 111C     	 mov r1,r2
 1465 012c FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 300:../main.c     **** 		delay_ms(500);
 1466              	 .loc 5 300 0
 1467 0130 FA23     	 mov r3,#250
 1468 0132 5B00     	 lsl r3,r3,#1
 1469 0134 181C     	 mov r0,r3
 1470 0136 FFF7FEFF 	 bl delay_ms
 1471 013a 03E0     	 b .L61
 1472              	.L60:
 301:../main.c     **** 	}
 302:../main.c     **** 	else{
 303:../main.c     **** 		ADC_upper_threshold = eeprom_upper;
 1473              	 .loc 5 303 0
 1474 013c 3F4B     	 ldr r3,.L71+4
 1475 013e 1A68     	 ldr r2,[r3]
 1476 0140 424B     	 ldr r3,.L71+20
 1477 0142 1A60     	 str r2,[r3]
 1478              	.L61:
 304:../main.c     **** 	}
 305:../main.c     **** 	// Restore lower threshold from EEPROM or blink on error
 306:../main.c     **** 	if(eeprom_lower < 0 || eeprom_lower > ADC_THRESHOLD_MAX){
 1479              	 .loc 5 306 0
 1480 0144 3C4B     	 ldr r3,.L71
 1481 0146 1B68     	 ldr r3,[r3]
 1482 0148 002B     	 cmp r3,#0
 1483 014a 04DB     	 blt .L62
 1484              	 .loc 5 306 0 is_stmt 0 discriminator 1
 1485 014c 3A4B     	 ldr r3,.L71
 1486 014e 1B68     	 ldr r3,[r3]
 1487 0150 3D4A     	 ldr r2,.L71+16
 1488 0152 9342     	 cmp r3,r2
 1489 0154 27DD     	 ble .L63
 1490              	.L62:
 307:../main.c     **** 		ADC_lower_threshold = ADC_TH_LOWER_DEFAULT;
 1491              	 .loc 5 307 0 is_stmt 1
 1492 0156 414B     	 ldr r3,.L71+36
 1493 0158 414A     	 ldr r2,.L71+40
 1494 015a 1A60     	 str r2,[r3]
 308:../main.c     **** 		// Blink LED for error indication
 309:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1495              	 .loc 5 309 0
 1496 015c 3D4B     	 ldr r3,.L71+28
 1497 015e 181C     	 mov r0,r3
 1498 0160 0021     	 mov r1,#0
 1499 0162 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 310:../main.c     **** 		delay_ms(150);
 1500              	 .loc 5 310 0
 1501 0166 9620     	 mov r0,#150
 1502 0168 FFF7FEFF 	 bl delay_ms
 311:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1503              	 .loc 5 311 0
 1504 016c 394B     	 ldr r3,.L71+28
 1505 016e 3A4A     	 ldr r2,.L71+32
 1506 0170 181C     	 mov r0,r3
 1507 0172 111C     	 mov r1,r2
 1508 0174 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 312:../main.c     **** 		delay_ms(200);
 1509              	 .loc 5 312 0
 1510 0178 C820     	 mov r0,#200
 1511 017a FFF7FEFF 	 bl delay_ms
 313:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1512              	 .loc 5 313 0
 1513 017e 354B     	 ldr r3,.L71+28
 1514 0180 181C     	 mov r0,r3
 1515 0182 0021     	 mov r1,#0
 1516 0184 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 314:../main.c     **** 		delay_ms(150);
 1517              	 .loc 5 314 0
 1518 0188 9620     	 mov r0,#150
 1519 018a FFF7FEFF 	 bl delay_ms
 315:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1520              	 .loc 5 315 0
 1521 018e 314B     	 ldr r3,.L71+28
 1522 0190 314A     	 ldr r2,.L71+32
 1523 0192 181C     	 mov r0,r3
 1524 0194 111C     	 mov r1,r2
 1525 0196 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 316:../main.c     **** 		delay_ms(500);
 1526              	 .loc 5 316 0
 1527 019a FA23     	 mov r3,#250
 1528 019c 5B00     	 lsl r3,r3,#1
 1529 019e 181C     	 mov r0,r3
 1530 01a0 FFF7FEFF 	 bl delay_ms
 1531 01a4 03E0     	 b .L64
 1532              	.L63:
 317:../main.c     **** 	}
 318:../main.c     **** 	else{
 319:../main.c     **** 		ADC_lower_threshold = eeprom_lower;
 1533              	 .loc 5 319 0
 1534 01a6 244B     	 ldr r3,.L71
 1535 01a8 1A68     	 ldr r2,[r3]
 1536 01aa 2C4B     	 ldr r3,.L71+36
 1537 01ac 1A60     	 str r2,[r3]
 1538              	.L64:
 320:../main.c     **** 	}
 321:../main.c     **** 	// Restore latchtime from EEPROM or blink on error
 322:../main.c     **** 	if(eeprom_latchtime < 0 || eeprom_latchtime > ADC_THRESHOLD_MAX){
 1539              	 .loc 5 322 0
 1540 01ae 244B     	 ldr r3,.L71+8
 1541 01b0 1B68     	 ldr r3,[r3]
 1542 01b2 002B     	 cmp r3,#0
 1543 01b4 04DB     	 blt .L65
 1544              	 .loc 5 322 0 is_stmt 0 discriminator 1
 1545 01b6 224B     	 ldr r3,.L71+8
 1546 01b8 1B68     	 ldr r3,[r3]
 1547 01ba 234A     	 ldr r2,.L71+16
 1548 01bc 9342     	 cmp r3,r2
 1549 01be 23DD     	 ble .L66
 1550              	.L65:
 323:../main.c     **** 		relay_threshold_latchtime = RELAY_LATCHTIME_DEFAULT;
 1551              	 .loc 5 323 0 is_stmt 1
 1552 01c0 284B     	 ldr r3,.L71+44
 1553 01c2 FA22     	 mov r2,#250
 1554 01c4 5200     	 lsl r2,r2,#1
 1555 01c6 1A60     	 str r2,[r3]
 324:../main.c     **** 		// Blink LED for error indication
 325:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1556              	 .loc 5 325 0
 1557 01c8 224B     	 ldr r3,.L71+28
 1558 01ca 181C     	 mov r0,r3
 1559 01cc 0021     	 mov r1,#0
 1560 01ce FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 326:../main.c     **** 		delay_ms(150);
 1561              	 .loc 5 326 0
 1562 01d2 9620     	 mov r0,#150
 1563 01d4 FFF7FEFF 	 bl delay_ms
 327:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1564              	 .loc 5 327 0
 1565 01d8 1E4B     	 ldr r3,.L71+28
 1566 01da 1F4A     	 ldr r2,.L71+32
 1567 01dc 181C     	 mov r0,r3
 1568 01de 111C     	 mov r1,r2
 1569 01e0 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 328:../main.c     **** 		delay_ms(200);
 1570              	 .loc 5 328 0
 1571 01e4 C820     	 mov r0,#200
 1572 01e6 FFF7FEFF 	 bl delay_ms
 329:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 1573              	 .loc 5 329 0
 1574 01ea 1A4B     	 ldr r3,.L71+28
 1575 01ec 181C     	 mov r0,r3
 1576 01ee 0021     	 mov r1,#0
 1577 01f0 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 330:../main.c     **** 		delay_ms(150);
 1578              	 .loc 5 330 0
 1579 01f4 9620     	 mov r0,#150
 1580 01f6 FFF7FEFF 	 bl delay_ms
 331:../main.c     **** 		PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 1581              	 .loc 5 331 0
 1582 01fa 164B     	 ldr r3,.L71+28
 1583 01fc 164A     	 ldr r2,.L71+32
 1584 01fe 181C     	 mov r0,r3
 1585 0200 111C     	 mov r1,r2
 1586 0202 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 1587 0206 03E0     	 b .L67
 1588              	.L66:
 332:../main.c     **** 	}
 333:../main.c     **** 	else{
 334:../main.c     **** 		relay_threshold_latchtime = eeprom_latchtime;
 1589              	 .loc 5 334 0
 1590 0208 0D4B     	 ldr r3,.L71+8
 1591 020a 1A68     	 ldr r2,[r3]
 1592 020c 154B     	 ldr r3,.L71+44
 1593 020e 1A60     	 str r2,[r3]
 1594              	.L67:
 335:../main.c     **** 	}
 336:../main.c     **** 	// Restore USB state from EEPROM or reset to USB1 on error
 337:../main.c     **** 	if(eeprom_usb_state < 0 || eeprom_usb_state > USB_inactive)
 1595              	 .loc 5 337 0
 1596 0210 0C4B     	 ldr r3,.L71+12
 1597 0212 1B68     	 ldr r3,[r3]
 1598 0214 002B     	 cmp r3,#0
 1599 0216 03DB     	 blt .L68
 1600              	 .loc 5 337 0 is_stmt 0 discriminator 1
 1601 0218 0A4B     	 ldr r3,.L71+12
 1602 021a 1B68     	 ldr r3,[r3]
 1603 021c 022B     	 cmp r3,#2
 1604 021e 03DD     	 ble .L69
 1605              	.L68:
 338:../main.c     **** 		USB_state = USB_1_active;
 1606              	 .loc 5 338 0 is_stmt 1
 1607 0220 114B     	 ldr r3,.L71+48
 1608 0222 0022     	 mov r2,#0
 1609 0224 1A70     	 strb r2,[r3]
 1610 0226 04E0     	 b .L58
 1611              	.L69:
 339:../main.c     **** 	else
 340:../main.c     **** 		USB_state = (USB_states)eeprom_usb_state;
 1612              	 .loc 5 340 0
 1613 0228 064B     	 ldr r3,.L71+12
 1614 022a 1B68     	 ldr r3,[r3]
 1615 022c DAB2     	 uxtb r2,r3
 1616 022e 0E4B     	 ldr r3,.L71+48
 1617 0230 1A70     	 strb r2,[r3]
 1618              	.L58:
 341:../main.c     **** 
 342:../main.c     **** 	//     --    Use this to write a value to e_eeprom for debug purpose   --
 343:../main.c     **** 	//int32_t temp = 100001;
 344:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp;
 345:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp >> 8);
 346:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(temp >> 16);
 347:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(temp >> 24);
 348:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_LOWER_TH, EEPROM_WriteBuffer);
 349:../main.c     **** 	//
 350:../main.c     **** 	//temp = 100002;
 351:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp;
 352:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp >> 8);
 353:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(temp >> 16);
 354:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(temp >> 24);
 355:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_UPPER_TH, EEPROM_WriteBuffer);
 356:../main.c     **** 	//
 357:../main.c     **** 	//temp = 100002;
 358:../main.c     **** 	//EEPROM_WriteBuffer[0] = (uint8_t)temp;
 359:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(temp >> 8);
 360:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(temp >> 16);
 361:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(temp >> 24);
 362:../main.c     **** 	//E_EEPROM_XMC1_Write(EEPROM_LATCHTIME, EEPROM_WriteBuffer);
 363:../main.c     **** }
 1619              	 .loc 5 363 0
 1620 0232 BD46     	 mov sp,r7
 1621 0234 04B0     	 add sp,sp,#16
 1622              	 
 1623 0236 80BD     	 pop {r7,pc}
 1624              	.L72:
 1625              	 .align 2
 1626              	.L71:
 1627 0238 00000000 	 .word eeprom_lower
 1628 023c 00000000 	 .word eeprom_upper
 1629 0240 00000000 	 .word eeprom_latchtime
 1630 0244 00000000 	 .word eeprom_usb_state
 1631 0248 FF0F0000 	 .word 4095
 1632 024c 00000000 	 .word ADC_upper_threshold
 1633 0250 B60D0000 	 .word 3510
 1634 0254 00000000 	 .word PWM_CCU4_LED_STATUS
 1635 0258 10270000 	 .word 10000
 1636 025c 00000000 	 .word ADC_lower_threshold
 1637 0260 49020000 	 .word 585
 1638 0264 00000000 	 .word relay_threshold_latchtime
 1639 0268 00000000 	 .word USB_state
 1640              	 .cfi_endproc
 1641              	.LFE163:
 1643              	 .section .text.write_eeprom,"ax",%progbits
 1644              	 .align 2
 1645              	 .global write_eeprom
 1646              	 .code 16
 1647              	 .thumb_func
 1649              	write_eeprom:
 1650              	.LFB164:
 364:../main.c     **** 
 365:../main.c     **** //****************************************************************************
 366:../main.c     **** // write_eeprom - writes up to 4 byte to a given EEPROM block
 367:../main.c     **** //****************************************************************************
 368:../main.c     **** void write_eeprom(uint8_t block_number, int32_t value, uint8_t size){
 1651              	 .loc 5 368 0
 1652              	 .cfi_startproc
 1653 0000 80B5     	 push {r7,lr}
 1654              	.LCFI36:
 1655              	 .cfi_def_cfa_offset 8
 1656              	 .cfi_offset 7,-8
 1657              	 .cfi_offset 14,-4
 1658 0002 84B0     	 sub sp,sp,#16
 1659              	.LCFI37:
 1660              	 .cfi_def_cfa_offset 24
 1661 0004 00AF     	 add r7,sp,#0
 1662              	.LCFI38:
 1663              	 .cfi_def_cfa_register 7
 1664 0006 3960     	 str r1,[r7]
 1665 0008 111C     	 mov r1,r2
 1666 000a FB1D     	 add r3,r7,#7
 1667 000c 021C     	 add r2,r0,#0
 1668 000e 1A70     	 strb r2,[r3]
 1669 0010 BB1D     	 add r3,r7,#6
 1670 0012 0A1C     	 add r2,r1,#0
 1671 0014 1A70     	 strb r2,[r3]
 369:../main.c     **** 	uint8_t EEPROM_WriteBuffer[4];
 370:../main.c     **** 
 371:../main.c     **** 	EEPROM_WriteBuffer[0] = (uint8_t)value;
 1672              	 .loc 5 371 0
 1673 0016 3B68     	 ldr r3,[r7]
 1674 0018 DAB2     	 uxtb r2,r3
 1675 001a 0823     	 mov r3,#8
 1676 001c FB18     	 add r3,r7,r3
 1677 001e 1A70     	 strb r2,[r3]
 1678              	.LBB3:
 372:../main.c     **** 	for(int i = 1; i < size; i++){
 1679              	 .loc 5 372 0
 1680 0020 0123     	 mov r3,#1
 1681 0022 FB60     	 str r3,[r7,#12]
 1682 0024 0EE0     	 b .L74
 1683              	.L75:
 373:../main.c     **** 		EEPROM_WriteBuffer[i] = (uint8_t)(value >> (i*8));
 1684              	 .loc 5 373 0 discriminator 3
 1685 0026 FB68     	 ldr r3,[r7,#12]
 1686 0028 DB00     	 lsl r3,r3,#3
 1687 002a 3A68     	 ldr r2,[r7]
 1688 002c 1A41     	 asr r2,r2,r3
 1689 002e 131C     	 mov r3,r2
 1690 0030 D9B2     	 uxtb r1,r3
 1691 0032 0823     	 mov r3,#8
 1692 0034 FA18     	 add r2,r7,r3
 1693 0036 FB68     	 ldr r3,[r7,#12]
 1694 0038 D318     	 add r3,r2,r3
 1695 003a 0A1C     	 add r2,r1,#0
 1696 003c 1A70     	 strb r2,[r3]
 372:../main.c     **** 	for(int i = 1; i < size; i++){
 1697              	 .loc 5 372 0 discriminator 3
 1698 003e FB68     	 ldr r3,[r7,#12]
 1699 0040 0133     	 add r3,r3,#1
 1700 0042 FB60     	 str r3,[r7,#12]
 1701              	.L74:
 372:../main.c     **** 	for(int i = 1; i < size; i++){
 1702              	 .loc 5 372 0 is_stmt 0 discriminator 1
 1703 0044 BB1D     	 add r3,r7,#6
 1704 0046 1A78     	 ldrb r2,[r3]
 1705 0048 FB68     	 ldr r3,[r7,#12]
 1706 004a 9A42     	 cmp r2,r3
 1707 004c EBDC     	 bgt .L75
 1708              	.LBE3:
 374:../main.c     **** 	}
 375:../main.c     **** 	E_EEPROM_XMC1_Write(block_number, EEPROM_WriteBuffer);
 1709              	 .loc 5 375 0 is_stmt 1
 1710 004e FB1D     	 add r3,r7,#7
 1711 0050 1A78     	 ldrb r2,[r3]
 1712 0052 0823     	 mov r3,#8
 1713 0054 FB18     	 add r3,r7,r3
 1714 0056 101C     	 mov r0,r2
 1715 0058 191C     	 mov r1,r3
 1716 005a FFF7FEFF 	 bl E_EEPROM_XMC1_Write
 376:../main.c     **** 
 377:../main.c     **** 	//EEPROM_WriteBuffer[1] = (uint8_t)(value >> 8);
 378:../main.c     **** 	//EEPROM_WriteBuffer[2] = (uint8_t)(value >> 16);
 379:../main.c     **** 	//EEPROM_WriteBuffer[3] = (uint8_t)(value >> 24);
 380:../main.c     **** }
 1717              	 .loc 5 380 0
 1718 005e BD46     	 mov sp,r7
 1719 0060 04B0     	 add sp,sp,#16
 1720              	 
 1721 0062 80BD     	 pop {r7,pc}
 1722              	 .cfi_endproc
 1723              	.LFE164:
 1725              	 .section .text.manage_buttons,"ax",%progbits
 1726              	 .align 2
 1727              	 .global manage_buttons
 1728              	 .code 16
 1729              	 .thumb_func
 1731              	manage_buttons:
 1732              	.LFB165:
 381:../main.c     **** 
 382:../main.c     **** //****************************************************************************
 383:../main.c     **** // manage_buttons - function to manage, debounce and interpret button presses
 384:../main.c     **** //****************************************************************************
 385:../main.c     **** void manage_buttons(void)
 386:../main.c     **** {
 1733              	 .loc 5 386 0
 1734              	 .cfi_startproc
 1735 0000 80B5     	 push {r7,lr}
 1736              	.LCFI39:
 1737              	 .cfi_def_cfa_offset 8
 1738              	 .cfi_offset 7,-8
 1739              	 .cfi_offset 14,-4
 1740 0002 00AF     	 add r7,sp,#0
 1741              	.LCFI40:
 1742              	 .cfi_def_cfa_register 7
 387:../main.c     **** 	/// Detect start of press and save current system time
 388:../main.c     **** 	if(button_usb_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_ON)
 1743              	 .loc 5 388 0
 1744 0004 8F4B     	 ldr r3,.L95
 1745 0006 1B68     	 ldr r3,[r3]
 1746 0008 002B     	 cmp r3,#0
 1747 000a 0AD1     	 bne .L77
 1748              	 .loc 5 388 0 is_stmt 0 discriminator 1
 1749 000c 8E4B     	 ldr r3,.L95+4
 1750 000e 181C     	 mov r0,r3
 1751 0010 FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1752 0014 031E     	 sub r3,r0,#0
 1753 0016 04D1     	 bne .L77
 389:../main.c     **** 		button_usb_pressed_timestamp = SYSTIMER_GetTime();
 1754              	 .loc 5 389 0 is_stmt 1
 1755 0018 FFF7FEFF 	 bl SYSTIMER_GetTime
 1756 001c 021C     	 mov r2,r0
 1757 001e 894B     	 ldr r3,.L95
 1758 0020 1A60     	 str r2,[r3]
 1759              	.L77:
 390:../main.c     **** 	if(button_up_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_ON)
 1760              	 .loc 5 390 0
 1761 0022 8A4B     	 ldr r3,.L95+8
 1762 0024 1B68     	 ldr r3,[r3]
 1763 0026 002B     	 cmp r3,#0
 1764 0028 0AD1     	 bne .L78
 1765              	 .loc 5 390 0 is_stmt 0 discriminator 1
 1766 002a 894B     	 ldr r3,.L95+12
 1767 002c 181C     	 mov r0,r3
 1768 002e FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1769 0032 031E     	 sub r3,r0,#0
 1770 0034 04D1     	 bne .L78
 391:../main.c     **** 		button_up_pressed_timestamp = SYSTIMER_GetTime();
 1771              	 .loc 5 391 0 is_stmt 1
 1772 0036 FFF7FEFF 	 bl SYSTIMER_GetTime
 1773 003a 021C     	 mov r2,r0
 1774 003c 834B     	 ldr r3,.L95+8
 1775 003e 1A60     	 str r2,[r3]
 1776              	.L78:
 392:../main.c     **** 	if(button_down_pressed_timestamp == 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_ON)
 1777              	 .loc 5 392 0
 1778 0040 844B     	 ldr r3,.L95+16
 1779 0042 1B68     	 ldr r3,[r3]
 1780 0044 002B     	 cmp r3,#0
 1781 0046 0AD1     	 bne .L79
 1782              	 .loc 5 392 0 is_stmt 0 discriminator 1
 1783 0048 834B     	 ldr r3,.L95+20
 1784 004a 181C     	 mov r0,r3
 1785 004c FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1786 0050 031E     	 sub r3,r0,#0
 1787 0052 04D1     	 bne .L79
 393:../main.c     **** 		button_down_pressed_timestamp = SYSTIMER_GetTime();
 1788              	 .loc 5 393 0 is_stmt 1
 1789 0054 FFF7FEFF 	 bl SYSTIMER_GetTime
 1790 0058 021C     	 mov r2,r0
 1791 005a 7E4B     	 ldr r3,.L95+16
 1792 005c 1A60     	 str r2,[r3]
 1793              	.L79:
 394:../main.c     **** 
 395:../main.c     **** 	// USB BUTTON: If a press in ongoing and release is detected, calculate time difference
 396:../main.c     **** 	if(button_usb_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_USB) == SW_OFF){
 1794              	 .loc 5 396 0
 1795 005e 794B     	 ldr r3,.L95
 1796 0060 1B68     	 ldr r3,[r3]
 1797 0062 002B     	 cmp r3,#0
 1798 0064 33D0     	 beq .L80
 1799              	 .loc 5 396 0 is_stmt 0 discriminator 1
 1800 0066 784B     	 ldr r3,.L95+4
 1801 0068 181C     	 mov r0,r3
 1802 006a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1803 006e 031E     	 sub r3,r0,#0
 1804 0070 012B     	 cmp r3,#1
 1805 0072 2CD1     	 bne .L80
 397:../main.c     **** 		button_usb_pressed_duration = (SYSTIMER_GetTime() - button_usb_pressed_timestamp) / 1000; // conv
 1806              	 .loc 5 397 0 is_stmt 1
 1807 0074 FFF7FEFF 	 bl SYSTIMER_GetTime
 1808 0078 021C     	 mov r2,r0
 1809 007a 724B     	 ldr r3,.L95
 1810 007c 1B68     	 ldr r3,[r3]
 1811 007e D31A     	 sub r3,r2,r3
 1812 0080 181C     	 mov r0,r3
 1813 0082 FA23     	 mov r3,#250
 1814 0084 9900     	 lsl r1,r3,#2
 1815 0086 FFF7FEFF 	 bl __aeabi_uidiv
 1816 008a 031C     	 mov r3,r0
 1817 008c 9AB2     	 uxth r2,r3
 1818 008e 734B     	 ldr r3,.L95+24
 1819 0090 1A80     	 strh r2,[r3]
 398:../main.c     **** 		button_usb_pressed_timestamp = 0;
 1820              	 .loc 5 398 0
 1821 0092 6C4B     	 ldr r3,.L95
 1822 0094 0022     	 mov r2,#0
 1823 0096 1A60     	 str r2,[r3]
 399:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 400:../main.c     **** 		if(button_usb_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1824              	 .loc 5 400 0
 1825 0098 704B     	 ldr r3,.L95+24
 1826 009a 1B88     	 ldrh r3,[r3]
 1827 009c 704A     	 ldr r2,.L95+28
 1828 009e 9342     	 cmp r3,r2
 1829 00a0 03D9     	 bls .L81
 401:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1830              	 .loc 5 401 0
 1831 00a2 704B     	 ldr r3,.L95+32
 1832 00a4 0022     	 mov r2,#0
 1833 00a6 1A70     	 strb r2,[r3]
 1834 00a8 10E0     	 b .L82
 1835              	.L81:
 402:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1836              	 .loc 5 402 0
 1837 00aa 6C4B     	 ldr r3,.L95+24
 1838 00ac 1B88     	 ldrh r3,[r3]
 1839 00ae 6E4A     	 ldr r2,.L95+36
 1840 00b0 9342     	 cmp r3,r2
 1841 00b2 03D9     	 bls .L83
 403:../main.c     **** 			buttonpress_usb = BTNPRESS_LONG;
 1842              	 .loc 5 403 0
 1843 00b4 6B4B     	 ldr r3,.L95+32
 1844 00b6 0222     	 mov r2,#2
 1845 00b8 1A70     	 strb r2,[r3]
 1846 00ba 07E0     	 b .L82
 1847              	.L83:
 404:../main.c     **** 		else if(button_usb_pressed_duration >= BTN_STD_PRESS_DURATION)
 1848              	 .loc 5 404 0
 1849 00bc 674B     	 ldr r3,.L95+24
 1850 00be 1B88     	 ldrh r3,[r3]
 1851 00c0 3B2B     	 cmp r3,#59
 1852 00c2 03D9     	 bls .L82
 405:../main.c     **** 			buttonpress_usb = BTNPRESS_STD;
 1853              	 .loc 5 405 0
 1854 00c4 674B     	 ldr r3,.L95+32
 1855 00c6 0122     	 mov r2,#1
 1856 00c8 1A70     	 strb r2,[r3]
 400:../main.c     **** 			buttonpress_usb = BTNPRESS_NOT; // In this case the press is already handled
 1857              	 .loc 5 400 0
 1858 00ca 18E0     	 b .L84
 1859              	.L82:
 1860 00cc 17E0     	 b .L84
 1861              	.L80:
 406:../main.c     **** 	}
 407:../main.c     **** 	// USB BUTTON: If press is to long reset (simulate that press ended)
 408:../main.c     **** 	else if(button_usb_pressed_timestamp != 0 && button_usb_pressed_timestamp != TIMESTAMP_DEACTIVATED
 1862              	 .loc 5 408 0
 1863 00ce 5D4B     	 ldr r3,.L95
 1864 00d0 1B68     	 ldr r3,[r3]
 1865 00d2 002B     	 cmp r3,#0
 1866 00d4 13D0     	 beq .L84
 1867              	 .loc 5 408 0 is_stmt 0 discriminator 1
 1868 00d6 5B4B     	 ldr r3,.L95
 1869 00d8 1B68     	 ldr r3,[r3]
 1870 00da 0133     	 add r3,r3,#1
 1871 00dc 0FD0     	 beq .L84
 1872              	 .loc 5 408 0 discriminator 2
 1873 00de FFF7FEFF 	 bl SYSTIMER_GetTime
 1874 00e2 021C     	 mov r2,r0
 1875 00e4 574B     	 ldr r3,.L95
 1876 00e6 1B68     	 ldr r3,[r3]
 1877 00e8 D31A     	 sub r3,r2,r3
 1878 00ea 604A     	 ldr r2,.L95+40
 1879 00ec 9342     	 cmp r3,r2
 1880 00ee 06D9     	 bls .L84
 409:../main.c     **** 		button_usb_pressed_timestamp = TIMESTAMP_DEACTIVATED; // deactivate timestamp till button is rele
 1881              	 .loc 5 409 0 is_stmt 1
 1882 00f0 544B     	 ldr r3,.L95
 1883 00f2 0122     	 mov r2,#1
 1884 00f4 5242     	 neg r2,r2
 1885 00f6 1A60     	 str r2,[r3]
 410:../main.c     **** 		buttonpress_usb = BTNPRESS_LONGEST;
 1886              	 .loc 5 410 0
 1887 00f8 5A4B     	 ldr r3,.L95+32
 1888 00fa 0322     	 mov r2,#3
 1889 00fc 1A70     	 strb r2,[r3]
 1890              	.L84:
 411:../main.c     **** 	}
 412:../main.c     **** 
 413:../main.c     **** 	// UP BUTTON: If a press in ongoing and release is detected, calculate time difference
 414:../main.c     **** 	if(button_up_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_UP) == SW_OFF){
 1891              	 .loc 5 414 0
 1892 00fe 534B     	 ldr r3,.L95+8
 1893 0100 1B68     	 ldr r3,[r3]
 1894 0102 002B     	 cmp r3,#0
 1895 0104 33D0     	 beq .L85
 1896              	 .loc 5 414 0 is_stmt 0 discriminator 1
 1897 0106 524B     	 ldr r3,.L95+12
 1898 0108 181C     	 mov r0,r3
 1899 010a FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1900 010e 031E     	 sub r3,r0,#0
 1901 0110 012B     	 cmp r3,#1
 1902 0112 2CD1     	 bne .L85
 415:../main.c     **** 		button_up_pressed_duration = (SYSTIMER_GetTime() - button_up_pressed_timestamp) / 1000; // conver
 1903              	 .loc 5 415 0 is_stmt 1
 1904 0114 FFF7FEFF 	 bl SYSTIMER_GetTime
 1905 0118 021C     	 mov r2,r0
 1906 011a 4C4B     	 ldr r3,.L95+8
 1907 011c 1B68     	 ldr r3,[r3]
 1908 011e D31A     	 sub r3,r2,r3
 1909 0120 181C     	 mov r0,r3
 1910 0122 FA23     	 mov r3,#250
 1911 0124 9900     	 lsl r1,r3,#2
 1912 0126 FFF7FEFF 	 bl __aeabi_uidiv
 1913 012a 031C     	 mov r3,r0
 1914 012c 9AB2     	 uxth r2,r3
 1915 012e 504B     	 ldr r3,.L95+44
 1916 0130 1A80     	 strh r2,[r3]
 416:../main.c     **** 		button_up_pressed_timestamp = 0;
 1917              	 .loc 5 416 0
 1918 0132 464B     	 ldr r3,.L95+8
 1919 0134 0022     	 mov r2,#0
 1920 0136 1A60     	 str r2,[r3]
 417:../main.c     **** 		// Interpret button press and activate "button pressed" marker
 418:../main.c     **** 		if(button_up_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 1921              	 .loc 5 418 0
 1922 0138 4D4B     	 ldr r3,.L95+44
 1923 013a 1B88     	 ldrh r3,[r3]
 1924 013c 484A     	 ldr r2,.L95+28
 1925 013e 9342     	 cmp r3,r2
 1926 0140 03D9     	 bls .L86
 419:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1927              	 .loc 5 419 0
 1928 0142 4C4B     	 ldr r3,.L95+48
 1929 0144 0022     	 mov r2,#0
 1930 0146 1A70     	 strb r2,[r3]
 1931 0148 10E0     	 b .L87
 1932              	.L86:
 420:../main.c     **** 		else if(button_up_pressed_duration >= BTN_LONG_PRESS_DURATION)
 1933              	 .loc 5 420 0
 1934 014a 494B     	 ldr r3,.L95+44
 1935 014c 1B88     	 ldrh r3,[r3]
 1936 014e 464A     	 ldr r2,.L95+36
 1937 0150 9342     	 cmp r3,r2
 1938 0152 03D9     	 bls .L88
 421:../main.c     **** 			buttonpress_up = BTNPRESS_LONG;
 1939              	 .loc 5 421 0
 1940 0154 474B     	 ldr r3,.L95+48
 1941 0156 0222     	 mov r2,#2
 1942 0158 1A70     	 strb r2,[r3]
 1943 015a 07E0     	 b .L87
 1944              	.L88:
 422:../main.c     **** 		else if(button_up_pressed_duration >= BTN_STD_PRESS_DURATION)
 1945              	 .loc 5 422 0
 1946 015c 444B     	 ldr r3,.L95+44
 1947 015e 1B88     	 ldrh r3,[r3]
 1948 0160 3B2B     	 cmp r3,#59
 1949 0162 03D9     	 bls .L87
 423:../main.c     **** 			buttonpress_up = BTNPRESS_STD;
 1950              	 .loc 5 423 0
 1951 0164 434B     	 ldr r3,.L95+48
 1952 0166 0122     	 mov r2,#1
 1953 0168 1A70     	 strb r2,[r3]
 418:../main.c     **** 			buttonpress_up = BTNPRESS_NOT; // In this case the press is already handled
 1954              	 .loc 5 418 0
 1955 016a 18E0     	 b .L89
 1956              	.L87:
 1957 016c 17E0     	 b .L89
 1958              	.L85:
 424:../main.c     **** 
 425:../main.c     **** 	}
 426:../main.c     **** 	// UP BUTTON: If press is to long reset (simulate that press ended)
 427:../main.c     **** 	else if(button_up_pressed_timestamp != 0 && button_up_pressed_timestamp != TIMESTAMP_DEACTIVATED &
 1959              	 .loc 5 427 0
 1960 016e 374B     	 ldr r3,.L95+8
 1961 0170 1B68     	 ldr r3,[r3]
 1962 0172 002B     	 cmp r3,#0
 1963 0174 13D0     	 beq .L89
 1964              	 .loc 5 427 0 is_stmt 0 discriminator 1
 1965 0176 354B     	 ldr r3,.L95+8
 1966 0178 1B68     	 ldr r3,[r3]
 1967 017a 0133     	 add r3,r3,#1
 1968 017c 0FD0     	 beq .L89
 1969              	 .loc 5 427 0 discriminator 2
 1970 017e FFF7FEFF 	 bl SYSTIMER_GetTime
 1971 0182 021C     	 mov r2,r0
 1972 0184 314B     	 ldr r3,.L95+8
 1973 0186 1B68     	 ldr r3,[r3]
 1974 0188 D31A     	 sub r3,r2,r3
 1975 018a 384A     	 ldr r2,.L95+40
 1976 018c 9342     	 cmp r3,r2
 1977 018e 06D9     	 bls .L89
 428:../main.c     **** 		button_up_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 1978              	 .loc 5 428 0 is_stmt 1
 1979 0190 2E4B     	 ldr r3,.L95+8
 1980 0192 0122     	 mov r2,#1
 1981 0194 5242     	 neg r2,r2
 1982 0196 1A60     	 str r2,[r3]
 429:../main.c     **** 		buttonpress_up = BTNPRESS_LONGEST;
 1983              	 .loc 5 429 0
 1984 0198 364B     	 ldr r3,.L95+48
 1985 019a 0322     	 mov r2,#3
 1986 019c 1A70     	 strb r2,[r3]
 1987              	.L89:
 430:../main.c     **** 	}
 431:../main.c     **** 
 432:../main.c     **** 	// DOWN BUTTON: If a press in ongoing and release is detected, calculate time difference
 433:../main.c     **** 	if(button_down_pressed_timestamp != 0 && DIGITAL_IO_GetInput(&IO_SW_DOWN) == SW_OFF){
 1988              	 .loc 5 433 0
 1989 019e 2D4B     	 ldr r3,.L95+16
 1990 01a0 1B68     	 ldr r3,[r3]
 1991 01a2 002B     	 cmp r3,#0
 1992 01a4 33D0     	 beq .L90
 1993              	 .loc 5 433 0 is_stmt 0 discriminator 1
 1994 01a6 2C4B     	 ldr r3,.L95+20
 1995 01a8 181C     	 mov r0,r3
 1996 01aa FFF7FEFF 	 bl DIGITAL_IO_GetInput
 1997 01ae 031E     	 sub r3,r0,#0
 1998 01b0 012B     	 cmp r3,#1
 1999 01b2 2CD1     	 bne .L90
 434:../main.c     **** 		button_down_pressed_duration = (SYSTIMER_GetTime() - button_down_pressed_timestamp) / 1000; // co
 2000              	 .loc 5 434 0 is_stmt 1
 2001 01b4 FFF7FEFF 	 bl SYSTIMER_GetTime
 2002 01b8 021C     	 mov r2,r0
 2003 01ba 264B     	 ldr r3,.L95+16
 2004 01bc 1B68     	 ldr r3,[r3]
 2005 01be D31A     	 sub r3,r2,r3
 2006 01c0 181C     	 mov r0,r3
 2007 01c2 FA23     	 mov r3,#250
 2008 01c4 9900     	 lsl r1,r3,#2
 2009 01c6 FFF7FEFF 	 bl __aeabi_uidiv
 2010 01ca 031C     	 mov r3,r0
 2011 01cc 9AB2     	 uxth r2,r3
 2012 01ce 2A4B     	 ldr r3,.L95+52
 2013 01d0 1A80     	 strh r2,[r3]
 435:../main.c     **** 		button_down_pressed_timestamp = 0;
 2014              	 .loc 5 435 0
 2015 01d2 204B     	 ldr r3,.L95+16
 2016 01d4 0022     	 mov r2,#0
 2017 01d6 1A60     	 str r2,[r3]
 436:../main.c     **** 		// Interpret button press and activate "button pressed" marker. The code that is reacting to it m
 437:../main.c     **** 		if(button_down_pressed_duration >= BTN_LONGEST_PRESS_DURATION)
 2018              	 .loc 5 437 0
 2019 01d8 274B     	 ldr r3,.L95+52
 2020 01da 1B88     	 ldrh r3,[r3]
 2021 01dc 204A     	 ldr r2,.L95+28
 2022 01de 9342     	 cmp r3,r2
 2023 01e0 03D9     	 bls .L91
 438:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 2024              	 .loc 5 438 0
 2025 01e2 264B     	 ldr r3,.L95+56
 2026 01e4 0022     	 mov r2,#0
 2027 01e6 1A70     	 strb r2,[r3]
 2028 01e8 10E0     	 b .L92
 2029              	.L91:
 439:../main.c     **** 		else if(button_down_pressed_duration >= BTN_LONG_PRESS_DURATION)
 2030              	 .loc 5 439 0
 2031 01ea 234B     	 ldr r3,.L95+52
 2032 01ec 1B88     	 ldrh r3,[r3]
 2033 01ee 1E4A     	 ldr r2,.L95+36
 2034 01f0 9342     	 cmp r3,r2
 2035 01f2 03D9     	 bls .L93
 440:../main.c     **** 			buttonpress_down = BTNPRESS_LONG;
 2036              	 .loc 5 440 0
 2037 01f4 214B     	 ldr r3,.L95+56
 2038 01f6 0222     	 mov r2,#2
 2039 01f8 1A70     	 strb r2,[r3]
 2040 01fa 07E0     	 b .L92
 2041              	.L93:
 441:../main.c     **** 		else if(button_down_pressed_duration >= BTN_STD_PRESS_DURATION)
 2042              	 .loc 5 441 0
 2043 01fc 1E4B     	 ldr r3,.L95+52
 2044 01fe 1B88     	 ldrh r3,[r3]
 2045 0200 3B2B     	 cmp r3,#59
 2046 0202 03D9     	 bls .L92
 442:../main.c     **** 			buttonpress_down = BTNPRESS_STD;
 2047              	 .loc 5 442 0
 2048 0204 1D4B     	 ldr r3,.L95+56
 2049 0206 0122     	 mov r2,#1
 2050 0208 1A70     	 strb r2,[r3]
 437:../main.c     **** 			buttonpress_down = BTNPRESS_NOT; // In this case the press is already handled
 2051              	 .loc 5 437 0
 2052 020a 18E0     	 b .L76
 2053              	.L92:
 2054 020c 17E0     	 b .L76
 2055              	.L90:
 443:../main.c     **** 	}
 444:../main.c     **** 	// DOWN BUTTON: If press is to long reset (simulate that press ended)
 445:../main.c     **** 	else if(button_down_pressed_timestamp != 0 && button_down_pressed_timestamp != TIMESTAMP_DEACTIVAT
 2056              	 .loc 5 445 0
 2057 020e 114B     	 ldr r3,.L95+16
 2058 0210 1B68     	 ldr r3,[r3]
 2059 0212 002B     	 cmp r3,#0
 2060 0214 13D0     	 beq .L76
 2061              	 .loc 5 445 0 is_stmt 0 discriminator 1
 2062 0216 0F4B     	 ldr r3,.L95+16
 2063 0218 1B68     	 ldr r3,[r3]
 2064 021a 0133     	 add r3,r3,#1
 2065 021c 0FD0     	 beq .L76
 2066              	 .loc 5 445 0 discriminator 2
 2067 021e FFF7FEFF 	 bl SYSTIMER_GetTime
 2068 0222 021C     	 mov r2,r0
 2069 0224 0B4B     	 ldr r3,.L95+16
 2070 0226 1B68     	 ldr r3,[r3]
 2071 0228 D31A     	 sub r3,r2,r3
 2072 022a 104A     	 ldr r2,.L95+40
 2073 022c 9342     	 cmp r3,r2
 2074 022e 06D9     	 bls .L76
 446:../main.c     **** 		button_down_pressed_timestamp = TIMESTAMP_DEACTIVATED;
 2075              	 .loc 5 446 0 is_stmt 1
 2076 0230 084B     	 ldr r3,.L95+16
 2077 0232 0122     	 mov r2,#1
 2078 0234 5242     	 neg r2,r2
 2079 0236 1A60     	 str r2,[r3]
 447:../main.c     **** 		buttonpress_down = BTNPRESS_LONGEST;
 2080              	 .loc 5 447 0
 2081 0238 104B     	 ldr r3,.L95+56
 2082 023a 0322     	 mov r2,#3
 2083 023c 1A70     	 strb r2,[r3]
 2084              	.L76:
 448:../main.c     **** 	}
 449:../main.c     **** }
 2085              	 .loc 5 449 0
 2086 023e BD46     	 mov sp,r7
 2087              	 
 2088 0240 80BD     	 pop {r7,pc}
 2089              	.L96:
 2090 0242 C046     	 .align 2
 2091              	.L95:
 2092 0244 00000000 	 .word button_usb_pressed_timestamp
 2093 0248 00000000 	 .word IO_SW_USB
 2094 024c 00000000 	 .word button_up_pressed_timestamp
 2095 0250 00000000 	 .word IO_SW_UP
 2096 0254 00000000 	 .word button_down_pressed_timestamp
 2097 0258 00000000 	 .word IO_SW_DOWN
 2098 025c 00000000 	 .word button_usb_pressed_duration
 2099 0260 9F0F0000 	 .word 3999
 2100 0264 00000000 	 .word buttonpress_usb
 2101 0268 E7030000 	 .word 999
 2102 026c E70C3D00 	 .word 4000999
 2103 0270 00000000 	 .word button_up_pressed_duration
 2104 0274 00000000 	 .word buttonpress_up
 2105 0278 00000000 	 .word button_down_pressed_duration
 2106 027c 00000000 	 .word buttonpress_down
 2107              	 .cfi_endproc
 2108              	.LFE165:
 2110              	 .section .text.switchUSB,"ax",%progbits
 2111              	 .align 2
 2112              	 .global switchUSB
 2113              	 .code 16
 2114              	 .thumb_func
 2116              	switchUSB:
 2117              	.LFB166:
 450:../main.c     **** 
 451:../main.c     **** //****************************************************************************
 452:../main.c     **** // switchUSB -
 453:../main.c     **** //****************************************************************************
 454:../main.c     **** int switchUSB(USB_states state)
 455:../main.c     **** {
 2118              	 .loc 5 455 0
 2119              	 .cfi_startproc
 2120 0000 80B5     	 push {r7,lr}
 2121              	.LCFI41:
 2122              	 .cfi_def_cfa_offset 8
 2123              	 .cfi_offset 7,-8
 2124              	 .cfi_offset 14,-4
 2125 0002 82B0     	 sub sp,sp,#8
 2126              	.LCFI42:
 2127              	 .cfi_def_cfa_offset 16
 2128 0004 00AF     	 add r7,sp,#0
 2129              	.LCFI43:
 2130              	 .cfi_def_cfa_register 7
 2131 0006 021C     	 mov r2,r0
 2132 0008 FB1D     	 add r3,r7,#7
 2133 000a 1A70     	 strb r2,[r3]
 456:../main.c     **** 	if(state == USB_1_active){
 2134              	 .loc 5 456 0
 2135 000c FB1D     	 add r3,r7,#7
 2136 000e 1B78     	 ldrb r3,[r3]
 2137 0010 002B     	 cmp r3,#0
 2138 0012 14D1     	 bne .L98
 457:../main.c     **** 		DIGITAL_IO_SetOutputLow(&IO_USBPWR_2);
 2139              	 .loc 5 457 0
 2140 0014 184B     	 ldr r3,.L100
 2141 0016 181C     	 mov r0,r3
 2142 0018 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 458:../main.c     **** 		DIGITAL_IO_SetOutputLow(&IO_USB_SI);
 2143              	 .loc 5 458 0
 2144 001c 174B     	 ldr r3,.L100+4
 2145 001e 181C     	 mov r0,r3
 2146 0020 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 459:../main.c     **** 		DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 2147              	 .loc 5 459 0
 2148 0024 164B     	 ldr r3,.L100+8
 2149 0026 181C     	 mov r0,r3
 2150 0028 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 460:../main.c     **** 		DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 2151              	 .loc 5 460 0
 2152 002c 154B     	 ldr r3,.L100+12
 2153 002e 181C     	 mov r0,r3
 2154 0030 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 461:../main.c     **** 		DIGITAL_IO_SetOutputHigh(&IO_USBPWR_1);
 2155              	 .loc 5 461 0
 2156 0034 144B     	 ldr r3,.L100+16
 2157 0036 181C     	 mov r0,r3
 2158 0038 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 2159 003c 17E0     	 b .L99
 2160              	.L98:
 462:../main.c     **** 	}
 463:../main.c     **** 	else if(state == USB_2_active){
 2161              	 .loc 5 463 0
 2162 003e FB1D     	 add r3,r7,#7
 2163 0040 1B78     	 ldrb r3,[r3]
 2164 0042 012B     	 cmp r3,#1
 2165 0044 13D1     	 bne .L99
 464:../main.c     **** 		DIGITAL_IO_SetOutputLow(&IO_USBPWR_1);
 2166              	 .loc 5 464 0
 2167 0046 104B     	 ldr r3,.L100+16
 2168 0048 181C     	 mov r0,r3
 2169 004a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 465:../main.c     **** 		DIGITAL_IO_SetOutputHigh(&IO_USB_SI);
 2170              	 .loc 5 465 0
 2171 004e 0B4B     	 ldr r3,.L100+4
 2172 0050 181C     	 mov r0,r3
 2173 0052 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 466:../main.c     **** 		DIGITAL_IO_SetOutputLow(&IO_LED_USB2);
 2174              	 .loc 5 466 0
 2175 0056 0B4B     	 ldr r3,.L100+12
 2176 0058 181C     	 mov r0,r3
 2177 005a FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 467:../main.c     **** 		DIGITAL_IO_SetOutputHigh(&IO_LED_USB1);
 2178              	 .loc 5 467 0
 2179 005e 084B     	 ldr r3,.L100+8
 2180 0060 181C     	 mov r0,r3
 2181 0062 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 468:../main.c     **** 		DIGITAL_IO_SetOutputHigh(&IO_USBPWR_2);
 2182              	 .loc 5 468 0
 2183 0066 044B     	 ldr r3,.L100
 2184 0068 181C     	 mov r0,r3
 2185 006a FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 2186              	.L99:
 469:../main.c     **** 	}
 470:../main.c     **** }
 2187              	 .loc 5 470 0
 2188 006e 181C     	 mov r0,r3
 2189 0070 BD46     	 mov sp,r7
 2190 0072 02B0     	 add sp,sp,#8
 2191              	 
 2192 0074 80BD     	 pop {r7,pc}
 2193              	.L101:
 2194 0076 C046     	 .align 2
 2195              	.L100:
 2196 0078 00000000 	 .word IO_USBPWR_2
 2197 007c 00000000 	 .word IO_USB_SI
 2198 0080 00000000 	 .word IO_LED_USB1
 2199 0084 00000000 	 .word IO_LED_USB2
 2200 0088 00000000 	 .word IO_USBPWR_1
 2201              	 .cfi_endproc
 2202              	.LFE166:
 2204              	 .section .text.main,"ax",%progbits
 2205              	 .align 2
 2206              	 .global main
 2207              	 .code 16
 2208              	 .thumb_func
 2210              	main:
 2211              	.LFB167:
 471:../main.c     **** 
 472:../main.c     **** 
 473:../main.c     **** //****************************************************************************
 474:../main.c     **** // main - primary loop function
 475:../main.c     **** //****************************************************************************
 476:../main.c     **** int main(void)
 477:../main.c     **** {
 2212              	 .loc 5 477 0
 2213              	 .cfi_startproc
 2214 0000 90B5     	 push {r4,r7,lr}
 2215              	.LCFI44:
 2216              	 .cfi_def_cfa_offset 12
 2217              	 .cfi_offset 4,-12
 2218              	 .cfi_offset 7,-8
 2219              	 .cfi_offset 14,-4
 2220 0002 85B0     	 sub sp,sp,#20
 2221              	.LCFI45:
 2222              	 .cfi_def_cfa_offset 32
 2223 0004 00AF     	 add r7,sp,#0
 2224              	.LCFI46:
 2225              	 .cfi_def_cfa_register 7
 478:../main.c     **** 	// Initialization of DAVE APPs
 479:../main.c     **** 	DAVE_STATUS_t status;
 480:../main.c     **** 	status = DAVE_Init();
 2226              	 .loc 5 480 0
 2227 0006 0B23     	 mov r3,#11
 2228 0008 FC18     	 add r4,r7,r3
 2229 000a FFF7FEFF 	 bl DAVE_Init
 2230 000e 031C     	 mov r3,r0
 2231 0010 2370     	 strb r3,[r4]
 481:../main.c     **** 
 482:../main.c     **** 	// Error routine
 483:../main.c     **** 	if (status != DAVE_STATUS_SUCCESS) {
 2232              	 .loc 5 483 0
 2233 0012 0B23     	 mov r3,#11
 2234 0014 FB18     	 add r3,r7,r3
 2235 0016 1B78     	 ldrb r3,[r3]
 2236 0018 002B     	 cmp r3,#0
 2237 001a 25D0     	 beq .L103
 2238              	.L104:
 484:../main.c     **** 		while(1U){
 485:../main.c     **** 			DIGITAL_IO_SetOutputLow(&IO_LED_USB1);
 2239              	 .loc 5 485 0 discriminator 1
 2240 001c C44B     	 ldr r3,.L154
 2241 001e 181C     	 mov r0,r3
 2242 0020 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 486:../main.c     **** 			DIGITAL_IO_SetOutputLow(&IO_LED_USB2);
 2243              	 .loc 5 486 0 discriminator 1
 2244 0024 C34B     	 ldr r3,.L154+4
 2245 0026 181C     	 mov r0,r3
 2246 0028 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 487:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_ON);
 2247              	 .loc 5 487 0 discriminator 1
 2248 002c C24B     	 ldr r3,.L154+8
 2249 002e 181C     	 mov r0,r3
 2250 0030 0021     	 mov r1,#0
 2251 0032 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 488:../main.c     **** 			delay_ms(500);
 2252              	 .loc 5 488 0 discriminator 1
 2253 0036 FA23     	 mov r3,#250
 2254 0038 5B00     	 lsl r3,r3,#1
 2255 003a 181C     	 mov r0,r3
 2256 003c FFF7FEFF 	 bl delay_ms
 489:../main.c     **** 			DIGITAL_IO_SetOutputHigh(&IO_LED_USB1);
 2257              	 .loc 5 489 0 discriminator 1
 2258 0040 BB4B     	 ldr r3,.L154
 2259 0042 181C     	 mov r0,r3
 2260 0044 FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 490:../main.c     **** 			DIGITAL_IO_SetOutputHigh(&IO_LED_USB2);
 2261              	 .loc 5 490 0 discriminator 1
 2262 0048 BA4B     	 ldr r3,.L154+4
 2263 004a 181C     	 mov r0,r3
 2264 004c FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 491:../main.c     **** 			PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 2265              	 .loc 5 491 0 discriminator 1
 2266 0050 B94B     	 ldr r3,.L154+8
 2267 0052 BA4A     	 ldr r2,.L154+12
 2268 0054 181C     	 mov r0,r3
 2269 0056 111C     	 mov r1,r2
 2270 0058 FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 492:../main.c     **** 			delay_ms(500);
 2271              	 .loc 5 492 0 discriminator 1
 2272 005c FA23     	 mov r3,#250
 2273 005e 5B00     	 lsl r3,r3,#1
 2274 0060 181C     	 mov r0,r3
 2275 0062 FFF7FEFF 	 bl delay_ms
 493:../main.c     **** 		}
 2276              	 .loc 5 493 0 discriminator 1
 2277 0066 D9E7     	 b .L104
 2278              	.L103:
 494:../main.c     **** 	}
 495:../main.c     **** 
 496:../main.c     **** 	/// - Read setup from emulated EEPROM
 497:../main.c     **** 	read_eeprom_setup();
 2279              	 .loc 5 497 0
 2280 0068 FFF7FEFF 	 bl read_eeprom_setup
 498:../main.c     **** 
 499:../main.c     **** 	/// - Set initial state -
 500:../main.c     **** 	// Enable USB chip and switch to USB1, disable USB2
 501:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_USB_OE);
 2281              	 .loc 5 501 0
 2282 006c B44B     	 ldr r3,.L154+16
 2283 006e 181C     	 mov r0,r3
 2284 0070 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 502:../main.c     **** 	switchUSB(USB_state);
 2285              	 .loc 5 502 0
 2286 0074 B34B     	 ldr r3,.L154+20
 2287 0076 1B78     	 ldrb r3,[r3]
 2288 0078 181C     	 mov r0,r3
 2289 007a FFF7FEFF 	 bl switchUSB
 503:../main.c     **** 	// Disable Relay and set LED off
 504:../main.c     **** 	DIGITAL_IO_SetOutputLow(&IO_RELAY);
 2290              	 .loc 5 504 0
 2291 007e B24B     	 ldr r3,.L154+24
 2292 0080 181C     	 mov r0,r3
 2293 0082 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 505:../main.c     **** 	PWM_CCU4_SetDutyCycle(&PWM_CCU4_LED_STATUS, PWM_FULL_OFF);
 2294              	 .loc 5 505 0
 2295 0086 AC4B     	 ldr r3,.L154+8
 2296 0088 AC4A     	 ldr r2,.L154+12
 2297 008a 181C     	 mov r0,r3
 2298 008c 111C     	 mov r1,r2
 2299 008e FFF7FEFF 	 bl PWM_CCU4_SetDutyCycle
 506:../main.c     **** 	// Initialize next value conversion
 507:../main.c     **** 	ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 2300              	 .loc 5 507 0
 2301 0092 AE4B     	 ldr r3,.L154+28
 2302 0094 181C     	 mov r0,r3
 2303 0096 FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 508:../main.c     **** 
 509:../main.c     **** 	int main_loop_count = 0;
 2304              	 .loc 5 509 0
 2305 009a 0023     	 mov r3,#0
 2306 009c FB60     	 str r3,[r7,#12]
 2307              	.L150:
 510:../main.c     **** 
 511:../main.c     **** 	// Main loop
 512:../main.c     **** 	while(1U)
 513:../main.c     **** 	{
 514:../main.c     **** 		// - Status LED handling -
 515:../main.c     **** 		manage_status_led();
 2308              	 .loc 5 515 0
 2309 009e FFF7FEFF 	 bl manage_status_led
 516:../main.c     **** 		main_loop_count++;
 2310              	 .loc 5 516 0
 2311 00a2 FB68     	 ldr r3,[r7,#12]
 2312 00a4 0133     	 add r3,r3,#1
 2313 00a6 FB60     	 str r3,[r7,#12]
 517:../main.c     **** 		systime_debug = SYSTIMER_GetTime();
 2314              	 .loc 5 517 0
 2315 00a8 FFF7FEFF 	 bl SYSTIMER_GetTime
 2316 00ac 031C     	 mov r3,r0
 2317 00ae 1A1C     	 mov r2,r3
 2318 00b0 A74B     	 ldr r3,.L154+32
 2319 00b2 1A60     	 str r2,[r3]
 518:../main.c     **** 
 519:../main.c     **** 		//// - Button handling -
 520:../main.c     **** 		manage_buttons();
 2320              	 .loc 5 520 0
 2321 00b4 FFF7FEFF 	 bl manage_buttons
 521:../main.c     **** 
 522:../main.c     **** 		/// - USB Channel handling -
 523:../main.c     **** 		// Save state of USB if necessary (Enabled and timeout since state change happened)
 524:../main.c     **** 		if(usb_changed_timestamp != 0 && ((SYSTIMER_GetTime() - usb_changed_timestamp)/1000) > USB_STORE_
 2322              	 .loc 5 524 0
 2323 00b8 A64B     	 ldr r3,.L154+36
 2324 00ba 1B68     	 ldr r3,[r3]
 2325 00bc 002B     	 cmp r3,#0
 2326 00be 12D0     	 beq .L105
 2327              	 .loc 5 524 0 is_stmt 0 discriminator 1
 2328 00c0 FFF7FEFF 	 bl SYSTIMER_GetTime
 2329 00c4 021C     	 mov r2,r0
 2330 00c6 A34B     	 ldr r3,.L154+36
 2331 00c8 1B68     	 ldr r3,[r3]
 2332 00ca D31A     	 sub r3,r2,r3
 2333 00cc A24A     	 ldr r2,.L154+40
 2334 00ce 9342     	 cmp r3,r2
 2335 00d0 09D9     	 bls .L105
 525:../main.c     **** 			usb_changed_timestamp = 0;
 2336              	 .loc 5 525 0 is_stmt 1
 2337 00d2 A04B     	 ldr r3,.L154+36
 2338 00d4 0022     	 mov r2,#0
 2339 00d6 1A60     	 str r2,[r3]
 526:../main.c     **** 			if(USB_STORE_STATE_EEPROM)
 527:../main.c     **** 				write_eeprom(EEPROM_USB_STATE, (uint32_t)USB_state, 4);
 2340              	 .loc 5 527 0
 2341 00d8 9A4B     	 ldr r3,.L154+20
 2342 00da 1B78     	 ldrb r3,[r3]
 2343 00dc 0420     	 mov r0,#4
 2344 00de 191C     	 mov r1,r3
 2345 00e0 0422     	 mov r2,#4
 2346 00e2 FFF7FEFF 	 bl write_eeprom
 2347              	.L105:
 528:../main.c     **** 		}
 529:../main.c     **** 		// USB state machine
 530:../main.c     **** 		switch (USB_state){
 2348              	 .loc 5 530 0
 2349 00e6 974B     	 ldr r3,.L154+20
 2350 00e8 1B78     	 ldrb r3,[r3]
 2351 00ea 012B     	 cmp r3,#1
 2352 00ec 19D0     	 beq .L107
 2353 00ee 022B     	 cmp r3,#2
 2354 00f0 2DD0     	 beq .L151
 2355 00f2 002B     	 cmp r3,#0
 2356 00f4 2CD1     	 bne .L106
 531:../main.c     **** 			case USB_1_active:
 532:../main.c     **** 				// State code - none atm
 533:../main.c     **** 
 534:../main.c     **** 				// Transition statement
 535:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 2357              	 .loc 5 535 0
 2358 00f6 994B     	 ldr r3,.L154+44
 2359 00f8 1B78     	 ldrb r3,[r3]
 2360 00fa 012B     	 cmp r3,#1
 2361 00fc 10D1     	 bne .L110
 536:../main.c     **** 					USB_state = USB_2_active;
 2362              	 .loc 5 536 0
 2363 00fe 914B     	 ldr r3,.L154+20
 2364 0100 0122     	 mov r2,#1
 2365 0102 1A70     	 strb r2,[r3]
 537:../main.c     **** 					switchUSB(USB_state);
 2366              	 .loc 5 537 0
 2367 0104 8F4B     	 ldr r3,.L154+20
 2368 0106 1B78     	 ldrb r3,[r3]
 2369 0108 181C     	 mov r0,r3
 2370 010a FFF7FEFF 	 bl switchUSB
 538:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 2371              	 .loc 5 538 0
 2372 010e 934B     	 ldr r3,.L154+44
 2373 0110 0022     	 mov r2,#0
 2374 0112 1A70     	 strb r2,[r3]
 539:../main.c     **** 					usb_changed_timestamp = SYSTIMER_GetTime();
 2375              	 .loc 5 539 0
 2376 0114 FFF7FEFF 	 bl SYSTIMER_GetTime
 2377 0118 021C     	 mov r2,r0
 2378 011a 8E4B     	 ldr r3,.L154+36
 2379 011c 1A60     	 str r2,[r3]
 540:../main.c     **** 				}
 541:../main.c     **** 				break;
 2380              	 .loc 5 541 0
 2381 011e 17E0     	 b .L106
 2382              	.L110:
 2383 0120 16E0     	 b .L106
 2384              	.L107:
 542:../main.c     **** 			case USB_2_active:
 543:../main.c     **** 				// State code - none atm
 544:../main.c     **** 
 545:../main.c     **** 				// Transition statement
 546:../main.c     **** 				if(buttonpress_usb == BTNPRESS_STD){
 2385              	 .loc 5 546 0
 2386 0122 8E4B     	 ldr r3,.L154+44
 2387 0124 1B78     	 ldrb r3,[r3]
 2388 0126 012B     	 cmp r3,#1
 2389 0128 10D1     	 bne .L111
 547:../main.c     **** 					USB_state = USB_1_active;
 2390              	 .loc 5 547 0
 2391 012a 864B     	 ldr r3,.L154+20
 2392 012c 0022     	 mov r2,#0
 2393 012e 1A70     	 strb r2,[r3]
 548:../main.c     **** 					switchUSB(USB_state);
 2394              	 .loc 5 548 0
 2395 0130 844B     	 ldr r3,.L154+20
 2396 0132 1B78     	 ldrb r3,[r3]
 2397 0134 181C     	 mov r0,r3
 2398 0136 FFF7FEFF 	 bl switchUSB
 549:../main.c     **** 					buttonpress_usb = BTNPRESS_NOT;
 2399              	 .loc 5 549 0
 2400 013a 884B     	 ldr r3,.L154+44
 2401 013c 0022     	 mov r2,#0
 2402 013e 1A70     	 strb r2,[r3]
 550:../main.c     **** 					usb_changed_timestamp = SYSTIMER_GetTime();
 2403              	 .loc 5 550 0
 2404 0140 FFF7FEFF 	 bl SYSTIMER_GetTime
 2405 0144 021C     	 mov r2,r0
 2406 0146 834B     	 ldr r3,.L154+36
 2407 0148 1A60     	 str r2,[r3]
 551:../main.c     **** 				}
 552:../main.c     **** 				break;
 2408              	 .loc 5 552 0
 2409 014a 01E0     	 b .L106
 2410              	.L111:
 2411 014c 00E0     	 b .L106
 2412              	.L151:
 553:../main.c     **** 			case USB_inactive:
 554:../main.c     **** 				// Currently not implemented!
 555:../main.c     **** 				break;
 2413              	 .loc 5 555 0
 2414 014e C046     	 mov r8,r8
 2415              	.L106:
 556:../main.c     **** 		}
 557:../main.c     **** 
 558:../main.c     **** 		/// - Relay handling -
 559:../main.c     **** 		// Check for state change triggers based on current state
 560:../main.c     **** 		switch (relay_state){
 2416              	 .loc 5 560 0
 2417 0150 834B     	 ldr r3,.L154+48
 2418 0152 1B78     	 ldrb r3,[r3]
 2419 0154 002B     	 cmp r3,#0
 2420 0156 4ED0     	 beq .L113
 2421 0158 012B     	 cmp r3,#1
 2422 015a 00D0     	 beq .LCB1964
 2423 015c 95E0     	 b .L112
 2424              	.LCB1964:
 561:../main.c     **** 			case RELAY_LOW:
 562:../main.c     **** 				// State code
 563:../main.c     **** 				// Check if upper threshold is exceeded. If it is and timestamp is not already set - save times
 564:../main.c     **** 				if     (ADC_val_upper_thres_exceed_timestamp == 0 && ADC_val_current > ADC_upper_threshold){
 2425              	 .loc 5 564 0
 2426 015e 814B     	 ldr r3,.L154+52
 2427 0160 1B68     	 ldr r3,[r3]
 2428 0162 002B     	 cmp r3,#0
 2429 0164 0CD1     	 bne .L115
 2430              	 .loc 5 564 0 is_stmt 0 discriminator 1
 2431 0166 804B     	 ldr r3,.L154+56
 2432 0168 1B68     	 ldr r3,[r3]
 2433 016a 1A1E     	 sub r2,r3,#0
 2434 016c 7F4B     	 ldr r3,.L154+60
 2435 016e 1B68     	 ldr r3,[r3]
 2436 0170 9A42     	 cmp r2,r3
 2437 0172 05D2     	 bcs .L115
 565:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = SYSTIMER_GetTime();
 2438              	 .loc 5 565 0 is_stmt 1
 2439 0174 FFF7FEFF 	 bl SYSTIMER_GetTime
 2440 0178 021C     	 mov r2,r0
 2441 017a 7A4B     	 ldr r3,.L154+52
 2442 017c 1A60     	 str r2,[r3]
 2443 017e 0DE0     	 b .L116
 2444              	.L115:
 566:../main.c     **** 				}
 567:../main.c     **** 				else if(ADC_val_upper_thres_exceed_timestamp != 0 && ADC_val_current < ADC_upper_threshold){
 2445              	 .loc 5 567 0
 2446 0180 784B     	 ldr r3,.L154+52
 2447 0182 1B68     	 ldr r3,[r3]
 2448 0184 002B     	 cmp r3,#0
 2449 0186 09D0     	 beq .L116
 2450              	 .loc 5 567 0 is_stmt 0 discriminator 1
 2451 0188 774B     	 ldr r3,.L154+56
 2452 018a 1B68     	 ldr r3,[r3]
 2453 018c 1A1E     	 sub r2,r3,#0
 2454 018e 774B     	 ldr r3,.L154+60
 2455 0190 1B68     	 ldr r3,[r3]
 2456 0192 9A42     	 cmp r2,r3
 2457 0194 02D9     	 bls .L116
 568:../main.c     **** 					ADC_val_upper_thres_exceed_timestamp = 0;
 2458              	 .loc 5 568 0 is_stmt 1
 2459 0196 734B     	 ldr r3,.L154+52
 2460 0198 0022     	 mov r2,#0
 2461 019a 1A60     	 str r2,[r3]
 2462              	.L116:
 569:../main.c     **** 				}
 570:../main.c     **** 
 571:../main.c     **** 				// Transition statement
 572:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 573:../main.c     **** 				if(ADC_val_upper_thres_exceed_timestamp != 0){
 2463              	 .loc 5 573 0
 2464 019c 714B     	 ldr r3,.L154+52
 2465 019e 1B68     	 ldr r3,[r3]
 2466 01a0 002B     	 cmp r3,#0
 2467 01a2 27D0     	 beq .L117
 2468              	.LBB4:
 574:../main.c     **** 					uint16_t upperThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_upper_thres_exceed_times
 2469              	 .loc 5 574 0
 2470 01a4 FFF7FEFF 	 bl SYSTIMER_GetTime
 2471 01a8 021C     	 mov r2,r0
 2472 01aa 6E4B     	 ldr r3,.L154+52
 2473 01ac 1B68     	 ldr r3,[r3]
 2474 01ae D31A     	 sub r3,r2,r3
 2475 01b0 181C     	 mov r0,r3
 2476 01b2 FA23     	 mov r3,#250
 2477 01b4 9900     	 lsl r1,r3,#2
 2478 01b6 FFF7FEFF 	 bl __aeabi_uidiv
 2479 01ba 031C     	 mov r3,r0
 2480 01bc 1A1C     	 mov r2,r3
 2481 01be 0823     	 mov r3,#8
 2482 01c0 FB18     	 add r3,r7,r3
 2483 01c2 1A80     	 strh r2,[r3]
 575:../main.c     **** 					if(upperThresholdExceedDuration > relay_threshold_latchtime){
 2484              	 .loc 5 575 0
 2485 01c4 0823     	 mov r3,#8
 2486 01c6 FB18     	 add r3,r7,r3
 2487 01c8 1A88     	 ldrh r2,[r3]
 2488 01ca 694B     	 ldr r3,.L154+64
 2489 01cc 1B68     	 ldr r3,[r3]
 2490 01ce 9A42     	 cmp r2,r3
 2491 01d0 10DD     	 ble .L117
 576:../main.c     **** 						relay_state = RELAY_HIGH;
 2492              	 .loc 5 576 0
 2493 01d2 634B     	 ldr r3,.L154+48
 2494 01d4 0022     	 mov r2,#0
 2495 01d6 1A70     	 strb r2,[r3]
 577:../main.c     **** 						DIGITAL_IO_SetOutputHigh(&IO_RELAY);
 2496              	 .loc 5 577 0
 2497 01d8 5B4B     	 ldr r3,.L154+24
 2498 01da 181C     	 mov r0,r3
 2499 01dc FFF7FEFF 	 bl DIGITAL_IO_SetOutputHigh
 578:../main.c     **** 						ADC_val_upper_thres_exceed_timestamp = 0;
 2500              	 .loc 5 578 0
 2501 01e0 604B     	 ldr r3,.L154+52
 2502 01e2 0022     	 mov r2,#0
 2503 01e4 1A60     	 str r2,[r3]
 579:../main.c     **** 						if(setup_state == SETUP_IDLE)
 2504              	 .loc 5 579 0
 2505 01e6 634B     	 ldr r3,.L154+68
 2506 01e8 1B78     	 ldrb r3,[r3]
 2507 01ea 002B     	 cmp r3,#0
 2508 01ec 02D1     	 bne .L117
 580:../main.c     **** 							reset_status_led_to_relay_state();
 2509              	 .loc 5 580 0
 2510 01ee FFF7FEFF 	 bl reset_status_led_to_relay_state
 2511              	.LBE4:
 581:../main.c     **** 					}
 582:../main.c     **** 				}
 583:../main.c     **** 				break;
 2512              	 .loc 5 583 0
 2513 01f2 4AE0     	 b .L112
 2514              	.L117:
 2515 01f4 49E0     	 b .L112
 2516              	.L113:
 584:../main.c     **** 			case RELAY_HIGH:
 585:../main.c     **** 				// State code
 586:../main.c     **** 				// Check if lower threshold is exceeded. If it is and timestamp is not already set - save times
 587:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp == 0 && ADC_val_current < ADC_lower_threshold){
 2517              	 .loc 5 587 0
 2518 01f6 604B     	 ldr r3,.L154+72
 2519 01f8 1B68     	 ldr r3,[r3]
 2520 01fa 002B     	 cmp r3,#0
 2521 01fc 0CD1     	 bne .L118
 2522              	 .loc 5 587 0 is_stmt 0 discriminator 1
 2523 01fe 5F4B     	 ldr r3,.L154+76
 2524 0200 1B68     	 ldr r3,[r3]
 2525 0202 1A1E     	 sub r2,r3,#0
 2526 0204 594B     	 ldr r3,.L154+60
 2527 0206 1B68     	 ldr r3,[r3]
 2528 0208 9A42     	 cmp r2,r3
 2529 020a 05D9     	 bls .L118
 588:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = SYSTIMER_GetTime();
 2530              	 .loc 5 588 0 is_stmt 1
 2531 020c FFF7FEFF 	 bl SYSTIMER_GetTime
 2532 0210 021C     	 mov r2,r0
 2533 0212 594B     	 ldr r3,.L154+72
 2534 0214 1A60     	 str r2,[r3]
 2535 0216 0DE0     	 b .L119
 2536              	.L118:
 589:../main.c     **** 				}
 590:../main.c     **** 				else if(ADC_val_lower_thres_exceed_timestamp != 0 && ADC_val_current > ADC_lower_threshold){
 2537              	 .loc 5 590 0
 2538 0218 574B     	 ldr r3,.L154+72
 2539 021a 1B68     	 ldr r3,[r3]
 2540 021c 002B     	 cmp r3,#0
 2541 021e 09D0     	 beq .L119
 2542              	 .loc 5 590 0 is_stmt 0 discriminator 1
 2543 0220 564B     	 ldr r3,.L154+76
 2544 0222 1B68     	 ldr r3,[r3]
 2545 0224 1A1E     	 sub r2,r3,#0
 2546 0226 514B     	 ldr r3,.L154+60
 2547 0228 1B68     	 ldr r3,[r3]
 2548 022a 9A42     	 cmp r2,r3
 2549 022c 02D2     	 bcs .L119
 591:../main.c     **** 					ADC_val_lower_thres_exceed_timestamp = 0;
 2550              	 .loc 5 591 0 is_stmt 1
 2551 022e 524B     	 ldr r3,.L154+72
 2552 0230 0022     	 mov r2,#0
 2553 0232 1A60     	 str r2,[r3]
 2554              	.L119:
 592:../main.c     **** 				}
 593:../main.c     **** 
 594:../main.c     **** 				// Transition statement
 595:../main.c     **** 				// Check if threshold are exceeded long enough to trigger a switch
 596:../main.c     **** 				if(ADC_val_lower_thres_exceed_timestamp != 0){
 2555              	 .loc 5 596 0
 2556 0234 504B     	 ldr r3,.L154+72
 2557 0236 1B68     	 ldr r3,[r3]
 2558 0238 002B     	 cmp r3,#0
 2559 023a 25D0     	 beq .L120
 2560              	.LBB5:
 597:../main.c     **** 					uint16_t lowerThresholdExceedDuration = (SYSTIMER_GetTime() - ADC_val_lower_thres_exceed_times
 2561              	 .loc 5 597 0
 2562 023c FFF7FEFF 	 bl SYSTIMER_GetTime
 2563 0240 021C     	 mov r2,r0
 2564 0242 4D4B     	 ldr r3,.L154+72
 2565 0244 1B68     	 ldr r3,[r3]
 2566 0246 D31A     	 sub r3,r2,r3
 2567 0248 181C     	 mov r0,r3
 2568 024a FA23     	 mov r3,#250
 2569 024c 9900     	 lsl r1,r3,#2
 2570 024e FFF7FEFF 	 bl __aeabi_uidiv
 2571 0252 031C     	 mov r3,r0
 2572 0254 1A1C     	 mov r2,r3
 2573 0256 BB1D     	 add r3,r7,#6
 2574 0258 1A80     	 strh r2,[r3]
 598:../main.c     **** 					if(lowerThresholdExceedDuration > relay_threshold_latchtime){
 2575              	 .loc 5 598 0
 2576 025a BB1D     	 add r3,r7,#6
 2577 025c 1A88     	 ldrh r2,[r3]
 2578 025e 444B     	 ldr r3,.L154+64
 2579 0260 1B68     	 ldr r3,[r3]
 2580 0262 9A42     	 cmp r2,r3
 2581 0264 10DD     	 ble .L120
 599:../main.c     **** 						relay_state = RELAY_LOW;
 2582              	 .loc 5 599 0
 2583 0266 3E4B     	 ldr r3,.L154+48
 2584 0268 0122     	 mov r2,#1
 2585 026a 1A70     	 strb r2,[r3]
 600:../main.c     **** 						DIGITAL_IO_SetOutputLow(&IO_RELAY);
 2586              	 .loc 5 600 0
 2587 026c 364B     	 ldr r3,.L154+24
 2588 026e 181C     	 mov r0,r3
 2589 0270 FFF7FEFF 	 bl DIGITAL_IO_SetOutputLow
 601:../main.c     **** 						ADC_val_lower_thres_exceed_timestamp = 0;
 2590              	 .loc 5 601 0
 2591 0274 404B     	 ldr r3,.L154+72
 2592 0276 0022     	 mov r2,#0
 2593 0278 1A60     	 str r2,[r3]
 602:../main.c     **** 						if(setup_state == SETUP_IDLE)
 2594              	 .loc 5 602 0
 2595 027a 3E4B     	 ldr r3,.L154+68
 2596 027c 1B78     	 ldrb r3,[r3]
 2597 027e 002B     	 cmp r3,#0
 2598 0280 02D1     	 bne .L120
 603:../main.c     **** 							reset_status_led_to_relay_state();
 2599              	 .loc 5 603 0
 2600 0282 FFF7FEFF 	 bl reset_status_led_to_relay_state
 2601              	.LBE5:
 604:../main.c     **** 					}
 605:../main.c     **** 				}
 606:../main.c     **** 				break;
 2602              	 .loc 5 606 0
 2603 0286 FFE7     	 b .L152
 2604              	.L120:
 2605              	.L152:
 2606 0288 C046     	 mov r8,r8
 2607              	.L112:
 607:../main.c     **** 		}
 608:../main.c     **** 		// Init next value conversion
 609:../main.c     **** 		ADC_MEASUREMENT_StartConversion(&ADC_SENSOR);
 2608              	 .loc 5 609 0
 2609 028a 304B     	 ldr r3,.L154+28
 2610 028c 181C     	 mov r0,r3
 2611 028e FFF7FEFF 	 bl ADC_MEASUREMENT_StartConversion
 610:../main.c     **** 
 611:../main.c     **** 		/// - Relay settings handling - Todo auto exit menus after time?, led signal when reaching max?, 
 612:../main.c     **** 		switch(setup_state){
 2612              	 .loc 5 612 0
 2613 0292 384B     	 ldr r3,.L154+68
 2614 0294 1B78     	 ldrb r3,[r3]
 2615 0296 012B     	 cmp r3,#1
 2616 0298 33D0     	 beq .L122
 2617 029a 02DC     	 bgt .L123
 2618 029c 002B     	 cmp r3,#0
 2619 029e 07D0     	 beq .L124
 2620 02a0 9CE1     	 b .L121
 2621              	.L123:
 2622 02a2 022B     	 cmp r3,#2
 2623 02a4 00D1     	 bne .LCB2148
 2624 02a6 D1E0     	 b .L125
 2625              	.LCB2148:
 2626 02a8 032B     	 cmp r3,#3
 2627 02aa 00D1     	 bne .LCB2150
 2628 02ac 42E1     	 b .L126
 2629              	.LCB2150:
 2630 02ae 95E1     	 b .L121
 2631              	.L124:
 613:../main.c     **** 			case SETUP_IDLE:
 614:../main.c     **** 				/// Interpret button press and change to according setup sub-menu (state)
 615:../main.c     **** 				// A long  press of up or down brings system in time setup menu
 616:../main.c     **** 				// A short press of up         brings system in upper threshold setup menu
 617:../main.c     **** 				// A short press of down       brings system in lower threshold setup menu
 618:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2632              	 .loc 5 618 0
 2633 02b0 334B     	 ldr r3,.L154+80
 2634 02b2 1B78     	 ldrb r3,[r3]
 2635 02b4 022B     	 cmp r3,#2
 2636 02b6 03D0     	 beq .L127
 2637              	 .loc 5 618 0 is_stmt 0 discriminator 1
 2638 02b8 324B     	 ldr r3,.L154+84
 2639 02ba 1B78     	 ldrb r3,[r3]
 2640 02bc 022B     	 cmp r3,#2
 2641 02be 09D1     	 bne .L128
 2642              	.L127:
 619:../main.c     **** 					setup_state = SETUP_TIME_TH;
 2643              	 .loc 5 619 0 is_stmt 1
 2644 02c0 2C4B     	 ldr r3,.L154+68
 2645 02c2 0322     	 mov r2,#3
 2646 02c4 1A70     	 strb r2,[r3]
 620:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2647              	 .loc 5 620 0
 2648 02c6 304B     	 ldr r3,.L154+88
 2649 02c8 0222     	 mov r2,#2
 2650 02ca 1A70     	 strb r2,[r3]
 621:../main.c     **** 					led_number_continuous = 1;
 2651              	 .loc 5 621 0
 2652 02cc 2F4B     	 ldr r3,.L154+92
 2653 02ce 0122     	 mov r2,#1
 2654 02d0 1A80     	 strh r2,[r3]
 2655 02d2 15E0     	 b .L129
 2656              	.L128:
 622:../main.c     **** 				}
 623:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 2657              	 .loc 5 623 0
 2658 02d4 2A4B     	 ldr r3,.L154+80
 2659 02d6 1B78     	 ldrb r3,[r3]
 2660 02d8 012B     	 cmp r3,#1
 2661 02da 06D1     	 bne .L130
 624:../main.c     **** 					setup_state = SETUP_UPPER_TH;
 2662              	 .loc 5 624 0
 2663 02dc 254B     	 ldr r3,.L154+68
 2664 02de 0122     	 mov r2,#1
 2665 02e0 1A70     	 strb r2,[r3]
 625:../main.c     **** 					led_status_pattern = LED_FADE_UP;
 2666              	 .loc 5 625 0
 2667 02e2 294B     	 ldr r3,.L154+88
 2668 02e4 0422     	 mov r2,#4
 2669 02e6 1A70     	 strb r2,[r3]
 2670 02e8 0AE0     	 b .L129
 2671              	.L130:
 626:../main.c     **** 					//led_status_pattern = LED_NUMBER;
 627:../main.c     **** 					//led_number_continuous = 5;
 628:../main.c     **** 				}
 629:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 2672              	 .loc 5 629 0
 2673 02ea 264B     	 ldr r3,.L154+84
 2674 02ec 1B78     	 ldrb r3,[r3]
 2675 02ee 012B     	 cmp r3,#1
 2676 02f0 06D1     	 bne .L129
 630:../main.c     **** 					setup_state = SETUP_LOWER_TH;
 2677              	 .loc 5 630 0
 2678 02f2 204B     	 ldr r3,.L154+68
 2679 02f4 0222     	 mov r2,#2
 2680 02f6 1A70     	 strb r2,[r3]
 631:../main.c     **** 					led_status_pattern = LED_FADE_DOWN;
 2681              	 .loc 5 631 0
 2682 02f8 234B     	 ldr r3,.L154+88
 2683 02fa 0322     	 mov r2,#3
 2684 02fc 1A70     	 strb r2,[r3]
 632:../main.c     **** 					//led_status_pattern = LED_NUMBER;
 633:../main.c     **** 					//led_number_continuous = 3;
 634:../main.c     **** 				}
 635:../main.c     **** 				break;
 2685              	 .loc 5 635 0
 2686 02fe 6DE1     	 b .L121
 2687              	.L129:
 2688 0300 6CE1     	 b .L121
 2689              	.L122:
 636:../main.c     **** 			case SETUP_UPPER_TH:
 637:../main.c     **** 				// Blink relay LED
 638:../main.c     **** 
 639:../main.c     **** 				/// Interpret button press:
 640:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 641:../main.c     **** 				// A short press of up         increases the upper threshold value
 642:../main.c     **** 				// A short press of down       decreases the upper threshold value
 643:../main.c     **** 				// A longest press of up saves the current ADC value as threshold
 644:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2690              	 .loc 5 644 0
 2691 0302 1F4B     	 ldr r3,.L154+80
 2692 0304 1B78     	 ldrb r3,[r3]
 2693 0306 022B     	 cmp r3,#2
 2694 0308 03D0     	 beq .L131
 2695              	 .loc 5 644 0 is_stmt 0 discriminator 1
 2696 030a 1E4B     	 ldr r3,.L154+84
 2697 030c 1B78     	 ldrb r3,[r3]
 2698 030e 022B     	 cmp r3,#2
 2699 0310 3ED1     	 bne .L132
 2700              	.L131:
 645:../main.c     **** 					write_eeprom(EEPROM_UPPER_TH, ADC_upper_threshold, 4);
 2701              	 .loc 5 645 0 is_stmt 1
 2702 0312 154B     	 ldr r3,.L154+56
 2703 0314 1B68     	 ldr r3,[r3]
 2704 0316 0220     	 mov r0,#2
 2705 0318 191C     	 mov r1,r3
 2706 031a 0422     	 mov r2,#4
 2707 031c FFF7FEFF 	 bl write_eeprom
 646:../main.c     **** 					setup_state = SETUP_IDLE;
 2708              	 .loc 5 646 0
 2709 0320 144B     	 ldr r3,.L154+68
 2710 0322 0022     	 mov r2,#0
 2711 0324 1A70     	 strb r2,[r3]
 647:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2712              	 .loc 5 647 0
 2713 0326 184B     	 ldr r3,.L154+88
 2714 0328 0522     	 mov r2,#5
 2715 032a 1A70     	 strb r2,[r3]
 2716 032c 8DE0     	 b .L133
 2717              	.L155:
 2718 032e C046     	 .align 2
 2719              	.L154:
 2720 0330 00000000 	 .word IO_LED_USB1
 2721 0334 00000000 	 .word IO_LED_USB2
 2722 0338 00000000 	 .word PWM_CCU4_LED_STATUS
 2723 033c 10270000 	 .word 10000
 2724 0340 00000000 	 .word IO_USB_OE
 2725 0344 00000000 	 .word USB_state
 2726 0348 00000000 	 .word IO_RELAY
 2727 034c 00000000 	 .word ADC_SENSOR
 2728 0350 00000000 	 .word systime_debug
 2729 0354 00000000 	 .word usb_changed_timestamp
 2730 0358 274F4C00 	 .word 5000999
 2731 035c 00000000 	 .word buttonpress_usb
 2732 0360 00000000 	 .word relay_state
 2733 0364 00000000 	 .word ADC_val_upper_thres_exceed_timestamp
 2734 0368 00000000 	 .word ADC_upper_threshold
 2735 036c 00000000 	 .word ADC_val_current
 2736 0370 00000000 	 .word relay_threshold_latchtime
 2737 0374 00000000 	 .word setup_state
 2738 0378 00000000 	 .word ADC_val_lower_thres_exceed_timestamp
 2739 037c 00000000 	 .word ADC_lower_threshold
 2740 0380 00000000 	 .word buttonpress_up
 2741 0384 00000000 	 .word buttonpress_down
 2742 0388 00000000 	 .word led_status_pattern
 2743 038c 00000000 	 .word led_number_continuous
 2744              	.L132:
 648:../main.c     **** 				}
 649:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2745              	 .loc 5 649 0
 2746 0390 974B     	 ldr r3,.L156
 2747 0392 1B78     	 ldrb r3,[r3]
 2748 0394 012B     	 cmp r3,#1
 2749 0396 1AD1     	 bne .L134
 650:../main.c     **** 					ADC_upper_threshold += ADC_THRESHOLD_INCREMENT;
 2750              	 .loc 5 650 0
 2751 0398 964B     	 ldr r3,.L156+4
 2752 039a 1B68     	 ldr r3,[r3]
 2753 039c 7533     	 add r3,r3,#117
 2754 039e 1A1C     	 mov r2,r3
 2755 03a0 944B     	 ldr r3,.L156+4
 2756 03a2 1A60     	 str r2,[r3]
 651:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 652:../main.c     **** 					if(ADC_upper_threshold > ADC_THRESHOLD_MAX){
 2757              	 .loc 5 652 0
 2758 03a4 934B     	 ldr r3,.L156+4
 2759 03a6 1B68     	 ldr r3,[r3]
 2760 03a8 934A     	 ldr r2,.L156+8
 2761 03aa 9342     	 cmp r3,r2
 2762 03ac 4DDD     	 ble .L133
 653:../main.c     **** 						ADC_upper_threshold = ADC_THRESHOLD_MAX;
 2763              	 .loc 5 653 0
 2764 03ae 914B     	 ldr r3,.L156+4
 2765 03b0 914A     	 ldr r2,.L156+8
 2766 03b2 1A60     	 str r2,[r3]
 654:../main.c     **** 						led_number_single = 2;
 2767              	 .loc 5 654 0
 2768 03b4 914B     	 ldr r3,.L156+12
 2769 03b6 0222     	 mov r2,#2
 2770 03b8 1A80     	 strh r2,[r3]
 655:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2771              	 .loc 5 655 0
 2772 03ba 914B     	 ldr r3,.L156+16
 2773 03bc 0222     	 mov r2,#2
 2774 03be 1A70     	 strb r2,[r3]
 656:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2775              	 .loc 5 656 0
 2776 03c0 904B     	 ldr r3,.L156+20
 2777 03c2 0122     	 mov r2,#1
 2778 03c4 1A70     	 strb r2,[r3]
 657:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2779              	 .loc 5 657 0
 2780 03c6 904B     	 ldr r3,.L156+24
 2781 03c8 0422     	 mov r2,#4
 2782 03ca 1A70     	 strb r2,[r3]
 658:../main.c     **** 					}
 659:../main.c     **** 				}
 660:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 661:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 662:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 663:../main.c     **** 					if(ADC_upper_threshold <= 0){
 664:../main.c     **** 						ADC_upper_threshold = 0;
 665:../main.c     **** 						led_number_single = 2;
 666:../main.c     **** 						led_status_pattern = LED_NUMBER;
 667:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 668:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 669:../main.c     **** 					}
 670:../main.c     **** 					//if(ADC_upper_threshold <= ADC_lower_threshold)
 671:../main.c     **** 						//ADC_upper_threshold = ADC_lower_threshold;
 672:../main.c     **** 				}
 673:../main.c     **** 				else if(buttonpress_up == BTNPRESS_LONGEST){
 674:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 675:../main.c     **** 					ADC_upper_threshold = ADC_val_current;
 676:../main.c     **** 					write_eeprom(EEPROM_UPPER_TH, ADC_upper_threshold, 4);
 677:../main.c     **** 					setup_state = SETUP_IDLE;
 678:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 679:../main.c     **** 					led_number_single = 3;
 680:../main.c     **** 					led_status_pattern = LED_NUMBER;
 681:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 682:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 683:../main.c     **** 				}
 684:../main.c     **** 				break;
 2783              	 .loc 5 684 0
 2784 03cc 06E1     	 b .L121
 2785              	.L134:
 660:../main.c     **** 					ADC_upper_threshold -= ADC_THRESHOLD_INCREMENT;
 2786              	 .loc 5 660 0
 2787 03ce 8F4B     	 ldr r3,.L156+28
 2788 03d0 1B78     	 ldrb r3,[r3]
 2789 03d2 012B     	 cmp r3,#1
 2790 03d4 19D1     	 bne .L136
 661:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2791              	 .loc 5 661 0
 2792 03d6 874B     	 ldr r3,.L156+4
 2793 03d8 1B68     	 ldr r3,[r3]
 2794 03da 753B     	 sub r3,r3,#117
 2795 03dc 1A1C     	 mov r2,r3
 2796 03de 854B     	 ldr r3,.L156+4
 2797 03e0 1A60     	 str r2,[r3]
 663:../main.c     **** 						ADC_upper_threshold = 0;
 2798              	 .loc 5 663 0
 2799 03e2 844B     	 ldr r3,.L156+4
 2800 03e4 1B68     	 ldr r3,[r3]
 2801 03e6 002B     	 cmp r3,#0
 2802 03e8 2FDC     	 bgt .L133
 664:../main.c     **** 						led_number_single = 2;
 2803              	 .loc 5 664 0
 2804 03ea 824B     	 ldr r3,.L156+4
 2805 03ec 0022     	 mov r2,#0
 2806 03ee 1A60     	 str r2,[r3]
 665:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2807              	 .loc 5 665 0
 2808 03f0 824B     	 ldr r3,.L156+12
 2809 03f2 0222     	 mov r2,#2
 2810 03f4 1A80     	 strh r2,[r3]
 666:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2811              	 .loc 5 666 0
 2812 03f6 824B     	 ldr r3,.L156+16
 2813 03f8 0222     	 mov r2,#2
 2814 03fa 1A70     	 strb r2,[r3]
 667:../main.c     **** 						led_status_pattern_after_single = LED_FADE_UP;
 2815              	 .loc 5 667 0
 2816 03fc 814B     	 ldr r3,.L156+20
 2817 03fe 0122     	 mov r2,#1
 2818 0400 1A70     	 strb r2,[r3]
 668:../main.c     **** 					}
 2819              	 .loc 5 668 0
 2820 0402 814B     	 ldr r3,.L156+24
 2821 0404 0422     	 mov r2,#4
 2822 0406 1A70     	 strb r2,[r3]
 2823              	 .loc 5 684 0
 2824 0408 E8E0     	 b .L121
 2825              	.L136:
 673:../main.c     **** 					// Save current ADC value as threshold and exit setup menu
 2826              	 .loc 5 673 0
 2827 040a 794B     	 ldr r3,.L156
 2828 040c 1B78     	 ldrb r3,[r3]
 2829 040e 032B     	 cmp r3,#3
 2830 0410 1BD1     	 bne .L133
 675:../main.c     **** 					write_eeprom(EEPROM_UPPER_TH, ADC_upper_threshold, 4);
 2831              	 .loc 5 675 0
 2832 0412 7F4B     	 ldr r3,.L156+32
 2833 0414 1B68     	 ldr r3,[r3]
 2834 0416 1A1C     	 mov r2,r3
 2835 0418 764B     	 ldr r3,.L156+4
 2836 041a 1A60     	 str r2,[r3]
 676:../main.c     **** 					setup_state = SETUP_IDLE;
 2837              	 .loc 5 676 0
 2838 041c 754B     	 ldr r3,.L156+4
 2839 041e 1B68     	 ldr r3,[r3]
 2840 0420 0220     	 mov r0,#2
 2841 0422 191C     	 mov r1,r3
 2842 0424 0422     	 mov r2,#4
 2843 0426 FFF7FEFF 	 bl write_eeprom
 677:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2844              	 .loc 5 677 0
 2845 042a 7A4B     	 ldr r3,.L156+36
 2846 042c 0022     	 mov r2,#0
 2847 042e 1A70     	 strb r2,[r3]
 679:../main.c     **** 					led_status_pattern = LED_NUMBER;
 2848              	 .loc 5 679 0
 2849 0430 724B     	 ldr r3,.L156+12
 2850 0432 0322     	 mov r2,#3
 2851 0434 1A80     	 strh r2,[r3]
 680:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 2852              	 .loc 5 680 0
 2853 0436 724B     	 ldr r3,.L156+16
 2854 0438 0222     	 mov r2,#2
 2855 043a 1A70     	 strb r2,[r3]
 681:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 2856              	 .loc 5 681 0
 2857 043c 714B     	 ldr r3,.L156+20
 2858 043e 0122     	 mov r2,#1
 2859 0440 1A70     	 strb r2,[r3]
 682:../main.c     **** 				}
 2860              	 .loc 5 682 0
 2861 0442 714B     	 ldr r3,.L156+24
 2862 0444 0522     	 mov r2,#5
 2863 0446 1A70     	 strb r2,[r3]
 2864              	 .loc 5 684 0
 2865 0448 C8E0     	 b .L121
 2866              	.L133:
 2867              	 .loc 5 684 0 is_stmt 0 discriminator 1
 2868 044a C7E0     	 b .L121
 2869              	.L125:
 685:../main.c     **** 			case SETUP_LOWER_TH:
 686:../main.c     **** 				// Blink relay LED
 687:../main.c     **** 
 688:../main.c     **** 				/// Interpret button press:
 689:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 690:../main.c     **** 				// A short press of up         increases the lower threshold value
 691:../main.c     **** 				// A short press of down       decreases the lower threshold value
 692:../main.c     **** 				// A longest press of down saves the current ADC value as threshold
 693:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 2870              	 .loc 5 693 0 is_stmt 1
 2871 044c 684B     	 ldr r3,.L156
 2872 044e 1B78     	 ldrb r3,[r3]
 2873 0450 022B     	 cmp r3,#2
 2874 0452 03D0     	 beq .L138
 2875              	 .loc 5 693 0 is_stmt 0 discriminator 1
 2876 0454 6D4B     	 ldr r3,.L156+28
 2877 0456 1B78     	 ldrb r3,[r3]
 2878 0458 022B     	 cmp r3,#2
 2879 045a 0DD1     	 bne .L139
 2880              	.L138:
 694:../main.c     **** 					write_eeprom(EEPROM_LOWER_TH, ADC_lower_threshold, 4);
 2881              	 .loc 5 694 0 is_stmt 1
 2882 045c 6E4B     	 ldr r3,.L156+40
 2883 045e 1B68     	 ldr r3,[r3]
 2884 0460 0120     	 mov r0,#1
 2885 0462 191C     	 mov r1,r3
 2886 0464 0422     	 mov r2,#4
 2887 0466 FFF7FEFF 	 bl write_eeprom
 695:../main.c     **** 					setup_state = SETUP_IDLE;
 2888              	 .loc 5 695 0
 2889 046a 6A4B     	 ldr r3,.L156+36
 2890 046c 0022     	 mov r2,#0
 2891 046e 1A70     	 strb r2,[r3]
 696:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 2892              	 .loc 5 696 0
 2893 0470 634B     	 ldr r3,.L156+16
 2894 0472 0522     	 mov r2,#5
 2895 0474 1A70     	 strb r2,[r3]
 2896 0476 5CE0     	 b .L140
 2897              	.L139:
 697:../main.c     **** 				}
 698:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){ // Increase
 2898              	 .loc 5 698 0
 2899 0478 5D4B     	 ldr r3,.L156
 2900 047a 1B78     	 ldrb r3,[r3]
 2901 047c 012B     	 cmp r3,#1
 2902 047e 1AD1     	 bne .L141
 699:../main.c     **** 					ADC_lower_threshold += ADC_THRESHOLD_INCREMENT;
 2903              	 .loc 5 699 0
 2904 0480 654B     	 ldr r3,.L156+40
 2905 0482 1B68     	 ldr r3,[r3]
 2906 0484 7533     	 add r3,r3,#117
 2907 0486 1A1C     	 mov r2,r3
 2908 0488 634B     	 ldr r3,.L156+40
 2909 048a 1A60     	 str r2,[r3]
 700:../main.c     **** 					// If maximum is reached blink led 2 times, then continue fading
 701:../main.c     **** 					if(ADC_lower_threshold > ADC_THRESHOLD_MAX){
 2910              	 .loc 5 701 0
 2911 048c 624B     	 ldr r3,.L156+40
 2912 048e 1B68     	 ldr r3,[r3]
 2913 0490 594A     	 ldr r2,.L156+8
 2914 0492 9342     	 cmp r3,r2
 2915 0494 4DDD     	 ble .L140
 702:../main.c     **** 						ADC_lower_threshold = ADC_THRESHOLD_MAX;
 2916              	 .loc 5 702 0
 2917 0496 604B     	 ldr r3,.L156+40
 2918 0498 574A     	 ldr r2,.L156+8
 2919 049a 1A60     	 str r2,[r3]
 703:../main.c     **** 						led_number_single = 2;
 2920              	 .loc 5 703 0
 2921 049c 574B     	 ldr r3,.L156+12
 2922 049e 0222     	 mov r2,#2
 2923 04a0 1A80     	 strh r2,[r3]
 704:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2924              	 .loc 5 704 0
 2925 04a2 574B     	 ldr r3,.L156+16
 2926 04a4 0222     	 mov r2,#2
 2927 04a6 1A70     	 strb r2,[r3]
 705:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2928              	 .loc 5 705 0
 2929 04a8 564B     	 ldr r3,.L156+20
 2930 04aa 0122     	 mov r2,#1
 2931 04ac 1A70     	 strb r2,[r3]
 706:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2932              	 .loc 5 706 0
 2933 04ae 564B     	 ldr r3,.L156+24
 2934 04b0 0322     	 mov r2,#3
 2935 04b2 1A70     	 strb r2,[r3]
 707:../main.c     **** 					}
 708:../main.c     **** 				}
 709:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){ // Decrease
 710:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 711:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 712:../main.c     **** 					if(ADC_lower_threshold <= 0){
 713:../main.c     **** 						ADC_lower_threshold = 0;
 714:../main.c     **** 						led_number_single = 2;
 715:../main.c     **** 						led_status_pattern = LED_NUMBER;
 716:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 717:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 718:../main.c     **** 					}
 719:../main.c     **** 				}
 720:../main.c     **** 				else if(buttonpress_down == BTNPRESS_LONGEST){
 721:../main.c     **** 					// Save current ADC value as threshold
 722:../main.c     **** 					ADC_lower_threshold = ADC_val_current;
 723:../main.c     **** 					write_eeprom(EEPROM_LOWER_TH, ADC_lower_threshold, 4);
 724:../main.c     **** 					setup_state = SETUP_IDLE;
 725:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 726:../main.c     **** 					led_number_single = 3;
 727:../main.c     **** 					led_status_pattern = LED_NUMBER;
 728:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 729:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 730:../main.c     **** 				}
 731:../main.c     **** 				break;
 2936              	 .loc 5 731 0
 2937 04b4 92E0     	 b .L121
 2938              	.L141:
 709:../main.c     **** 					ADC_lower_threshold -= ADC_THRESHOLD_INCREMENT;
 2939              	 .loc 5 709 0
 2940 04b6 554B     	 ldr r3,.L156+28
 2941 04b8 1B78     	 ldrb r3,[r3]
 2942 04ba 012B     	 cmp r3,#1
 2943 04bc 19D1     	 bne .L143
 710:../main.c     **** 					// If minimum is reached blink led 2 times, then continue fading
 2944              	 .loc 5 710 0
 2945 04be 564B     	 ldr r3,.L156+40
 2946 04c0 1B68     	 ldr r3,[r3]
 2947 04c2 753B     	 sub r3,r3,#117
 2948 04c4 1A1C     	 mov r2,r3
 2949 04c6 544B     	 ldr r3,.L156+40
 2950 04c8 1A60     	 str r2,[r3]
 712:../main.c     **** 						ADC_lower_threshold = 0;
 2951              	 .loc 5 712 0
 2952 04ca 534B     	 ldr r3,.L156+40
 2953 04cc 1B68     	 ldr r3,[r3]
 2954 04ce 002B     	 cmp r3,#0
 2955 04d0 2FDC     	 bgt .L140
 713:../main.c     **** 						led_number_single = 2;
 2956              	 .loc 5 713 0
 2957 04d2 514B     	 ldr r3,.L156+40
 2958 04d4 0022     	 mov r2,#0
 2959 04d6 1A60     	 str r2,[r3]
 714:../main.c     **** 						led_status_pattern = LED_NUMBER;
 2960              	 .loc 5 714 0
 2961 04d8 484B     	 ldr r3,.L156+12
 2962 04da 0222     	 mov r2,#2
 2963 04dc 1A80     	 strh r2,[r3]
 715:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 2964              	 .loc 5 715 0
 2965 04de 484B     	 ldr r3,.L156+16
 2966 04e0 0222     	 mov r2,#2
 2967 04e2 1A70     	 strb r2,[r3]
 716:../main.c     **** 						led_status_pattern_after_single = LED_FADE_DOWN;
 2968              	 .loc 5 716 0
 2969 04e4 474B     	 ldr r3,.L156+20
 2970 04e6 0122     	 mov r2,#1
 2971 04e8 1A70     	 strb r2,[r3]
 717:../main.c     **** 					}
 2972              	 .loc 5 717 0
 2973 04ea 474B     	 ldr r3,.L156+24
 2974 04ec 0322     	 mov r2,#3
 2975 04ee 1A70     	 strb r2,[r3]
 2976              	 .loc 5 731 0
 2977 04f0 74E0     	 b .L121
 2978              	.L143:
 720:../main.c     **** 					// Save current ADC value as threshold
 2979              	 .loc 5 720 0
 2980 04f2 464B     	 ldr r3,.L156+28
 2981 04f4 1B78     	 ldrb r3,[r3]
 2982 04f6 032B     	 cmp r3,#3
 2983 04f8 1BD1     	 bne .L140
 722:../main.c     **** 					write_eeprom(EEPROM_LOWER_TH, ADC_lower_threshold, 4);
 2984              	 .loc 5 722 0
 2985 04fa 454B     	 ldr r3,.L156+32
 2986 04fc 1B68     	 ldr r3,[r3]
 2987 04fe 1A1C     	 mov r2,r3
 2988 0500 454B     	 ldr r3,.L156+40
 2989 0502 1A60     	 str r2,[r3]
 723:../main.c     **** 					setup_state = SETUP_IDLE;
 2990              	 .loc 5 723 0
 2991 0504 444B     	 ldr r3,.L156+40
 2992 0506 1B68     	 ldr r3,[r3]
 2993 0508 0120     	 mov r0,#1
 2994 050a 191C     	 mov r1,r3
 2995 050c 0422     	 mov r2,#4
 2996 050e FFF7FEFF 	 bl write_eeprom
 724:../main.c     **** 					// Blink LED 3 times (user info) and return to operation where led matches the state of the re
 2997              	 .loc 5 724 0
 2998 0512 404B     	 ldr r3,.L156+36
 2999 0514 0022     	 mov r2,#0
 3000 0516 1A70     	 strb r2,[r3]
 726:../main.c     **** 					led_status_pattern = LED_NUMBER;
 3001              	 .loc 5 726 0
 3002 0518 384B     	 ldr r3,.L156+12
 3003 051a 0322     	 mov r2,#3
 3004 051c 1A80     	 strh r2,[r3]
 727:../main.c     **** 					led_pattern_mode = LED_PATTERN_SINGLE;
 3005              	 .loc 5 727 0
 3006 051e 384B     	 ldr r3,.L156+16
 3007 0520 0222     	 mov r2,#2
 3008 0522 1A70     	 strb r2,[r3]
 728:../main.c     **** 					led_status_pattern_after_single = LED_MATCH_RELAY_STATE;
 3009              	 .loc 5 728 0
 3010 0524 374B     	 ldr r3,.L156+20
 3011 0526 0122     	 mov r2,#1
 3012 0528 1A70     	 strb r2,[r3]
 729:../main.c     **** 				}
 3013              	 .loc 5 729 0
 3014 052a 374B     	 ldr r3,.L156+24
 3015 052c 0522     	 mov r2,#5
 3016 052e 1A70     	 strb r2,[r3]
 3017              	 .loc 5 731 0
 3018 0530 54E0     	 b .L121
 3019              	.L140:
 3020              	 .loc 5 731 0 is_stmt 0 discriminator 3
 3021 0532 53E0     	 b .L121
 3022              	.L126:
 732:../main.c     **** 			case SETUP_TIME_TH:
 733:../main.c     **** 				/// Interpret button press:
 734:../main.c     **** 				// A long  press of up or down brings system back to setup idle
 735:../main.c     **** 				// A short press of up         increases the threshold exceed time
 736:../main.c     **** 				// A short press of down       decreases the threshold exceed time
 737:../main.c     **** 				if(buttonpress_up == BTNPRESS_LONG || buttonpress_down == BTNPRESS_LONG){
 3023              	 .loc 5 737 0 is_stmt 1
 3024 0534 2E4B     	 ldr r3,.L156
 3025 0536 1B78     	 ldrb r3,[r3]
 3026 0538 022B     	 cmp r3,#2
 3027 053a 03D0     	 beq .L145
 3028              	 .loc 5 737 0 is_stmt 0 discriminator 1
 3029 053c 334B     	 ldr r3,.L156+28
 3030 053e 1B78     	 ldrb r3,[r3]
 3031 0540 022B     	 cmp r3,#2
 3032 0542 0DD1     	 bne .L146
 3033              	.L145:
 738:../main.c     **** 					write_eeprom(EEPROM_LATCHTIME, relay_threshold_latchtime, 4);
 3034              	 .loc 5 738 0 is_stmt 1
 3035 0544 354B     	 ldr r3,.L156+44
 3036 0546 1B68     	 ldr r3,[r3]
 3037 0548 0320     	 mov r0,#3
 3038 054a 191C     	 mov r1,r3
 3039 054c 0422     	 mov r2,#4
 3040 054e FFF7FEFF 	 bl write_eeprom
 739:../main.c     **** 					setup_state = SETUP_IDLE;
 3041              	 .loc 5 739 0
 3042 0552 304B     	 ldr r3,.L156+36
 3043 0554 0022     	 mov r2,#0
 3044 0556 1A70     	 strb r2,[r3]
 740:../main.c     **** 					led_status_pattern = LED_MATCH_RELAY_STATE;
 3045              	 .loc 5 740 0
 3046 0558 294B     	 ldr r3,.L156+16
 3047 055a 0522     	 mov r2,#5
 3048 055c 1A70     	 strb r2,[r3]
 3049 055e 3CE0     	 b .L147
 3050              	.L146:
 741:../main.c     **** 				}
 742:../main.c     **** 				else if(buttonpress_up == BTNPRESS_STD){
 3051              	 .loc 5 742 0
 3052 0560 234B     	 ldr r3,.L156
 3053 0562 1B78     	 ldrb r3,[r3]
 3054 0564 012B     	 cmp r3,#1
 3055 0566 1AD1     	 bne .L148
 743:../main.c     **** 					relay_threshold_latchtime += RELAY_LATCHTIME_INCREMENT;
 3056              	 .loc 5 743 0
 3057 0568 2C4B     	 ldr r3,.L156+44
 3058 056a 1B68     	 ldr r3,[r3]
 3059 056c FA33     	 add r3,r3,#250
 3060 056e 1A1C     	 mov r2,r3
 3061 0570 2A4B     	 ldr r3,.L156+44
 3062 0572 1A60     	 str r2,[r3]
 744:../main.c     **** 					if(relay_threshold_latchtime > RELAY_LATCHTIME_MAX){
 3063              	 .loc 5 744 0
 3064 0574 294B     	 ldr r3,.L156+44
 3065 0576 1B68     	 ldr r3,[r3]
 3066 0578 294A     	 ldr r2,.L156+48
 3067 057a 9342     	 cmp r3,r2
 3068 057c 2DDD     	 ble .L147
 745:../main.c     **** 						relay_threshold_latchtime = RELAY_LATCHTIME_MAX;
 3069              	 .loc 5 745 0
 3070 057e 274B     	 ldr r3,.L156+44
 3071 0580 274A     	 ldr r2,.L156+48
 3072 0582 1A60     	 str r2,[r3]
 746:../main.c     **** 						led_number_single = 2;
 3073              	 .loc 5 746 0
 3074 0584 1D4B     	 ldr r3,.L156+12
 3075 0586 0222     	 mov r2,#2
 3076 0588 1A80     	 strh r2,[r3]
 747:../main.c     **** 						led_status_pattern = LED_NUMBER;
 3077              	 .loc 5 747 0
 3078 058a 1D4B     	 ldr r3,.L156+16
 3079 058c 0222     	 mov r2,#2
 3080 058e 1A70     	 strb r2,[r3]
 748:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 3081              	 .loc 5 748 0
 3082 0590 1C4B     	 ldr r3,.L156+20
 3083 0592 0122     	 mov r2,#1
 3084 0594 1A70     	 strb r2,[r3]
 749:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 3085              	 .loc 5 749 0
 3086 0596 1C4B     	 ldr r3,.L156+24
 3087 0598 0222     	 mov r2,#2
 3088 059a 1A70     	 strb r2,[r3]
 750:../main.c     **** 					}
 751:../main.c     **** 				}
 752:../main.c     **** 				else if(buttonpress_down == BTNPRESS_STD){
 753:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 754:../main.c     **** 					if(relay_threshold_latchtime <= 0){
 755:../main.c     **** 						relay_threshold_latchtime = 0;
 756:../main.c     **** 						led_number_single = 2;
 757:../main.c     **** 						led_status_pattern = LED_NUMBER;
 758:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 759:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 760:../main.c     **** 					}
 761:../main.c     **** 				}
 762:../main.c     **** 				break;
 3089              	 .loc 5 762 0
 3090 059c 1DE0     	 b .L153
 3091              	.L148:
 752:../main.c     **** 					relay_threshold_latchtime -= RELAY_LATCHTIME_INCREMENT;
 3092              	 .loc 5 752 0
 3093 059e 1B4B     	 ldr r3,.L156+28
 3094 05a0 1B78     	 ldrb r3,[r3]
 3095 05a2 012B     	 cmp r3,#1
 3096 05a4 19D1     	 bne .L147
 753:../main.c     **** 					if(relay_threshold_latchtime <= 0){
 3097              	 .loc 5 753 0
 3098 05a6 1D4B     	 ldr r3,.L156+44
 3099 05a8 1B68     	 ldr r3,[r3]
 3100 05aa FA3B     	 sub r3,r3,#250
 3101 05ac 1A1C     	 mov r2,r3
 3102 05ae 1B4B     	 ldr r3,.L156+44
 3103 05b0 1A60     	 str r2,[r3]
 754:../main.c     **** 						relay_threshold_latchtime = 0;
 3104              	 .loc 5 754 0
 3105 05b2 1A4B     	 ldr r3,.L156+44
 3106 05b4 1B68     	 ldr r3,[r3]
 3107 05b6 002B     	 cmp r3,#0
 3108 05b8 0FDC     	 bgt .L147
 755:../main.c     **** 						led_number_single = 2;
 3109              	 .loc 5 755 0
 3110 05ba 184B     	 ldr r3,.L156+44
 3111 05bc 0022     	 mov r2,#0
 3112 05be 1A60     	 str r2,[r3]
 756:../main.c     **** 						led_status_pattern = LED_NUMBER;
 3113              	 .loc 5 756 0
 3114 05c0 0E4B     	 ldr r3,.L156+12
 3115 05c2 0222     	 mov r2,#2
 3116 05c4 1A80     	 strh r2,[r3]
 757:../main.c     **** 						led_pattern_mode = LED_PATTERN_SINGLE;
 3117              	 .loc 5 757 0
 3118 05c6 0E4B     	 ldr r3,.L156+16
 3119 05c8 0222     	 mov r2,#2
 3120 05ca 1A70     	 strb r2,[r3]
 758:../main.c     **** 						led_status_pattern_after_single = LED_NUMBER;
 3121              	 .loc 5 758 0
 3122 05cc 0D4B     	 ldr r3,.L156+20
 3123 05ce 0122     	 mov r2,#1
 3124 05d0 1A70     	 strb r2,[r3]
 759:../main.c     **** 					}
 3125              	 .loc 5 759 0
 3126 05d2 0D4B     	 ldr r3,.L156+24
 3127 05d4 0222     	 mov r2,#2
 3128 05d6 1A70     	 strb r2,[r3]
 3129              	 .loc 5 762 0
 3130 05d8 FFE7     	 b .L153
 3131              	.L147:
 3132              	.L153:
 3133 05da C046     	 mov r8,r8
 3134              	.L121:
 763:../main.c     **** 		}
 764:../main.c     **** 
 765:../main.c     **** 		// Reset all button presses
 766:../main.c     **** 		buttonpress_usb = BTNPRESS_NOT;
 3135              	 .loc 5 766 0
 3136 05dc 114B     	 ldr r3,.L156+52
 3137 05de 0022     	 mov r2,#0
 3138 05e0 1A70     	 strb r2,[r3]
 767:../main.c     **** 		buttonpress_up = BTNPRESS_NOT;
 3139              	 .loc 5 767 0
 3140 05e2 034B     	 ldr r3,.L156
 3141 05e4 0022     	 mov r2,#0
 3142 05e6 1A70     	 strb r2,[r3]
 768:../main.c     **** 		buttonpress_down = BTNPRESS_NOT;
 3143              	 .loc 5 768 0
 3144 05e8 084B     	 ldr r3,.L156+28
 3145 05ea 0022     	 mov r2,#0
 3146 05ec 1A70     	 strb r2,[r3]
 769:../main.c     **** 	}
 3147              	 .loc 5 769 0
 3148 05ee 56E5     	 b .L150
 3149              	.L157:
 3150              	 .align 2
 3151              	.L156:
 3152 05f0 00000000 	 .word buttonpress_up
 3153 05f4 00000000 	 .word ADC_upper_threshold
 3154 05f8 FF0F0000 	 .word 4095
 3155 05fc 00000000 	 .word led_number_single
 3156 0600 00000000 	 .word led_status_pattern
 3157 0604 00000000 	 .word led_pattern_mode
 3158 0608 00000000 	 .word led_status_pattern_after_single
 3159 060c 00000000 	 .word buttonpress_down
 3160 0610 00000000 	 .word ADC_val_current
 3161 0614 00000000 	 .word setup_state
 3162 0618 00000000 	 .word ADC_lower_threshold
 3163 061c 00000000 	 .word relay_threshold_latchtime
 3164 0620 60EA0000 	 .word 60000
 3165 0624 00000000 	 .word buttonpress_usb
 3166              	 .cfi_endproc
 3167              	.LFE167:
 3169              	 .global meas_invalid_count
 3170              	 .section .bss.meas_invalid_count,"aw",%nobits
 3171              	 .align 2
 3174              	meas_invalid_count:
 3175 0000 00000000 	 .space 4
 3176              	 .section .text.VADC0_C0_0_IRQHandler,"ax",%progbits
 3177              	 .align 2
 3178              	 .global VADC0_C0_0_IRQHandler
 3179              	 .code 16
 3180              	 .thumb_func
 3182              	VADC0_C0_0_IRQHandler:
 3183              	.LFB168:
 770:../main.c     **** }
 771:../main.c     **** 
 772:../main.c     **** int meas_invalid_count = 0;
 773:../main.c     **** 
 774:../main.c     **** void Adc_Measurement_Handler()
 775:../main.c     **** {
 3184              	 .loc 5 775 0
 3185              	 .cfi_startproc
 3186 0000 80B5     	 push {r7,lr}
 3187              	.LCFI47:
 3188              	 .cfi_def_cfa_offset 8
 3189              	 .cfi_offset 7,-8
 3190              	 .cfi_offset 14,-4
 3191 0002 82B0     	 sub sp,sp,#8
 3192              	.LCFI48:
 3193              	 .cfi_def_cfa_offset 16
 3194 0004 00AF     	 add r7,sp,#0
 3195              	.LCFI49:
 3196              	 .cfi_def_cfa_register 7
 776:../main.c     **** 	//uint8_t channel_num;
 777:../main.c     **** 	//uint8_t group_num;
 778:../main.c     **** 	uint32_t adc_register;
 779:../main.c     **** 
 780:../main.c     **** 	#if(UC_SERIES == XMC11)
 781:../main.c     **** 	adc_register = ADC_MEASUREMENT_GetGlobalDetailedResult();
 3197              	 .loc 5 781 0
 3198 0006 FFF7FEFF 	 bl ADC_MEASUREMENT_GetGlobalDetailedResult
 3199 000a 031C     	 mov r3,r0
 3200 000c 7B60     	 str r3,[r7,#4]
 782:../main.c     **** 	#endif
 783:../main.c     **** 
 784:../main.c     **** 	if((bool)(adc_register >> VADC_GLOBRES_VF_Pos))
 3201              	 .loc 5 784 0
 3202 000e 7B68     	 ldr r3,[r7,#4]
 3203 0010 002B     	 cmp r3,#0
 3204 0012 0DDA     	 bge .L159
 785:../main.c     **** 	{
 786:../main.c     **** 		//channel_num = (adc_register & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos;
 787:../main.c     **** 		//group_num = ADC_MEASUREMENT_Channel_A.group_index;
 788:../main.c     **** 		ADC_val_current = (adc_register & VADC_GLOBRES_RESULT_Msk) >> ((uint32_t)(ADC_SENSOR.iclass_confi
 3205              	 .loc 5 788 0
 3206 0014 7B68     	 ldr r3,[r7,#4]
 3207 0016 1B04     	 lsl r3,r3,#16
 3208 0018 1A0C     	 lsr r2,r3,#16
 3209 001a 094B     	 ldr r3,.L161
 3210 001c 9B68     	 ldr r3,[r3,#8]
 3211 001e 5B78     	 ldrb r3,[r3,#1]
 3212 0020 5B07     	 lsl r3,r3,#29
 3213 0022 5B0F     	 lsr r3,r3,#29
 3214 0024 DBB2     	 uxtb r3,r3
 3215 0026 5B00     	 lsl r3,r3,#1
 3216 0028 DA40     	 lsr r2,r2,r3
 3217 002a 064B     	 ldr r3,.L161+4
 3218 002c 1A60     	 str r2,[r3]
 3219 002e 04E0     	 b .L158
 3220              	.L159:
 789:../main.c     **** 	}
 790:../main.c     **** 	else{
 791:../main.c     **** 		meas_invalid_count++;
 3221              	 .loc 5 791 0
 3222 0030 054B     	 ldr r3,.L161+8
 3223 0032 1B68     	 ldr r3,[r3]
 3224 0034 5A1C     	 add r2,r3,#1
 3225 0036 044B     	 ldr r3,.L161+8
 3226 0038 1A60     	 str r2,[r3]
 3227              	.L158:
 792:../main.c     **** 	}
 793:../main.c     **** 
 794:../main.c     **** 	//	ADC_val_current = ADC_MEASUREMENT_GetGlobalResult();
 795:../main.c     **** 	//	ADC_val_current = ADC_val_current >> ((uint32_t)ADC_SENSOR.iclass_config_handle->conversion_mod
 796:../main.c     **** }
 3228              	 .loc 5 796 0
 3229 003a BD46     	 mov sp,r7
 3230 003c 02B0     	 add sp,sp,#8
 3231              	 
 3232 003e 80BD     	 pop {r7,pc}
 3233              	.L162:
 3234              	 .align 2
 3235              	.L161:
 3236 0040 00000000 	 .word ADC_SENSOR
 3237 0044 00000000 	 .word ADC_val_current
 3238 0048 00000000 	 .word meas_invalid_count
 3239              	 .cfi_endproc
 3240              	.LFE168:
 3242              	 .section .bss.led_pattern_state_timestamp.7189,"aw",%nobits
 3243              	 .align 2
 3246              	led_pattern_state_timestamp.7189:
 3247 0000 00000000 	 .space 4
 3248              	 .section .bss.led_pattern_state_length.7190,"aw",%nobits
 3249              	 .align 1
 3252              	led_pattern_state_length.7190:
 3253 0000 0000     	 .space 2
 3254              	 .section .bss.led_pattern_state.7188,"aw",%nobits
 3255              	 .align 1
 3258              	led_pattern_state.7188:
 3259 0000 0000     	 .space 2
 3260              	 .section .bss.fade_duty_step.7191,"aw",%nobits
 3261              	 .align 1
 3264              	fade_duty_step.7191:
 3265 0000 0000     	 .space 2
 3266              	 .text
 3267              	.Letext0:
 3268              	 .file 6 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3269              	 .file 7 "c:\\workspaces\\4.5.0\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3270              	 .file 8 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 3271              	 .file 9 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_scu.h"
 3272              	 .file 10 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_ADC/global_adc.h"
 3273              	 .file 11 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc1_gpio.h"
 3274              	 .file 12 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/XMCLib/inc/xmc_ccu4.h"
 3275              	 .file 13 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/GLOBAL_CCU4/global_ccu4.h"
 3276              	 .file 14 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4.h"
 3277              	 .file 15 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DAVE.h"
 3278              	 .file 16 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Include/cmsis_gcc.h"
 3279              	 .file 17 "C:/Workspaces/DAVE_WS/USB_Changer/Libraries/CMSIS/Infineon/XMC1100_series/Include/system_XMC1100.h"
 3280              	 .file 18 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/ADC_MEASUREMENT/adc_measurement_extern.h"
 3281              	 .file 19 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/DIGITAL_IO/digital_io_extern.h"
 3282              	 .file 20 "C:/Workspaces/DAVE_WS/USB_Changer/Dave/Generated/PWM_CCU4/pwm_ccu4_extern.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:18     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 $t
    {standard input}:22     .text.XMC_VADC_GLOBAL_GetDetailedResult:00000000 XMC_VADC_GLOBAL_GetDetailedResult
    {standard input}:54     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 $t
    {standard input}:58     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:00000000 ADC_MEASUREMENT_GetGlobalDetailedResult
    {standard input}:91     .text.ADC_MEASUREMENT_GetGlobalDetailedResult:0000001c $d
    {standard input}:96     .text.XMC_GPIO_SetOutputHigh:00000000 $t
    {standard input}:100    .text.XMC_GPIO_SetOutputHigh:00000000 XMC_GPIO_SetOutputHigh
    {standard input}:136    .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:140    .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:176    .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:180    .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
    {standard input}:218    .text.DIGITAL_IO_SetOutputHigh:00000000 $t
    {standard input}:222    .text.DIGITAL_IO_SetOutputHigh:00000000 DIGITAL_IO_SetOutputHigh
    {standard input}:256    .text.DIGITAL_IO_SetOutputLow:00000000 $t
    {standard input}:260    .text.DIGITAL_IO_SetOutputLow:00000000 DIGITAL_IO_SetOutputLow
    {standard input}:293    .text.DIGITAL_IO_GetInput:00000000 $t
    {standard input}:297    .text.DIGITAL_IO_GetInput:00000000 DIGITAL_IO_GetInput
    {standard input}:336    .data.relay_threshold_latchtime:00000000 relay_threshold_latchtime
    {standard input}:333    .data.relay_threshold_latchtime:00000000 $d
    {standard input}:343    .data.ADC_upper_threshold:00000000 ADC_upper_threshold
    {standard input}:340    .data.ADC_upper_threshold:00000000 $d
    {standard input}:350    .data.ADC_lower_threshold:00000000 ADC_lower_threshold
    {standard input}:347    .data.ADC_lower_threshold:00000000 $d
    {standard input}:356    .bss.USB_state:00000000 USB_state
    {standard input}:357    .bss.USB_state:00000000 $d
    {standard input}:362    .data.relay_state:00000000 relay_state
    {standard input}:368    .bss.setup_state:00000000 setup_state
    {standard input}:369    .bss.setup_state:00000000 $d
    {standard input}:375    .bss.usb_changed_timestamp:00000000 usb_changed_timestamp
    {standard input}:372    .bss.usb_changed_timestamp:00000000 $d
    {standard input}:381    .bss.led_status_pattern:00000000 led_status_pattern
    {standard input}:382    .bss.led_status_pattern:00000000 $d
    {standard input}:387    .bss.led_status_pattern_last:00000000 led_status_pattern_last
    {standard input}:388    .bss.led_status_pattern_last:00000000 $d
    {standard input}:393    .bss.led_pattern_mode:00000000 led_pattern_mode
    {standard input}:394    .bss.led_pattern_mode:00000000 $d
    {standard input}:399    .bss.led_status_pattern_after_single:00000000 led_status_pattern_after_single
    {standard input}:400    .bss.led_status_pattern_after_single:00000000 $d
    {standard input}:406    .bss.led_number_continuous:00000000 led_number_continuous
    {standard input}:403    .bss.led_number_continuous:00000000 $d
    {standard input}:413    .bss.led_number_single:00000000 led_number_single
    {standard input}:410    .bss.led_number_single:00000000 $d
    {standard input}:420    .data.led_fadetime:00000000 led_fadetime
    {standard input}:417    .data.led_fadetime:00000000 $d
    {standard input}:427    .data.led_fadesteps:00000000 led_fadesteps
    {standard input}:424    .data.led_fadesteps:00000000 $d
    {standard input}:433    .bss.buttonpress_usb:00000000 buttonpress_usb
    {standard input}:434    .bss.buttonpress_usb:00000000 $d
    {standard input}:439    .bss.buttonpress_up:00000000 buttonpress_up
    {standard input}:440    .bss.buttonpress_up:00000000 $d
    {standard input}:445    .bss.buttonpress_down:00000000 buttonpress_down
    {standard input}:446    .bss.buttonpress_down:00000000 $d
    {standard input}:452    .bss.button_usb_pressed_timestamp:00000000 button_usb_pressed_timestamp
    {standard input}:449    .bss.button_usb_pressed_timestamp:00000000 $d
    {standard input}:459    .bss.button_up_pressed_timestamp:00000000 button_up_pressed_timestamp
    {standard input}:456    .bss.button_up_pressed_timestamp:00000000 $d
    {standard input}:466    .bss.button_down_pressed_timestamp:00000000 button_down_pressed_timestamp
    {standard input}:463    .bss.button_down_pressed_timestamp:00000000 $d
    {standard input}:473    .bss.button_usb_pressed_duration:00000000 button_usb_pressed_duration
    {standard input}:470    .bss.button_usb_pressed_duration:00000000 $d
    {standard input}:480    .bss.button_up_pressed_duration:00000000 button_up_pressed_duration
    {standard input}:477    .bss.button_up_pressed_duration:00000000 $d
    {standard input}:487    .bss.button_down_pressed_duration:00000000 button_down_pressed_duration
    {standard input}:484    .bss.button_down_pressed_duration:00000000 $d
    {standard input}:494    .bss.ADC_val_current:00000000 ADC_val_current
    {standard input}:491    .bss.ADC_val_current:00000000 $d
    {standard input}:501    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 ADC_val_upper_thres_exceed_timestamp
    {standard input}:498    .bss.ADC_val_upper_thres_exceed_timestamp:00000000 $d
    {standard input}:508    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 ADC_val_lower_thres_exceed_timestamp
    {standard input}:505    .bss.ADC_val_lower_thres_exceed_timestamp:00000000 $d
    {standard input}:515    .bss.systime_debug:00000000 systime_debug
    {standard input}:512    .bss.systime_debug:00000000 $d
    {standard input}:522    .bss.eeprom_latchtime:00000000 eeprom_latchtime
    {standard input}:519    .bss.eeprom_latchtime:00000000 $d
    {standard input}:529    .bss.eeprom_upper:00000000 eeprom_upper
    {standard input}:526    .bss.eeprom_upper:00000000 $d
    {standard input}:536    .bss.eeprom_lower:00000000 eeprom_lower
    {standard input}:533    .bss.eeprom_lower:00000000 $d
    {standard input}:543    .bss.eeprom_usb_state:00000000 eeprom_usb_state
    {standard input}:540    .bss.eeprom_usb_state:00000000 $d
    {standard input}:546    .text.delay_ms:00000000 $t
    {standard input}:551    .text.delay_ms:00000000 delay_ms
    {standard input}:601    .text.reset_status_led_to_relay_state:00000000 $t
    {standard input}:606    .text.reset_status_led_to_relay_state:00000000 reset_status_led_to_relay_state
    {standard input}:661    .text.reset_status_led_to_relay_state:00000044 $d
    {standard input}:670    .text.manage_status_led:00000000 $t
    {standard input}:675    .text.manage_status_led:00000000 manage_status_led
    {standard input}:712    .rodata.manage_status_led:00000000 $d
    {standard input}:1144   .text.manage_status_led:000002e0 $d
    {standard input}:3246   .bss.led_pattern_state_timestamp.7189:00000000 led_pattern_state_timestamp.7189
    {standard input}:3252   .bss.led_pattern_state_length.7190:00000000 led_pattern_state_length.7190
    {standard input}:3258   .bss.led_pattern_state.7188:00000000 led_pattern_state.7188
    {standard input}:3264   .bss.fade_duty_step.7191:00000000 fade_duty_step.7191
    {standard input}:1162   .text.manage_status_led:00000320 $t
    {standard input}:1275   .text.manage_status_led:000003e0 $d
    {standard input}:1289   .text.read_eeprom_setup:00000000 $t
    {standard input}:1294   .text.read_eeprom_setup:00000000 read_eeprom_setup
    {standard input}:1627   .text.read_eeprom_setup:00000238 $d
    {standard input}:1644   .text.write_eeprom:00000000 $t
    {standard input}:1649   .text.write_eeprom:00000000 write_eeprom
    {standard input}:1726   .text.manage_buttons:00000000 $t
    {standard input}:1731   .text.manage_buttons:00000000 manage_buttons
    {standard input}:2092   .text.manage_buttons:00000244 $d
    {standard input}:2111   .text.switchUSB:00000000 $t
    {standard input}:2116   .text.switchUSB:00000000 switchUSB
    {standard input}:2196   .text.switchUSB:00000078 $d
    {standard input}:2205   .text.main:00000000 $t
    {standard input}:2210   .text.main:00000000 main
    {standard input}:2720   .text.main:00000330 $d
    {standard input}:2746   .text.main:00000390 $t
    {standard input}:3152   .text.main:000005f0 $d
    {standard input}:3174   .bss.meas_invalid_count:00000000 meas_invalid_count
    {standard input}:3171   .bss.meas_invalid_count:00000000 $d
    {standard input}:3177   .text.VADC0_C0_0_IRQHandler:00000000 $t
    {standard input}:3182   .text.VADC0_C0_0_IRQHandler:00000000 VADC0_C0_0_IRQHandler
    {standard input}:3236   .text.VADC0_C0_0_IRQHandler:00000040 $d
    {standard input}:3243   .bss.led_pattern_state_timestamp.7189:00000000 $d
    {standard input}:3249   .bss.led_pattern_state_length.7190:00000000 $d
    {standard input}:3255   .bss.led_pattern_state.7188:00000000 $d
    {standard input}:3261   .bss.fade_duty_step.7191:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SYSTIMER_GetTime
PWM_CCU4_SetDutyCycle
IO_RELAY
PWM_CCU4_LED_STATUS
__aeabi_uidiv
E_EEPROM_XMC1_Read
E_EEPROM_XMC1_Write
IO_SW_USB
IO_SW_UP
IO_SW_DOWN
IO_USBPWR_2
IO_USB_SI
IO_LED_USB1
IO_LED_USB2
IO_USBPWR_1
DAVE_Init
ADC_MEASUREMENT_StartConversion
IO_USB_OE
ADC_SENSOR
